'use strict';

function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
  : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
  var core = module.exports = {
    version: '2.6.5' };

  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
var _core_1 = _core.version;

var _isObject = function _isObject(it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function _anObject(it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function _fails(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    } }).
  a != 7;
});

var document$1 = _global.document; // typeof document.createElement is 'object' in old IE

var is = _isObject(document$1) && _isObject(document$1.createElement);

var _domCreate = function _domCreate(it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', {
    get: function get() {
      return 7;
    } }).
  a != 7;
});

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string

var _toPrimitive = function _toPrimitive(it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;
var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
var _objectDp = {
  f: f };


var _propertyDesc = function _propertyDesc(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value };

};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;

var _has = function _has(it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();

var _uid = function _uid(key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _library = false;

var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});
  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode: 'global',
    copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)' });

});

var _functionToString = _shared('native-function-to-string', Function.toString);

var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');
  var TO_STRING = 'toString';
  var TPL = ('' + _functionToString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return _functionToString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || _functionToString.call(this);
  });
});

var _aFunction = function _aFunction(it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

var _ctx = function _ctx(fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };}


  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // extend global

    if (target) _redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

_global.core = _core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

var _export = $export;

var toString = {}.toString;

var _cof = function _cof(it) {
  return toString.call(it).slice(8, -1);
};

var _isArray = Array.isArray || function isArray(arg) {
  return _cof(arg) == 'Array';
};

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

var _toInteger = function _toInteger(it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

var min = Math.min;

var _toLength = function _toLength(it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');
  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
});

var IS_CONCAT_SPREADABLE = _wks('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? _ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (_isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : _isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, _toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

var _flattenIntoArray = flattenIntoArray;

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function _defined(it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

var _toObject = function _toObject(it) {
  return Object(_defined(it));
};

var SPECIES = _wks('species');

var _arraySpeciesConstructor = function _arraySpeciesConstructor(original) {
  var C;

  if (_isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;

    if (_isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

var _arraySpeciesCreate = function _arraySpeciesCreate(original, length) {
  return new (_arraySpeciesConstructor(original))(length);
};

var UNSCOPABLES = _wks('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});

var _addToUnscopables = function _addToUnscopables(key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

_export(_export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */)
  {
    var O = _toObject(this);
    var sourceLen, A;
    _aFunction(callbackfn);
    sourceLen = _toLength(O.length);
    A = _arraySpeciesCreate(O, 0);
    _flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  } });

_addToUnscopables('flatMap');

var _iterCall = function _iterCall(iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

var _iterators = {};

var ITERATOR = _wks('iterator');
var ArrayProto$1 = Array.prototype;

var _isArrayIter = function _isArrayIter(it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR] === it);
};

var _createProperty = function _createProperty(object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
};

var TAG = _wks('toStringTag'); // ES3 wrong here

var ARG = _cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

var _classof = function _classof(it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? _cof(O) // ES3 arguments fallback
  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var ITERATOR$1 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$1] || it['@@iterator'] || _iterators[_classof(it)];
};

var ITERATOR$2 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$2]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

var _iterDetect = function _iterDetect(exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR$2]();

    iter.next = function () {
      return {
        done: safe = true };

    };

    arr[ITERATOR$2] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

_export(_export.S + _export.F * !_iterDetect(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */)
  {
    var O = _toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);

      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  } });


// eslint-disable-next-line no-prototype-builtins

var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

var _toIobject = function _toIobject(it) {
  return _iobject(_defined(it));
};

var max = Math.max;
var min$1 = Math.min;

var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// true  -> Array#includes

var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }
    return !IS_INCLUDES && -1;
  };
};

var $includes = _arrayIncludes(true);
_export(_export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */)
  {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  } });

_addToUnscopables('includes');

var _strictMethod = function _strictMethod(method, arg) {
  return !!method && _fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

var $sort = [].sort;
var test = [1, 2, 3];
_export(_export.P + _export.F * (_fails(function () {
  // IE8-
  test.sort(undefined);
}) || !_fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !_strictMethod($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(_toObject(this)) : $sort.call(_toObject(this), _aFunction(comparefn));
  } });


var SPECIES$1 = _wks('species');

var _setSpecies = function _setSpecies(KEY) {
  var C = _global[KEY];
  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
    configurable: true,
    get: function get() {
      return this;
    } });

};

_setSpecies('Array');

_export(_export.P + _export.F * _fails(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function toISOString() {
      return 1;
    } }) !==
  1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = _toObject(this);
    var pv = _toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  } });


var NUMBER = 'number';

var _dateToPrimitive = function _dateToPrimitive(hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return _toPrimitive(_anObject(this), hint != NUMBER);
};

var TO_PRIMITIVE = _wks('toPrimitive');
var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) _hide(proto, TO_PRIMITIVE, _dateToPrimitive);

var shared = _shared('keys');

var _sharedKey = function _sharedKey(key) {
  return shared[key] || (shared[key] = _uid(key));
};

var IE_PROTO = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

var HAS_INSTANCE = _wks('hasInstance');
var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) _objectDp.f(FunctionProto, HAS_INSTANCE, {
  value: function value(O) {
    if (typeof this != 'function' || !_isObject(O)) return false;
    if (!_isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = _objectGpo(O)) {
      if (this.prototype === O) return true;
    }

    return false;
  } });


var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO$1 = _sharedKey('IE_PROTO');

var _objectKeysInternal = function _objectKeysInternal(object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    if (key != IE_PROTO$1) _has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }

  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) {
    _objectDp.f(O, P = keys[i++], Properties[P]);
  }

  return O;
};

var document$2 = _global.document;

var _html = document$2 && document$2.documentElement;

var IE_PROTO$2 = _sharedKey('IE_PROTO');

var Empty = function Empty() {
  /* empty */
};

var PROTOTYPE$1 = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (i--) {
    delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
  }

  return _createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO$2] = O;
  } else result = _createDict();

  return Properties === undefined ? result : _objectDps(result, Properties);
};

var _redefineAll = function _redefineAll(target, src, safe) {
  for (var key in src) {
    _redefine(target, key, src[key], safe);
  }

  return target;
};

var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};

  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () {
      return iterable;
    } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };

  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
});

var def = _objectDp.f;
var TAG$1 = _wks('toStringTag');

var _setToStringTag = function _setToStringTag(it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, {
    configurable: true,
    value: tag });

};

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

_hide(IteratorPrototype, _wks('iterator'), function () {
  return this;
});

var _iterCreate = function _iterCreate(Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, {
    next: _propertyDesc(1, next) });

  _setToStringTag(Constructor, NAME + ' Iterator');
};

var ITERATOR$3 = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);

  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };}


    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR$3] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (typeof IteratorPrototype[ITERATOR$3] != 'function') _hide(IteratorPrototype, ITERATOR$3, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if (BUGGY || VALUES_BUG || !proto[ITERATOR$3]) {
    _hide(proto, ITERATOR$3, $default);
  } // Plug for library


  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries };

    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

var _iterStep = function _iterStep(done, value) {
  return {
    value: value,
    done: !!done };

};

var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');
  var setDesc = _objectDp.f;
  var id = 0;

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });

  var setMeta = function setMeta(it) {
    setDesc(it, META, {
      value: {
        i: 'O' + ++id,
        // object ID
        w: {} // weak collections IDs
      } });


  };

  var fastKey = function fastKey(it, create) {
    // return primitive with prefix
    if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMeta(it); // return object ID
    }

    return it[META].i;
  };

  var getWeak = function getWeak(it, create) {
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMeta(it); // return hash weak collections IDs
    }

    return it[META].w;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function onFreeze(it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };

  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze };

});
var _meta_1 = _meta.KEY;
var _meta_2 = _meta.NEED;
var _meta_3 = _meta.fastKey;
var _meta_4 = _meta.getWeak;
var _meta_5 = _meta.onFreeze;

var _validateCollection = function _validateCollection(it, TYPE) {
  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

var dP$1 = _objectDp.f;
var fastKey = _meta.fastKey;
var SIZE = _descriptors ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

var _collectionStrong = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      _anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = _objectCreate(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
    });
    _redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = _validateCollection(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */)
      {
        _validateCollection(this, NAME);
        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(_validateCollection(this, NAME), key);
      } });

    if (_descriptors) dP$1(C.prototype, 'size', {
      get: function get() {
        return _validateCollection(this, NAME)[SIZE];
      } });

    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed
      };

      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    _iterDefine(C, NAME, function (iterated, kind) {
      this._t = _validateCollection(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return _iterStep(1);
      } // return step by kind


      if (kind == 'keys') return _iterStep(0, entry.k);
      if (kind == 'values') return _iterStep(0, entry.v);
      return _iterStep(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    _setSpecies(NAME);
  } };


var f$1 = {}.propertyIsEnumerable;
var _objectPie = {
  f: f$1 };


var gOPD = Object.getOwnPropertyDescriptor;
var f$2 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};
var _objectGopd = {
  f: f$2 };


/* eslint-disable no-proto */

var check = function check(O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check };


var setPrototypeOf = _setProto.set;

var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = _global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    _redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    _redefineAll(C.prototype, methods);
    _meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = _fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = _iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME);
        var that = _inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  _setToStringTag(C, NAME);
  O[NAME] = C;
  _export(_export.G + _export.W + _export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

var MAP = 'Map'; // 23.1 Map Objects

var es6_map = _collection(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
  } },
_collectionStrong, true);

var f$3 = Object.getOwnPropertySymbols;
var _objectGops = {
  f: f$3 };


var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = _toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = _objectGops.f;
  var isEnum = _objectPie.f;

  while (aLen > index) {
    var S = _iobject(arguments[index++]);
    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }

  return T;
} : $assign;

_export(_export.S + _export.F, 'Object', {
  assign: _objectAssign });


var isEnum = _objectPie.f;

var _objectToArray = function _objectToArray(isEntries) {
  return function (it) {
    var O = _toIobject(it);
    var keys = _objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      if (isEnum.call(O, key = keys[i++])) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

var $entries = _objectToArray(true);
_export(_export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  } });


var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return _objectKeysInternal(O, hiddenKeys);
};

var _objectGopn = {
  f: f$4 };


var Reflect$1 = _global.Reflect;

var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
  var keys = _objectGopn.f(_anObject(it));
  var getSymbols = _objectGops.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

_export(_export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = _toIobject(object);
    var getDesc = _objectGopd.f;
    var keys = _ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) _createProperty(result, key, desc);
    }

    return result;
  } });


var test$1 = {};
test$1[_wks('toStringTag')] = 'z';

if (test$1 + '' != '[object z]') {
  _redefine(Object.prototype, 'toString', function toString() {
    return '[object ' + _classof(this) + ']';
  }, true);
}

var $values = _objectToArray(false);
_export(_export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  } });


var SPECIES$2 = _wks('species');

var _speciesConstructor = function _speciesConstructor(O, D) {
  var C = _anObject(O).constructor;
  var S;
  return C === undefined || (S = _anObject(C)[SPECIES$2]) == undefined ? D : _aFunction(S);
};

// fast apply, http://jsperf.lnkit.com/fast-apply/5
var _invoke = function _invoke(fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);}


  return fn.apply(that, args);
};

var process$1 = _global.process;
var setTask = _global.setImmediate;
var clearTask = _global.clearImmediate;
var MessageChannel = _global.MessageChannel;
var Dispatch = _global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function run() {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (_cof(process$1) == 'process') {
    defer = function defer(id) {
      process$1.nextTick(_ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(_ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = _ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
    defer = function defer(id) {
      _global.postMessage(id + '', '*');
    };

    _global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
    defer = function defer(id) {
      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
        _html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(_ctx(run, id, 1), 0);
    };
  }
}

var _task = {
  set: setTask,
  clear: clearTask };


var macrotask = _task.set;
var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
var process$2 = _global.process;
var Promise$1 = _global.Promise;
var isNode = _cof(process$2) == 'process';

var _microtask = function _microtask() {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process$2.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function notify() {
      process$2.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true });
    // eslint-disable-line no-new

    notify = function notify() {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise$1 && Promise$1.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise$1.resolve(undefined);

    notify = function notify() {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(_global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined };

    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = _aFunction(resolve);
  this.reject = _aFunction(reject);
}

var f$5 = function f(C) {
  return new PromiseCapability(C);
};

var _newPromiseCapability = {
  f: f$5 };


var _perform = function _perform(exec) {
  try {
    return {
      e: false,
      v: exec() };

  } catch (e) {
    return {
      e: true,
      v: e };

  }
};

var navigator = _global.navigator;

var _userAgent = navigator && navigator.userAgent || '';

var _promiseResolve = function _promiseResolve(C, x) {
  _anObject(C);
  if (_isObject(x) && x.constructor === C) return x;
  var promiseCapability = _newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var task = _task.set;
var microtask = _microtask();
var PROMISE = 'Promise';
var TypeError$1 = _global.TypeError;
var process$3 = _global.process;
var versions = process$3 && process$3.versions;
var v8 = versions && versions.v8 || '';
var $Promise = _global[PROMISE];
var isNode$1 = _classof(process$3) == 'process';

var empty = function empty() {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && _userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function isThenable(it) {
  var then;
  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) {
      run(chain[i++]);
    } // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function onUnhandled(promise) {
  task.call(_global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = _perform(function () {
        if (isNode$1) {
          process$3.emit('unhandledRejection', value, promise);
        } else if (handler = _global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value });

        } else if ((console = _global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(_global, function () {
    var handler;

    if (isNode$1) {
      process$3.emit('rejectionHandled', promise);
    } else if (handler = _global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v });

    }
  });
};

var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false };
        // wrap

        try {
          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false },
    e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    _anInstance(this, $Promise, PROMISE, '_h');
    _aFunction(executor);
    Internal.call(this);

    try {
      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = _redefineAll($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode$1 ? process$3.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    } });


  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = _ctx($resolve, promise, 1);
    this.reject = _ctx($reject, promise, 1);
  };

  _newPromiseCapability.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE, {
  Promise: $Promise });

_setToStringTag($Promise, PROMISE);
_setSpecies(PROMISE);
Wrapper = _core[PROMISE]; // statics

_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  } });

_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return _promiseResolve(this, x);
  } });

_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = _perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      _forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = _perform(function () {
      _forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  } });


_export(_export.P + _export.R, 'Promise', {
  'finally': function _finally(onFinally) {
    var C = _speciesConstructor(this, _core.Promise || _global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return _promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return _promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  } });


var rApply = (_global.Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

_export(_export.S + _export.F * !_fails(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = _aFunction(target);
    var L = _anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  } });


var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) {
      n[i] = 'a[' + i + ']';
    } // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

var _bind = Function.bind || function bind(that
/* , ...args */)
{
  var fn = _aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function bound()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
  };

  if (_isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

var rConstruct = (_global.Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = _fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !_fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
_export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */)
  {
    _aFunction(Target);
    _anObject(args);
    var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);}
      // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (_bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = _objectCreate(_isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return _isObject(result) ? result : instance;
  } });


// MS Edge has broken Reflect.defineProperty - throwing instead of returning false

_export(_export.S + _export.F * _fails(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(_objectDp.f({}, 1, {
    value: 1 }),
  1, {
    value: 2 });

}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    _anObject(target);
    propertyKey = _toPrimitive(propertyKey, true);
    _anObject(attributes);

    try {
      _objectDp.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  } });


var gOPD$1 = _objectGopd.f;
_export(_export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD$1(_anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  } });


function get(target, propertyKey
/* , receiver */)
{
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (_anObject(target) === receiver) return target[propertyKey];
  if (desc = _objectGopd.f(target, propertyKey)) return _has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (_isObject(proto = _objectGpo(target))) return get(proto, propertyKey, receiver);
}

_export(_export.S, 'Reflect', {
  get: get });


_export(_export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return _objectGopd.f(_anObject(target), propertyKey);
  } });


_export(_export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return _objectGpo(_anObject(target));
  } });


_export(_export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  } });


var $isExtensible = Object.isExtensible;
_export(_export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    _anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  } });


_export(_export.S, 'Reflect', {
  ownKeys: _ownKeys });


var $preventExtensions = Object.preventExtensions;
_export(_export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    _anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  } });


function set(target, propertyKey, V
/* , receiver */)
{
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = _objectGopd.f(_anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (_isObject(proto = _objectGpo(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = _propertyDesc(0);
  }

  if (_has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !_isObject(receiver)) return false;

    if (existingDescriptor = _objectGopd.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      _objectDp.f(receiver, propertyKey, existingDescriptor);
    } else _objectDp.f(receiver, propertyKey, _propertyDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

_export(_export.S, 'Reflect', {
  set: set });


if (_setProto) _export(_export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    _setProto.check(target, proto);

    try {
      _setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  } });


var MATCH = _wks('match');

var _isRegexp = function _isRegexp(it) {
  var isRegExp;
  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
};

var _flags = function _flags() {
  var that = _anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

var dP$2 = _objectDp.f;
var gOPN = _objectGopn.f;
var $RegExp = _global.RegExp;
var Base = $RegExp;
var proto$1 = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (_descriptors && (!CORRECT_NEW || _fails(function () {
  re2[_wks('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = _isRegexp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : _inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f), tiRE ? this : proto$1, $RegExp);
  };

  var proxy = function proxy(key) {
    key in $RegExp || dP$2($RegExp, key, {
      configurable: true,
      get: function get() {
        return Base[key];
      },
      set: function set(it) {
        Base[key] = it;
      } });

  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
    proxy(keys[i++]);
  }

  proto$1.constructor = $RegExp;
  $RegExp.prototype = proto$1;
  _redefine(_global, 'RegExp', $RegExp);
}

_setSpecies('RegExp');

// false -> String#codePointAt

var _stringAt = function _stringAt(TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var at = _stringAt(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex

var _advanceStringIndex = function _advanceStringIndex(S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

var _regexpExecAbstract = function _regexpExecAbstract(R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (_classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
  re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var _regexpExec = patchedExec;

_export({
  target: 'RegExp',
  proto: true,
  forced: _regexpExec !== /./.exec },
{
  exec: _regexpExec });


var SPECIES$3 = _wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7' };

    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

var _fixReWks = function _fixReWks(KEY, length, exec) {
  var SYMBOL = _wks(KEY);
  var DELEGATES_TO_SYMBOL = !_fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES$3] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(_defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === _regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2) };

        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2) };

      }

      return {
        done: false };

    });
    var strfn = fns[0];
    var rxfn = fns[1];
    _redefine(String.prototype, KEY, strfn);
    _hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

_fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = _anObject(regexp);
    var S = String(this);
    if (!rx.global) return _regexpExecAbstract(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = _regexpExecAbstract(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

var max$1 = Math.max;
var min$2 = Math.min;
var floor$1 = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


_fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = _anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = _regexpExecAbstract(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max$1(min$2(_toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) {
        captures.push(maybeToString(result[j]));
      }

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = _toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor$1(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];}


      return capture === undefined ? '' : capture;
    });
  }
});

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX$1 = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !_fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

_fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!_isRegexp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = _regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX$1];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX$1] === match.index) separatorCopy[LAST_INDEX$1]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = _anObject(regexp);
    var S = String(this);
    var C = _speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return _regexpExecAbstract(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = _advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

// 7.2.9 SameValue(x, y)
var _sameValue = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

_fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = _anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!_sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = _regexpExecAbstract(rx, S);
    if (!_sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
  configurable: true,
  get: _flags });


var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  _redefine(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (_fails(function () {
  return $toString.call({
    source: 'a',
    flags: 'b' }) !=
  '/a/b';
})) {
  define(function toString() {
    var R = _anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

var SET = 'Set'; // 23.2 Set Objects

var es6_set = _collection(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
  } },
_collectionStrong);

var f$6 = _wks;
var _wksExt = {
  f: f$6 };


var defineProperty = _objectDp.f;

var _wksDefine = function _wksDefine(name) {
  var $Symbol = _core.Symbol || (_core.Symbol = _global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: _wksExt.f(name) });

};

var _enumKeys = function _enumKeys(it) {
  var result = _objectKeys(it);
  var getSymbols = _objectGops.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = _objectPie.f;
    var i = 0;
    var key;

    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }

  return result;
};

var gOPN$1 = _objectGopn.f;
var toString$1 = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN$1(it);
  } catch (e) {
    return windowNames.slice();
  }
};

var f$7 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$1(_toIobject(it));
};

var _objectGopnExt = {
  f: f$7 };


var META = _meta.KEY;
var gOPD$2 = _objectGopd.f;
var dP$3 = _objectDp.f;
var gOPN$2 = _objectGopnExt.f;
var $Symbol = _global.Symbol;
var $JSON = _global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE$2 = 'prototype';
var HIDDEN = _wks('_hidden');
var TO_PRIMITIVE$1 = _wks('toPrimitive');
var isEnum$1 = {}.propertyIsEnumerable;
var SymbolRegistry = _shared('symbol-registry');
var AllSymbols = _shared('symbols');
var OPSymbols = _shared('op-symbols');
var ObjectProto$1 = Object[PROTOTYPE$2];
var USE_NATIVE$1 = typeof $Symbol == 'function';
var QObject = _global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = _descriptors && _fails(function () {
  return _objectCreate(dP$3({}, 'a', {
    get: function get() {
      return dP$3(this, 'a', {
        value: 7 }).
      a;
    } })).
  a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD$2(ObjectProto$1, key);
  if (protoDesc) delete ObjectProto$1[key];
  dP$3(it, key, D);
  if (protoDesc && it !== ObjectProto$1) dP$3(ObjectProto$1, key, protoDesc);
} : dP$3;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE$1 && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);
  _anObject(it);
  key = _toPrimitive(key, true);
  _anObject(D);

  if (_has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!_has(it, HIDDEN)) dP$3(it, HIDDEN, _propertyDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _objectCreate(D, {
        enumerable: _propertyDesc(0, false) });

    }

    return setSymbolDesc(it, key, D);
  }

  return dP$3(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  _anObject(it);
  var keys = _enumKeys(P = _toIobject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum$1.call(this, key = _toPrimitive(key, true));
  if (this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = _toIobject(it);
  key = _toPrimitive(key, true);
  if (it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
  var D = gOPD$2(it, key);
  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN$2(_toIobject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto$1;
  var names = gOPN$2(IS_OP ? OPSymbols : _toIobject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE$1) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function $set(value) {
      if (this === ObjectProto$1) $set.call(OPSymbols, value);
      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, _propertyDesc(1, value));
    };

    if (_descriptors && setter) setSymbolDesc(ObjectProto$1, tag, {
      configurable: true,
      set: $set });

    return wrap(tag);
  };

  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
    return this._k;
  });
  _objectGopd.f = $getOwnPropertyDescriptor;
  _objectDp.f = $defineProperty;
  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
  _objectPie.f = $propertyIsEnumerable;
  _objectGops.f = $getOwnPropertySymbols;

  if (_descriptors && !_library) {
    _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  _wksExt.f = function (name) {
    return wrap(_wks(name));
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, {
  Symbol: $Symbol });


for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  _wks(es6Symbols[j++]);
}

for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) {
  _wksDefine(wellKnownSymbols[k++]);
}

_export(_export.S + _export.F * !USE_NATIVE$1, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return _has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  } });

_export(_export.S + _export.F * !USE_NATIVE$1, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols });
// 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && _export(_export.S + _export.F * (!USE_NATIVE$1 || _fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S }) !=
  '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    $replacer = replacer = args[1];
    if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!_isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  } });
// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE$2][TO_PRIMITIVE$1] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE$1, $Symbol[PROTOTYPE$2].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

_setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

_setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

_setToStringTag(_global.JSON, 'JSON', true);

_wksDefine('asyncIterator');

var _stringRepeat = function repeat(count) {
  var str = String(_defined(this));
  var res = '';
  var n = _toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) {
    if (n & 1) res += str;
  }

  return res;
};

var _stringPad = function _stringPad(that, maxLength, fillString, left) {
  var S = String(_defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = _toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

// https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);
_export(_export.P + _export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */)
  {
    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  } });


// https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG$1 = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);
_export(_export.P + _export.F * WEBKIT_BUG$1, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */)
  {
    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  } });


var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var space = '[' + _stringWs + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = _fails(function () {
    return !!_stringWs[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  _export(_export.P + _export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(_defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

var _stringTrim = exporter;

_stringTrim('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

_stringTrim('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

var TYPED = _uid('typed_array');
var VIEW = _uid('view');
var ABV = !!(_global.ArrayBuffer && _global.DataView);
var CONSTR = ABV;
var i$1 = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i$1 < l) {
  if (Typed = _global[TypedArrayConstructors[i$1++]]) {
    _hide(Typed.prototype, TYPED, true);
    _hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

var _typed = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW };


var _toIndex = function _toIndex(it) {
  if (it === undefined) return 0;
  var number = _toInteger(it);
  var length = _toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

var _arrayFill = function fill(value
/* , start = 0, end = @length */)
{
  var O = _toObject(this);
  var length = _toLength(O.length);
  var aLen = arguments.length;
  var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);

  while (endPos > index) {
    O[index++] = value;
  }

  return O;
};

var _typedBuffer = createCommonjsModule(function (module, exports) {

  var gOPN = _objectGopn.f;
  var dP = _objectDp.f;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var DATA_VIEW = 'DataView';
  var PROTOTYPE = 'prototype';
  var WRONG_LENGTH = 'Wrong length!';
  var WRONG_INDEX = 'Wrong index!';
  var $ArrayBuffer = _global[ARRAY_BUFFER];
  var $DataView = _global[DATA_VIEW];
  var Math = _global.Math;
  var RangeError = _global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

  var Infinity = _global.Infinity;
  var BaseBuffer = $ArrayBuffer;
  var abs = Math.abs;
  var pow = Math.pow;
  var floor = Math.floor;
  var log = Math.log;
  var LN2 = Math.LN2;
  var BUFFER = 'buffer';
  var BYTE_LENGTH = 'byteLength';
  var BYTE_OFFSET = 'byteOffset';
  var $BUFFER = _descriptors ? '_b' : BUFFER;
  var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
  var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

  function packIEEE754(value, mLen, nBytes) {
    var buffer = new Array(nBytes);
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var i = 0;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    var e, m, c;
    value = abs(value); // eslint-disable-next-line no-self-compare

    if (value != value || value === Infinity) {
      // eslint-disable-next-line no-self-compare
      m = value != value ? 1 : 0;
      e = eMax;
    } else {
      e = floor(log(value) / LN2);

      if (value * (c = pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * pow(2, eBias - 1) * pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
    }

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
    }

    buffer[--i] |= s * 128;
    return buffer;
  }

  function unpackIEEE754(buffer, mLen, nBytes) {
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = eLen - 7;
    var i = nBytes - 1;
    var s = buffer[i--];
    var e = s & 127;
    var m;
    s >>= 7;

    for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
    }

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
    }

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : s ? -Infinity : Infinity;
    } else {
      m = m + pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * pow(2, e - mLen);
  }

  function unpackI32(bytes) {
    return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
  }

  function packI8(it) {
    return [it & 0xff];
  }

  function packI16(it) {
    return [it & 0xff, it >> 8 & 0xff];
  }

  function packI32(it) {
    return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
  }

  function packF64(it) {
    return packIEEE754(it, 52, 8);
  }

  function packF32(it) {
    return packIEEE754(it, 23, 4);
  }

  function addGetter(C, key, internal) {
    dP(C[PROTOTYPE], key, {
      get: function get() {
        return this[internal];
      } });

  }

  function get(view, bytes, index, isLittleEndian) {
    var numIndex = +index;
    var intIndex = _toIndex(numIndex);
    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
    var store = view[$BUFFER]._b;
    var start = intIndex + view[$OFFSET];
    var pack = store.slice(start, start + bytes);
    return isLittleEndian ? pack : pack.reverse();
  }

  function set(view, bytes, index, conversion, value, isLittleEndian) {
    var numIndex = +index;
    var intIndex = _toIndex(numIndex);
    if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
    var store = view[$BUFFER]._b;
    var start = intIndex + view[$OFFSET];
    var pack = conversion(+value);

    for (var i = 0; i < bytes; i++) {
      store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
    }
  }

  if (!_typed.ABV) {
    $ArrayBuffer = function ArrayBuffer(length) {
      _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
      var byteLength = _toIndex(length);
      this._b = _arrayFill.call(new Array(byteLength), 0);
      this[$LENGTH] = byteLength;
    };

    $DataView = function DataView(buffer, byteOffset, byteLength) {
      _anInstance(this, $DataView, DATA_VIEW);
      _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
      var bufferLength = buffer[$LENGTH];
      var offset = _toInteger(byteOffset);
      if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
      byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
      if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
      this[$BUFFER] = buffer;
      this[$OFFSET] = offset;
      this[$LENGTH] = byteLength;
    };

    if (_descriptors) {
      addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
      addGetter($DataView, BUFFER, '_b');
      addGetter($DataView, BYTE_LENGTH, '_l');
      addGetter($DataView, BYTE_OFFSET, '_o');
    }

    _redefineAll($DataView[PROTOTYPE], {
      getInt8: function getInt8(byteOffset) {
        return get(this, 1, byteOffset)[0] << 24 >> 24;
      },
      getUint8: function getUint8(byteOffset) {
        return get(this, 1, byteOffset)[0];
      },
      getInt16: function getInt16(byteOffset
      /* , littleEndian */)
      {
        var bytes = get(this, 2, byteOffset, arguments[1]);
        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
      },
      getUint16: function getUint16(byteOffset
      /* , littleEndian */)
      {
        var bytes = get(this, 2, byteOffset, arguments[1]);
        return bytes[1] << 8 | bytes[0];
      },
      getInt32: function getInt32(byteOffset
      /* , littleEndian */)
      {
        return unpackI32(get(this, 4, byteOffset, arguments[1]));
      },
      getUint32: function getUint32(byteOffset
      /* , littleEndian */)
      {
        return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
      },
      getFloat32: function getFloat32(byteOffset
      /* , littleEndian */)
      {
        return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
      },
      getFloat64: function getFloat64(byteOffset
      /* , littleEndian */)
      {
        return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
      },
      setInt8: function setInt8(byteOffset, value) {
        set(this, 1, byteOffset, packI8, value);
      },
      setUint8: function setUint8(byteOffset, value) {
        set(this, 1, byteOffset, packI8, value);
      },
      setInt16: function setInt16(byteOffset, value
      /* , littleEndian */)
      {
        set(this, 2, byteOffset, packI16, value, arguments[2]);
      },
      setUint16: function setUint16(byteOffset, value
      /* , littleEndian */)
      {
        set(this, 2, byteOffset, packI16, value, arguments[2]);
      },
      setInt32: function setInt32(byteOffset, value
      /* , littleEndian */)
      {
        set(this, 4, byteOffset, packI32, value, arguments[2]);
      },
      setUint32: function setUint32(byteOffset, value
      /* , littleEndian */)
      {
        set(this, 4, byteOffset, packI32, value, arguments[2]);
      },
      setFloat32: function setFloat32(byteOffset, value
      /* , littleEndian */)
      {
        set(this, 4, byteOffset, packF32, value, arguments[2]);
      },
      setFloat64: function setFloat64(byteOffset, value
      /* , littleEndian */)
      {
        set(this, 8, byteOffset, packF64, value, arguments[2]);
      } });

  } else {
    if (!_fails(function () {
      $ArrayBuffer(1);
    }) || !_fails(function () {
      new $ArrayBuffer(-1); // eslint-disable-line no-new
    }) || _fails(function () {
      new $ArrayBuffer(); // eslint-disable-line no-new

      new $ArrayBuffer(1.5); // eslint-disable-line no-new

      new $ArrayBuffer(NaN); // eslint-disable-line no-new

      return $ArrayBuffer.name != ARRAY_BUFFER;
    })) {
      $ArrayBuffer = function ArrayBuffer(length) {
        _anInstance(this, $ArrayBuffer);
        return new BaseBuffer(_toIndex(length));
      };

      var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

      for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
        if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
      }

      ArrayBufferProto.constructor = $ArrayBuffer;
    } // iOS Safari 7.x bug


    var view = new $DataView(new $ArrayBuffer(2));
    var $setInt8 = $DataView[PROTOTYPE].setInt8;
    view.setInt8(0, 2147483648);
    view.setInt8(1, 2147483649);
    if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {
      setInt8: function setInt8(byteOffset, value) {
        $setInt8.call(this, byteOffset, value << 24 >> 24);
      },
      setUint8: function setUint8(byteOffset, value) {
        $setInt8.call(this, byteOffset, value << 24 >> 24);
      } },
    true);
  }

  _setToStringTag($ArrayBuffer, ARRAY_BUFFER);
  _setToStringTag($DataView, DATA_VIEW);
  _hide($DataView[PROTOTYPE], _typed.VIEW, true);
  exports[ARRAY_BUFFER] = $ArrayBuffer;
  exports[DATA_VIEW] = $DataView;
});

var ArrayBuffer = _global.ArrayBuffer;
var $ArrayBuffer = _typedBuffer.ArrayBuffer;
var $DataView = _typedBuffer.DataView;
var $isView = _typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW$1 = _typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
_export(_export.G + _export.W + _export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer });

_export(_export.S + _export.F * !_typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || _isObject(it) && VIEW$1 in it;
  } });

_export(_export.P + _export.U + _export.F * _fails(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(_anObject(this), start); // FF fix

    var len = _anObject(this).byteLength;
    var first = _toAbsoluteIndex(start, len);
    var fin = _toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (_speciesConstructor(this, $ArrayBuffer))(_toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  } });

_setSpecies(ARRAY_BUFFER);

// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex

var _arrayMethods = function _arrayMethods(TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || _arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = _toObject($this);
    var self = _iobject(O);
    var f = _ctx(callbackfn, that, 3);
    var length = _toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);

        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return val;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                result.push(val);
              // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }

  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

_iterators.Arguments = _iterators.Array;
_addToUnscopables('keys');
_addToUnscopables('values');
_addToUnscopables('entries');

var _arrayCopyWithin = [].copyWithin || function copyWithin(target
/* = 0 */,
start
/* = 0, end = @length */)
{
  var O = _toObject(this);
  var len = _toLength(O.length);
  var to = _toAbsoluteIndex(target, len);
  var from = _toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

var _typedArray = createCommonjsModule(function (module) {

  if (_descriptors) {
    var LIBRARY = _library;
    var global = _global;
    var fails = _fails;
    var $export = _export;
    var $typed = _typed;
    var $buffer = _typedBuffer;
    var ctx = _ctx;
    var anInstance = _anInstance;
    var propertyDesc = _propertyDesc;
    var hide = _hide;
    var redefineAll = _redefineAll;
    var toInteger = _toInteger;
    var toLength = _toLength;
    var toIndex = _toIndex;
    var toAbsoluteIndex = _toAbsoluteIndex;
    var toPrimitive = _toPrimitive;
    var has = _has;
    var classof = _classof;
    var isObject = _isObject;
    var toObject = _toObject;
    var isArrayIter = _isArrayIter;
    var create = _objectCreate;
    var getPrototypeOf = _objectGpo;
    var gOPN = _objectGopn.f;
    var getIterFn = core_getIteratorMethod;
    var uid = _uid;
    var wks = _wks;
    var createArrayMethod = _arrayMethods;
    var createArrayIncludes = _arrayIncludes;
    var speciesConstructor = _speciesConstructor;
    var ArrayIterators = es6_array_iterator;
    var Iterators = _iterators;
    var $iterDetect = _iterDetect;
    var setSpecies = _setSpecies;
    var arrayFill = _arrayFill;
    var arrayCopyWithin = _arrayCopyWithin;
    var $DP = _objectDp;
    var $GOPD = _objectGopd;
    var dP = $DP.f;
    var gOPD = $GOPD.f;
    var RangeError = global.RangeError;
    var TypeError = global.TypeError;
    var Uint8Array = global.Uint8Array;
    var ARRAY_BUFFER = 'ArrayBuffer';
    var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
    var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
    var PROTOTYPE = 'prototype';
    var ArrayProto = Array[PROTOTYPE];
    var $ArrayBuffer = $buffer.ArrayBuffer;
    var $DataView = $buffer.DataView;
    var arrayForEach = createArrayMethod(0);
    var arrayFilter = createArrayMethod(2);
    var arraySome = createArrayMethod(3);
    var arrayEvery = createArrayMethod(4);
    var arrayFind = createArrayMethod(5);
    var arrayFindIndex = createArrayMethod(6);
    var arrayIncludes = createArrayIncludes(true);
    var arrayIndexOf = createArrayIncludes(false);
    var arrayValues = ArrayIterators.values;
    var arrayKeys = ArrayIterators.keys;
    var arrayEntries = ArrayIterators.entries;
    var arrayLastIndexOf = ArrayProto.lastIndexOf;
    var arrayReduce = ArrayProto.reduce;
    var arrayReduceRight = ArrayProto.reduceRight;
    var arrayJoin = ArrayProto.join;
    var arraySort = ArrayProto.sort;
    var arraySlice = ArrayProto.slice;
    var arrayToString = ArrayProto.toString;
    var arrayToLocaleString = ArrayProto.toLocaleString;
    var ITERATOR = wks('iterator');
    var TAG = wks('toStringTag');
    var TYPED_CONSTRUCTOR = uid('typed_constructor');
    var DEF_CONSTRUCTOR = uid('def_constructor');
    var ALL_CONSTRUCTORS = $typed.CONSTR;
    var TYPED_ARRAY = $typed.TYPED;
    var VIEW = $typed.VIEW;
    var WRONG_LENGTH = 'Wrong length!';
    var $map = createArrayMethod(1, function (O, length) {
      return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
    });
    var LITTLE_ENDIAN = fails(function () {
      // eslint-disable-next-line no-undef
      return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
    });
    var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
      new Uint8Array(1).set({});
    });

    var toOffset = function toOffset(it, BYTES) {
      var offset = toInteger(it);
      if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
      return offset;
    };

    var validate = function validate(it) {
      if (isObject(it) && TYPED_ARRAY in it) return it;
      throw TypeError(it + ' is not a typed array!');
    };

    var allocate = function allocate(C, length) {
      if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
        throw TypeError('It is not a typed array constructor!');
      }

      return new C(length);
    };

    var speciesFromList = function speciesFromList(O, list) {
      return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
    };

    var fromList = function fromList(C, list) {
      var index = 0;
      var length = list.length;
      var result = allocate(C, length);

      while (length > index) {
        result[index] = list[index++];
      }

      return result;
    };

    var addGetter = function addGetter(it, key, internal) {
      dP(it, key, {
        get: function get() {
          return this._d[internal];
        } });

    };

    var $from = function from(source
    /* , mapfn, thisArg */)
    {
      var O = toObject(source);
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var iterFn = getIterFn(O);
      var i, length, values, result, step, iterator;

      if (iterFn != undefined && !isArrayIter(iterFn)) {
        for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
          values.push(step.value);
        }

        O = values;
      }

      if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

      for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
        result[i] = mapping ? mapfn(O[i], i) : O[i];
      }

      return result;
    };

    var $of = function of()
    /* ...items */
    {
      var index = 0;
      var length = arguments.length;
      var result = allocate(this, length);

      while (length > index) {
        result[index] = arguments[index++];
      }

      return result;
    }; // iOS Safari 6.x fails here


    var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
      arrayToLocaleString.call(new Uint8Array(1));
    });

    var $toLocaleString = function toLocaleString() {
      return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
    };

    var proto = {
      copyWithin: function copyWithin(target, start
      /* , end */)
      {
        return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
      },
      every: function every(callbackfn
      /* , thisArg */)
      {
        return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      fill: function fill(value
      /* , start, end */)
      {
        // eslint-disable-line no-unused-vars
        return arrayFill.apply(validate(this), arguments);
      },
      filter: function filter(callbackfn
      /* , thisArg */)
      {
        return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
      },
      find: function find(predicate
      /* , thisArg */)
      {
        return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
      },
      findIndex: function findIndex(predicate
      /* , thisArg */)
      {
        return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
      },
      forEach: function forEach(callbackfn
      /* , thisArg */)
      {
        arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      indexOf: function indexOf(searchElement
      /* , fromIndex */)
      {
        return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
      },
      includes: function includes(searchElement
      /* , fromIndex */)
      {
        return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
      },
      join: function join(separator) {
        // eslint-disable-line no-unused-vars
        return arrayJoin.apply(validate(this), arguments);
      },
      lastIndexOf: function lastIndexOf(searchElement
      /* , fromIndex */)
      {
        // eslint-disable-line no-unused-vars
        return arrayLastIndexOf.apply(validate(this), arguments);
      },
      map: function map(mapfn
      /* , thisArg */)
      {
        return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      reduce: function reduce(callbackfn
      /* , initialValue */)
      {
        // eslint-disable-line no-unused-vars
        return arrayReduce.apply(validate(this), arguments);
      },
      reduceRight: function reduceRight(callbackfn
      /* , initialValue */)
      {
        // eslint-disable-line no-unused-vars
        return arrayReduceRight.apply(validate(this), arguments);
      },
      reverse: function reverse() {
        var that = this;
        var length = validate(that).length;
        var middle = Math.floor(length / 2);
        var index = 0;
        var value;

        while (index < middle) {
          value = that[index];
          that[index++] = that[--length];
          that[length] = value;
        }

        return that;
      },
      some: function some(callbackfn
      /* , thisArg */)
      {
        return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      },
      sort: function sort(comparefn) {
        return arraySort.call(validate(this), comparefn);
      },
      subarray: function subarray(begin, end) {
        var O = validate(this);
        var length = O.length;
        var $begin = toAbsoluteIndex(begin, length);
        return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
      } };


    var $slice = function slice(start, end) {
      return speciesFromList(this, arraySlice.call(validate(this), start, end));
    };

    var $set = function set(arrayLike
    /* , offset */)
    {
      validate(this);
      var offset = toOffset(arguments[1], 1);
      var length = this.length;
      var src = toObject(arrayLike);
      var len = toLength(src.length);
      var index = 0;
      if (len + offset > length) throw RangeError(WRONG_LENGTH);

      while (index < len) {
        this[offset + index] = src[index++];
      }
    };

    var $iterators = {
      entries: function entries() {
        return arrayEntries.call(validate(this));
      },
      keys: function keys() {
        return arrayKeys.call(validate(this));
      },
      values: function values() {
        return arrayValues.call(validate(this));
      } };


    var isTAIndex = function isTAIndex(target, key) {
      return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
    };

    var $getDesc = function getOwnPropertyDescriptor(target, key) {
      return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
    };

    var $setDesc = function defineProperty(target, key, desc) {
      if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
        target[key] = desc.value;
        return target;
      }

      return dP(target, key, desc);
    };

    if (!ALL_CONSTRUCTORS) {
      $GOPD.f = $getDesc;
      $DP.f = $setDesc;
    }

    $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
      getOwnPropertyDescriptor: $getDesc,
      defineProperty: $setDesc });


    if (fails(function () {
      arrayToString.call({});
    })) {
      arrayToString = arrayToLocaleString = function toString() {
        return arrayJoin.call(this);
      };
    }

    var $TypedArrayPrototype$ = redefineAll({}, proto);
    redefineAll($TypedArrayPrototype$, $iterators);
    hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
    redefineAll($TypedArrayPrototype$, {
      slice: $slice,
      set: $set,
      constructor: function constructor() {
        /* noop */
      },
      toString: arrayToString,
      toLocaleString: $toLocaleString });

    addGetter($TypedArrayPrototype$, 'buffer', 'b');
    addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
    addGetter($TypedArrayPrototype$, 'byteLength', 'l');
    addGetter($TypedArrayPrototype$, 'length', 'e');
    dP($TypedArrayPrototype$, TAG, {
      get: function get() {
        return this[TYPED_ARRAY];
      } });
    // eslint-disable-next-line max-statements

    module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
      CLAMPED = !!CLAMPED;
      var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + KEY;
      var SETTER = 'set' + KEY;
      var TypedArray = global[NAME];
      var Base = TypedArray || {};
      var TAC = TypedArray && getPrototypeOf(TypedArray);
      var FORCED = !TypedArray || !$typed.ABV;
      var O = {};
      var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

      var getter = function getter(that, index) {
        var data = that._d;
        return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
      };

      var setter = function setter(that, index, value) {
        var data = that._d;
        if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
        data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
      };

      var addElement = function addElement(that, index) {
        dP(that, index, {
          get: function get() {
            return getter(this, index);
          },
          set: function set(value) {
            return setter(this, index, value);
          },
          enumerable: true });

      };

      if (FORCED) {
        TypedArray = wrapper(function (that, data, $offset, $length) {
          anInstance(that, TypedArray, NAME, '_d');
          var index = 0;
          var offset = 0;
          var buffer, byteLength, length, klass;

          if (!isObject(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new $ArrayBuffer(byteLength);
          } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
            buffer = data;
            offset = toOffset($offset, BYTES);
            var $len = data.byteLength;

            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - offset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
            }

            length = byteLength / BYTES;
          } else if (TYPED_ARRAY in data) {
            return fromList(TypedArray, data);
          } else {
            return $from.call(TypedArray, data);
          }

          hide(that, '_d', {
            b: buffer,
            o: offset,
            l: byteLength,
            e: length,
            v: new $DataView(buffer) });


          while (index < length) {
            addElement(that, index++);
          }
        });
        TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
        hide(TypedArrayPrototype, 'constructor', TypedArray);
      } else if (!fails(function () {
        TypedArray(1);
      }) || !fails(function () {
        new TypedArray(-1); // eslint-disable-line no-new
      }) || !$iterDetect(function (iter) {
        new TypedArray(); // eslint-disable-line no-new

        new TypedArray(null); // eslint-disable-line no-new

        new TypedArray(1.5); // eslint-disable-line no-new

        new TypedArray(iter); // eslint-disable-line no-new
      }, true)) {
        TypedArray = wrapper(function (that, data, $offset, $length) {
          anInstance(that, TypedArray, NAME);
          var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
          // https://github.com/websockets/ws/pull/645

          if (!isObject(data)) return new Base(toIndex(data));

          if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
            return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
          }

          if (TYPED_ARRAY in data) return fromList(TypedArray, data);
          return $from.call(TypedArray, data);
        });
        arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
          if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
        });
        TypedArray[PROTOTYPE] = TypedArrayPrototype;
        if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
      }

      var $nativeIterator = TypedArrayPrototype[ITERATOR];
      var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
      var $iterator = $iterators.values;
      hide(TypedArray, TYPED_CONSTRUCTOR, true);
      hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
      hide(TypedArrayPrototype, VIEW, true);
      hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

      if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
        dP(TypedArrayPrototype, TAG, {
          get: function get() {
            return NAME;
          } });

      }

      O[NAME] = TypedArray;
      $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
      $export($export.S, NAME, {
        BYTES_PER_ELEMENT: BYTES });

      $export($export.S + $export.F * fails(function () {
        Base.of.call(TypedArray, 1);
      }), NAME, {
        from: $from,
        of: $of });

      if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
      $export($export.P, NAME, proto);
      setSpecies(NAME);
      $export($export.P + $export.F * FORCED_SET, NAME, {
        set: $set });

      $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
      if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
      $export($export.P + $export.F * fails(function () {
        new TypedArray(1).slice();
      }), NAME, {
        slice: $slice });

      $export($export.P + $export.F * (fails(function () {
        return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
      }) || !fails(function () {
        TypedArrayPrototype.toLocaleString.call([1, 2]);
      })), NAME, {
        toLocaleString: $toLocaleString });

      Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
      if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
    };
  } else module.exports = function () {
    /* empty */
  };
});

_typedArray('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

_typedArray('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

_typedArray('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

_typedArray('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

_typedArray('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

_typedArray('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

_typedArray('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

_typedArray('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

_typedArray('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var runtime = createCommonjsModule(function (module) {
  /**
                                                       * Copyright (c) 2014-present, Facebook, Inc.
                                                       *
                                                       * This source code is licensed under the MIT license found in the
                                                       * LICENSE file in the root directory of this source tree.
                                                       */
  !function (global) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var runtime = global.regeneratorRuntime;

    if (runtime) {
      {
        // If regeneratorRuntime is defined globally and we're in a module,
        // make the exports object identical to regeneratorRuntime.
        module.exports = runtime;
      } // Don't bother evaluating the rest of this file if the runtime was
      // already defined globally.


      return;
    } // Define the runtime globally (as expected by generated code) as either
    // module.exports (if we're in a module) or a new, empty object.


    runtime = global.regeneratorRuntime = module.exports;

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg) };

      } catch (err) {
        return {
          type: "throw",
          arg: err };

      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;

        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    runtime.awrap = function (arg) {
      return {
        __await: arg };

    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            resolve(result);
          }, reject);
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
      return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done };

          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0] };


      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root" }];

      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
          next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult };

    }

    runtime.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true };

    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc };


        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      } };

  }( // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  function () {
    return this;
  }() || Function("return this")());
});

/**
     * Appcelerator Titanium Mobile
     * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
     * Licensed under the terms of the Apache Public License
     * Please see the LICENSE included with this distribution for details.
     */
// Add a toJSON() method to all Error objects needed to output non-enumerable properties.
// The JSON.stringify() will automatically call this method if it exists to provide custom output.
// Notes:
// - In V8, all Error properties are not enumerable. We need this or else stringify() will return "{}".
// - In JavaScriptCore, only the "stack" property is not enumerable. We want to reveal this.
if (typeof Error.prototype.toJSON !== 'function') {
  Error.prototype.toJSON = function () {
    var properties = {};
    Object.getOwnPropertyNames(this).forEach(function (name) {
      properties[name] = this[name];
    }, this);
    return properties;
  };
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2019 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */
if (Ti.Platform.osname === 'iphone' || Ti.Platform.osname === 'ipad') {
  var buffer = Ti.createBuffer({
    value: '' });

  var blob = buffer.toBlob();

  blob.constructor.prototype.toString = function () {
    return this.text;
  };
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2019 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */
var colorset;
var osVersion; // As Android passes a new instance of Ti.UI to every JS file we can't just
// Ti.UI within this file, we must call kroll.binding to get the Titanium
// namespace that is passed in with require and that deal with the .UI
// namespace that is on that directly.

var uiModule = Ti.UI;

if (Ti.Android) {
  uiModule = kroll.binding('Titanium').Titanium.UI;
}

uiModule.SEMANTIC_COLOR_TYPE_LIGHT = 'light';
uiModule.SEMANTIC_COLOR_TYPE_DARK = 'dark'; // We need to track this manually with a getter/setter
// due to the same reasons we use uiModule instead of Ti.UI

var currentColorType = uiModule.SEMANTIC_COLOR_TYPE_LIGHT;
Object.defineProperty(uiModule, 'semanticColorType', {
  get: function get() {
    return currentColorType;
  },
  set: function set(colorType) {
    currentColorType = colorType;
  } });


uiModule.fetchSemanticColor = function fetchSemanticColor(colorName) {
  if (!osVersion) {
    osVersion = parseInt(Ti.Platform.version.split('.')[0]);
  }

  if (Ti.App.iOS && osVersion >= 13) {
    return Ti.UI.iOS.fetchSemanticColor(colorName);
  } else {
    if (!colorset) {
      try {
        colorset = require('/semantic.colors.json'); // eslint-disable-line import/no-absolute-path
      } catch (error) {
        console.error('Failed to require colors file at /semantic.colors.json');
        return;
      }
    }

    try {
      return colorset[colorName][uiModule.semanticColorType].color || colorset[colorName][uiModule.semanticColorType];
    } catch (error) {
      console.log("Failed to lookup color for ".concat(colorName));
    }
  }
};

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
    args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true } });


  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true } });


    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
   * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events
   * @param {string} eventName the name of the event to register for
   * @param {function} listener the listener callback/function to invoke when the event is emitted
   * @param {boolean} prepend whether to prepend or append the listener
   * @returns {EventEmitter}
   */
function _addListener(emitter, eventName, listener, prepend) {
  if (!emitter._eventsToListeners) {
    // no events/listeners registered
    emitter._eventsToListeners = {}; // initialize it
  } // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)


  if (emitter._eventsToListeners.newListener) {
    emitter.emit('newListener', eventName, listener);
  }

  var eventListeners = emitter._eventsToListeners[eventName] || [];

  if (prepend) {
    eventListeners.unshift(listener);
  } else {
    eventListeners.push(listener);
  }

  emitter._eventsToListeners[eventName] = eventListeners; // Check max listeners and spit out warning if >

  var max = emitter.getMaxListeners();
  var length = eventListeners.length;

  if (max > 0 && length > max) {
    var w = new Error("Possible EventEmitter memory leak detected. ".concat(length, " ").concat(eventName, " listeners added. Use emitter.setMaxListeners() to increase limit"));
    w.name = 'MaxListenersExceededWarning';
    w.emitter = emitter;
    w.type = eventName;
    w.count = length;
    process.emitWarning(w);
  }

  return emitter;
}

function onceWrap(emitter, eventName, listener) {
  function wrapper() {
    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.listener.apply(this.emitter, args); // then forward the event callback
  } // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter


  var wrapperThis = {
    emitter,
    eventName,
    listener };

  var bound = wrapper.bind(wrapperThis); // bind to force "this" to refer to our custom object tracking the wrapper/emitter/listener

  bound.listener = listener; // have to add listener property for "unwrapping"

  wrapperThis.wrappedFunc = bound;
  return bound;
} // many consumers make use of this via util.inherits, which does not chain constructor calls!
// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it


var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this._eventsToListeners = {};
    this._maxListeners = undefined;
  }

  _createClass(EventEmitter, [{
    key: "addListener",
    value: function addListener(eventName, listener) {
      return _addListener(this, eventName, listener, false);
    } },
  {
    key: "on",
    value: function on(eventName, listener) {
      return this.addListener(eventName, listener);
    } },
  {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      return _addListener(this, eventName, listener, true);
    } },
  {
    key: "once",
    value: function once(eventName, listener) {
      this.on(eventName, onceWrap(this, eventName, listener));
    } },
  {
    key: "prependOnceListener",
    value: function prependOnceListener(eventName, listener) {
      this.prependListener(eventName, onceWrap(this, eventName, listener));
    } },
  {
    key: "removeListener",
    value: function removeListener(eventName, listener) {
      if (!this._eventsToListeners) {
        // no events/listeners registered
        return this;
      }

      var eventListeners = this._eventsToListeners[eventName] || [];
      var length = eventListeners.length;
      var foundIndex = -1;
      var unwrappedListener; // Need to search LIFO, and need to handle wrapped functions (once wrappers)

      for (var i = length - 1; i >= 0; i--) {
        if (eventListeners[i] === listener || eventListeners[i].listener === listener) {
          foundIndex = i;
          unwrappedListener = eventListeners[i].listener;
          break;
        }
      }

      if (foundIndex !== -1) {
        if (length === 1) {
          // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!
          delete this._eventsToListeners[eventName];
        } else {
          // we had 2+ listeners, so store array without this given listener
          eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]
        } // Don't emit if there's no listeners for 'removeListener' type!


        if (this._eventsToListeners.removeListener) {
          this.emit('removeListener', eventName, unwrappedListener || listener);
        }
      }

      return this;
    } },
  {
    key: "off",
    value: function off(eventName, listener) {
      return this.removeListener(eventName, listener);
    } },
  {
    key: "emit",
    value: function emit(eventName) {
      if (!this._eventsToListeners) {
        // no events/listeners registered
        return false;
      }

      var eventListeners = this._eventsToListeners[eventName] || [];

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = eventListeners.slice()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var listener = _step.value;
          // must operate on copy because listeners ,ay get remove as side-effect of calling
          listener.call.apply(listener, [this].concat(args));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return eventListeners.length !== 0;
    } },
  {
    key: "listenerCount",
    value: function listenerCount(eventName) {
      if (!this._eventsToListeners) {
        // no events/listeners registered
        return 0;
      }

      var eventListeners = this._eventsToListeners[eventName] || [];
      return eventListeners.length;
    } },
  {
    key: "eventNames",
    value: function eventNames() {
      return Object.getOwnPropertyNames(this._eventsToListeners || {});
    } },
  {
    key: "listeners",
    value: function listeners(eventName) {
      if (!this._eventsToListeners) {
        // no events/listeners registered
        return [];
      } // Need to "unwrap" once wrappers!


      var raw = this._eventsToListeners[eventName] || [];
      return raw.map(function (l) {
        return l.listener || l;
      }); // here we unwrap the once wrapper if there is one or fall back to listener function
    } },
  {
    key: "rawListeners",
    value: function rawListeners(eventName) {
      if (!this._eventsToListeners) {
        // no events/listeners registered
        return [];
      }

      return (this._eventsToListeners[eventName] || []).slice(0); // return a copy
    } },
  {
    key: "getMaxListeners",
    value: function getMaxListeners() {
      return this._maxListeners || EventEmitter.defaultMaxListeners;
    } },
  {
    key: "setMaxListeners",
    value: function setMaxListeners(n) {
      this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)

      return this;
    } },
  {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      var _this = this;

      if (!this._eventsToListeners) {
        // no events/listeners registered
        this._eventsToListeners = {}; // initialize it
      }

      if (!this._eventsToListeners.removeListener) {
        // no need to emit! we can just wipe!
        if (eventName === undefined) {
          // remove every type!
          this._eventsToListeners = {};
        } else {
          // remove specific type
          delete this._eventsToListeners[eventName];
        }

        return this;
      } // yuck, we'll have to emit 'removeListener' events as we go


      if (eventName === undefined) {
        // Remove all types (but do 'removeListener' last!)
        var names = Object.keys(this._eventsToListeners).filter(function (name) {
          return name !== 'removeListener';
        });
        names.forEach(function (name) {
          return _this.removeAllListeners(name);
        });
        this.removeAllListeners('removeListener');
        this._eventsToListeners = {};
      } else {
        // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)
        var listeners = this._eventsToListeners[eventName] || [];

        for (var i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(eventName, listeners[i]);
        }
      }

      return this;
    } }]);


  return EventEmitter;
}();
EventEmitter.defaultMaxListeners = 10;

EventEmitter.listenerCount = function (emitter, eventName) {
  return emitter.listenerCount(eventName);
};

EventEmitter.EventEmitter = EventEmitter;

/**
                                           * @param  {*} arg passed in argument value
                                           * @param  {string} name name of the argument
                                           * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)
                                           * @return {void}
                                           * @throws {TypeError}
                                           */
function assertArgumentType(arg, name, typename) {
  var type = typeof arg;

  if (type !== typename.toLowerCase()) {
    throw new TypeError("The \"".concat(name, "\" argument must be of type ").concat(typename, ". Received type ").concat(type));
  }
}

var startTime = Date.now();
/**
                             * This function 'standardizes' the reported architectures to the equivalents reported by Node.js
                             * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.
                             * iOS values: "arm64", "armv7", "x86_64", "i386", "Unknown"
                             * Android values: "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64", "unknown"
                             * Windows values: "x64", "ia64", "ARM", "x86", "unknown"
                             * @param {string} original original architecture reported by Ti.Platform
                             * @returns {string}
                             */

function standardizeArch(original) {
  switch (original) {
    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'
    // 'armeabi' is a dead ABI for Android, removed in NDK r17
    case 'armv7':
    case 'armeabi':
    case 'armeabi-v7a':
    case 'ARM':
      return 'arm';
    // coerce 'arm64-v8a' -> 'arm64'

    case 'arm64-v8a':
      return 'arm64';
    // coerce 'i386', 'x86' -> 'ia32'

    case 'i386':
    case 'x86':
      return 'ia32';
    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'

    case 'x86_64':
    case 'ia64':
      return 'x64';
    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17

    case 'mips64':
      return 'mips';
    // coerce 'Unknown' -> 'unknown'

    case 'Unknown':
      return 'unknown';

    default:
      return original;}

}

var process$4 = new EventEmitter();

process$4.abort = function () {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here


process$4.arch = standardizeArch(Ti.Platform.architecture);
process$4.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?

Object.defineProperty(process$4, 'argv0', {
  value: '',
  // TODO: Path to .app on iOS?
  writable: false,
  enumerable: true,
  configurable: false });


process$4.binding = function () {
  throw new Error('process.binding is unsupported and not user-facing API');
};

process$4.channel = undefined;

process$4.chdir = function () {
  throw new Error('process.chdir is unsupported');
};

process$4.config = {};
process$4.connected = false;

process$4.cpuUsage = function () {
  // FIXME: Can we look at OS.cpus to get this data?
  return {
    user: 0,
    system: 0 };

};

process$4.cwd = function () {
  return __dirname;
};

Object.defineProperty(process$4, 'debugPort', {
  get: function get() {
    var value = 0; // default to 0

    try {
      if (Ti.Platform.osname === 'android') {
        var assets = kroll.binding('assets');
        var json = assets.readAsset('deploy.json');

        if (json) {
          var deployData = JSON.parse(json);

          if (deployData.debuggerPort !== -1) {
            // -1 means not set (not in debug mode)
            value = deployData.debuggerPort;
          }
        }
      } else if (Ti.Platform.osname === 'iphone' || Ti.Platform.osname === 'ipad') {
        // iOS is 27753 as of ios < 11.3 for simulators
        // for 11.3+ it uses a unix socket
        // for devices, it uses usbmuxd
        value = 27753; // TODO: Can we only return this for simulator < 11.3?
      }
    } catch (error) {} // ignore
    // overwrite this getter with static value


    Object.defineProperty(this, 'debugPort', {
      value: value,
      writable: true,
      enumerable: true,
      configurable: true });

    return value;
  },
  enumerable: true,
  configurable: true });


process$4.disconnect = function () {}; // no-op


process$4.dlopen = function () {
  throw new Error('process.dlopen is not supported');
};

process$4.emitWarning = function (warning, options, code, ctor) {
  // eslint-disable-line no-unused-vars
  var type;
  var detail;

  if (typeof options === 'string') {
    type = options;
  } else if (typeof options === 'object') {
    type = options.type;
    code = options.code;
    detail = options.detail;
  }

  if (typeof warning === 'string') {
    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8
    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);
    warning = new Error(warning);
    warning.name = type || 'Warning';

    if (code !== undefined) {
      warning.code = code;
    }

    if (detail !== undefined) {
      warning.detail = detail;
    }
  } // TODO: Throw TypeError if not an instanceof Error at this point!


  var isDeprecation = warning.name === 'DeprecationWarning';

  if (isDeprecation && process$4.noDeprecation) {
    return; // ignore
  }

  if (isDeprecation && process$4.throwDeprecation) {
    throw warning;
  }

  this.emit('warning', warning);
};

function loadEnvJson() {
  try {
    var jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');

    if (jsonFile.exists()) {
      return JSON.parse(jsonFile.read().text);
    }
  } catch (error) {
    Ti.API.error("Failed to read \"_env_.json\". Reason: ".concat(error.message));
  }

  return {};
}

Object.defineProperty(process$4, 'env', {
  get: function get() {
    delete this.env;
    return this.env = loadEnvJson();
  },
  enumerable: true,
  configurable: true });

process$4.execArgv = [];
process$4.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?

process$4.exit = function () {
  throw new Error('process.exit is not supported');
};

process$4.exitCode = undefined;
process$4.noDeprecation = false;
process$4.pid = 0; // FIXME: Should we try and adopt 'windowsphone'/'windowsstore' to 'win32'?
// FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?

process$4.platform = Ti.Platform.osname;
process$4.ppid = 0; // TODO: Add release property (Object)
// TODO: Can we expose stdout/stderr/stdin natively?

process$4.stderr = {
  isTTY: false,
  writable: true,
  write: function write(chunk, encoding, callback) {
    console.error(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$4.stdout = {
  isTTY: false,
  writable: true,
  write: function write(chunk, encoding, callback) {
    console.log(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$4.title = Ti.App.name;
process$4.throwDeprecation = false;
process$4.traceDeprecation = false;

process$4.umask = function () {
  return 0;
}; // just always return 0


process$4.uptime = function () {
  var diffMs = Date.now() - startTime;
  return diffMs / 1000.0; // convert to "seconds" with fractions
};

process$4.version = Ti.version;
process$4.versions = {
  modules: '',
  // TODO: Report module api version (for current platform!)
  v8: '',
  // TODO: report android's v8 version (if on Android!)
  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?
  // TODO: Report ios/Android/Windows platform versions?
};

global.process = process$4; // handle spitting out warnings

var WARNING_PREFIX = "(titanium:".concat(process$4.pid, ") ");
process$4.on('warning', function (warning) {
  var isDeprecation = warning.name === 'DeprecationWarning'; // if we're not doing deprecations, ignore!

  if (isDeprecation && process$4.noDeprecation) {
    return;
  } // TODO: Check process.traceDeprecation and if set, include stack trace in message!


  var msg = WARNING_PREFIX;

  if (warning.code !== undefined) {
    msg += "[".concat(warning.code, "] ");
  }

  if (warning.toString) {
    msg += warning.toString();
  }

  if (warning.detail) {
    msg += "\n".concat(warning.detail);
  }

  console.error(msg);
});
var uncaughtExceptionCallback = null;

process$4.hasUncaughtExceptionCaptureCallback = function () {
  return uncaughtExceptionCallback !== null;
};

process$4.setUncaughtExceptionCaptureCallback = function (fn) {
  if (fn === null) {
    uncaughtExceptionCallback = null;
    return;
  }

  assertArgumentType(fn, 'fn', 'function');

  if (uncaughtExceptionCallback !== null) {
    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');
  }

  uncaughtExceptionCallback = fn;
};

Ti.App.addEventListener('uncaughtException', function (event) {
  // Create an Error instance that wraps the data from the event
  // ideally we'd just forward along the original Error!
  var error = new Error(event.message);
  error.stack = event.backtrace;
  error.fileName = event.sourceName;
  error.lineNumber = event.line;
  error.columnNumber = event.lineOffset;

  if (process$4.hasUncaughtExceptionCaptureCallback()) {
    return uncaughtExceptionCallback(error);
  } // otherwise forward the event!


  process$4.emit('uncaughtException', error);
});
// JS engine should be able to optimize easier

var CallbackWithArgs =
/*#__PURE__*/
function () {
  function CallbackWithArgs(func, args) {
    _classCallCheck(this, CallbackWithArgs);

    this.func = func;
    this.args = args;
  }

  _createClass(CallbackWithArgs, [{
    key: "run",
    value: function run() {
      if (this.args) {
        this.func.apply(null, this.args);
      } else {
        this.fun();
      }
    } }]);


  return CallbackWithArgs;
}(); // nextTick vs setImmediate should be handled in a semi-smart way
// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)
// Then we should go through the "immediate" queue
// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/


var tickQueue = [];
var immediateQueue = [];
var drainingTickQueue = false;
var drainQueuesTimeout = null;
/**
                                * Iteratively runs all "ticks" until there are no more.
                                * This can cause infinite recursion if a tick schedules another forever.
                                */

function drainTickQueue() {
  if (drainingTickQueue) {
    return;
  }

  drainingTickQueue = true;

  while (tickQueue.length) {
    var tick = tickQueue.shift();
    tick.run();
  }

  drainingTickQueue = false;
}

function drainQueues() {
  // drain the full tick queue first...
  drainTickQueue(); // tick queue should be empty!

  var immediatesRemaining = processImmediateQueue();

  if (immediatesRemaining !== 0) {
    // re-schedule draining our queues, as we have at least one more "immediate" to handle
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  } else {
    drainQueuesTimeout = null;
  }
}
/**
   * Attempts to process "immediates" (in a much more leisurely way than ticks)
   * We give a 100ms window to run them in before re-scheduling the timeout to process them again.
   * If any ticks are added during invocation of immediate, we drain the tick queue fully before
   * proceeding to next immediate (if we still have time in our window).
   * @returns {number} number of remaining immediates to be processed
   */


function processImmediateQueue() {
  var immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates

  while (immediateQueue.length && Date.now() < immediateDeadline) {
    var immediate = immediateQueue.shift();
    immediate.run();

    if (tickQueue.length > 0) {
      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)
      drainTickQueue();
    }
  }

  return immediateQueue.length;
}

process$4.nextTick = function (callback) {
  assertArgumentType(callback, 'callback', 'function');

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  tickQueue.push(new CallbackWithArgs(callback, args));

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
};

global.setImmediate = function (callback) {
  assertArgumentType(callback, 'callback', 'function');

  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  var immediate = new CallbackWithArgs(callback, args);
  immediateQueue.push(immediate);

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }

  return immediate;
};

global.clearImmediate = function (immediate) {
  var index = immediateQueue.indexOf(immediate);

  if (index !== -1) {
    immediateQueue.splice(index, 1);
  }
};

var isWin32 = Ti.Platform.osname === 'windowsphone' || Ti.Platform.osname === 'windowsstore';
var FORWARD_SLASH = 47; // '/'

var BACKWARD_SLASH = 92; // '\\'

/**
 * Is this [a-zA-Z]?
 * @param  {number}  charCode value from String.charCodeAt()
 * @return {Boolean}          [description]
 */

function isWindowsDeviceName(charCode) {
  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
}
/**
   * [isAbsolute description]
   * @param  {boolean} isPosix whether this impl is for POSIX or not
   * @param  {string} filepath   input file path
   * @return {Boolean}          [description]
   */


function _isAbsolute(isPosix, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var length = filepath.length; // empty string special case

  if (length === 0) {
    return false;
  }

  var firstChar = filepath.charCodeAt(0);

  if (firstChar === FORWARD_SLASH) {
    return true;
  } // we already did our checks for posix


  if (isPosix) {
    return false;
  } // win32 from here on out


  if (firstChar === BACKWARD_SLASH) {
    return true;
  }

  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {
    var thirdChar = filepath.charAt(2);
    return thirdChar === '/' || thirdChar === '\\';
  }

  return false;
}
/**
   * [dirname description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @return {string}            [description]
   */


function _dirname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var length = filepath.length;

  if (length === 0) {
    return '.';
  } // ignore trailing separator


  var fromIndex = length - 1;
  var hadTrailing = filepath.endsWith(separator);

  if (hadTrailing) {
    fromIndex--;
  }

  var foundIndex = filepath.lastIndexOf(separator, fromIndex); // no separators

  if (foundIndex === -1) {
    // handle special case of root windows paths
    if (length >= 2 && separator === '\\' && filepath.charAt(1) === ':') {
      var firstChar = filepath.charCodeAt(0);

      if (isWindowsDeviceName(firstChar)) {
        return filepath; // it's a root windows path
      }
    }

    return '.';
  } // only found root separator


  if (foundIndex === 0) {
    return separator; // if it was '/', return that
  } // Handle special case of '//something'


  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {
    return '//';
  }

  return filepath.slice(0, foundIndex);
}
/**
   * [extname description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @return {string}            [description]
   */


function _extname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var index = filepath.lastIndexOf('.');

  if (index === -1 || index === 0) {
    return '';
  } // ignore trailing separator


  var endIndex = filepath.length;

  if (filepath.endsWith(separator)) {
    endIndex--;
  }

  return filepath.slice(index, endIndex);
}

function lastIndexWin32Separator(filepath, index) {
  for (var i = index; i >= 0; i--) {
    var char = filepath.charCodeAt(i);

    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {
      return i;
    }
  }

  return -1;
}
/**
   * [basename description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @param  {string} [ext]      file extension to drop if it exists
   * @return {string}            [description]
   */


function _basename(separator, filepath, ext) {
  assertArgumentType(filepath, 'path', 'string');

  if (ext !== undefined) {
    assertArgumentType(ext, 'ext', 'string');
  }

  var length = filepath.length;

  if (length === 0) {
    return '';
  }

  var isPosix = separator === '/';
  var endIndex = length; // drop trailing separator (if there is one)

  var lastCharCode = filepath.charCodeAt(length - 1);

  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {
    endIndex--;
  } // Find last occurence of separator


  var lastIndex = -1;

  if (isPosix) {
    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);
  } else {
    // On win32, handle *either* separator!
    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1); // handle special case of root path like 'C:' or 'C:\\'

    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {
      return '';
    }
  } // Take from last occurrence of separator to end of string (or beginning to end if not found)


  var base = filepath.slice(lastIndex + 1, endIndex); // drop trailing extension (if specified)

  if (ext === undefined) {
    return base;
  }

  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;
}
/**
   * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.
   *
   * When multiple, sequential path segment separation characters are found (e.g.
   * / on POSIX and either \ or / on Windows), they are replaced by a single
   * instance of the platform-specific path segment separator (/ on POSIX and \
   * on Windows). Trailing separators are preserved.
   *
   * If the path is a zero-length string, '.' is returned, representing the
   * current working directory.
   *
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath  input file path
   * @return {string} [description]
   */


function _normalize(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');

  if (filepath.length === 0) {
    return '.';
  } // Windows can handle '/' or '\\' and both should be turned into separator


  var isWindows = separator === '\\';

  if (isWindows) {
    filepath = filepath.replace(/\//g, separator);
  }

  var hadLeading = filepath.startsWith(separator); // On Windows, need to handle UNC paths (\\host-name\\resource\\dir) special to retain leading double backslash

  var isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\';
  var hadTrailing = filepath.endsWith(separator);
  var parts = filepath.split(separator);
  var result = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var segment = _step.value;

      if (segment.length !== 0 && segment !== '.') {
        if (segment === '..') {
          result.pop(); // FIXME: What if this goes above root? Should we throw an error?
        } else {
          result.push(segment);
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var normalized = hadLeading ? separator : '';
  normalized += result.join(separator);

  if (hadTrailing) {
    normalized += separator;
  }

  if (isUNC) {
    normalized = '\\' + normalized;
  }

  return normalized;
}
/**
   * [assertSegment description]
   * @param  {*} segment [description]
   * @return {void}         [description]
   */


function assertSegment(segment) {
  if (typeof segment !== 'string') {
    throw new TypeError("Path must be a string. Received ".concat(segment));
  }
}
/**
   * The `path.join()` method joins all given path segments together using the
   * platform-specific separator as a delimiter, then normalizes the resulting path.
   * Zero-length path segments are ignored. If the joined path string is a zero-
   * length string then '.' will be returned, representing the current working directory.
   * @param  {string} separator platform-specific file separator
   * @param  {string[]} paths [description]
   * @return {string}       The joined filepath
   */


function _join(separator, paths) {
  var result = []; // naive impl: just join all the paths with separator

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = paths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var segment = _step2.value;
      assertSegment(segment);

      if (segment.length !== 0) {
        result.push(segment);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return _normalize(separator, result.join(separator));
}
/**
   * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {string[]} paths [description]
   * @return {string}       [description]
   */


function _resolve(separator, paths) {
  var resolved = '';
  var hitRoot = false;
  var isPosix = separator === '/'; // go from right to left until we hit absolute path/root

  for (var i = paths.length - 1; i >= 0; i--) {
    var segment = paths[i];
    assertSegment(segment);

    if (segment.length === 0) {
      continue; // skip empty
    }

    resolved = segment + separator + resolved; // prepend new segment

    if (_isAbsolute(isPosix, segment)) {
      // have we backed into an absolute path?
      hitRoot = true;
      break;
    }
  } // if we didn't hit root, prepend cwd


  if (!hitRoot) {
    resolved = process.cwd() + separator + resolved;
  }

  var normalized = _normalize(separator, resolved);

  if (normalized.charAt(normalized.length - 1) === separator) {
    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\host-name\\resource\\'
    // Don't remove trailing separator if this is root path on windows!
    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {
      return normalized;
    } // otherwise trim trailing separator


    return normalized.slice(0, normalized.length - 1);
  }

  return normalized;
}
/**
   * The `path.relative()` method returns the relative path `from` from to `to` based
   * on the current working directory. If from and to each resolve to the same
   * path (after calling `path.resolve()` on each), a zero-length string is returned.
   *
   * If a zero-length string is passed as `from` or `to`, the current working directory
   * will be used instead of the zero-length strings.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {string} from [description]
   * @param  {string} to   [description]
   * @return {string}      [description]
   */


function _relative(separator, from, to) {
  assertArgumentType(from, 'from', 'string');
  assertArgumentType(to, 'to', 'string');

  if (from === to) {
    return '';
  }

  from = _resolve(separator, [from]);
  to = _resolve(separator, [to]);

  if (from === to) {
    return '';
  } // we now have two absolute paths,
  // lets "go up" from `from` until we reach common base dir of `to`
  // const originalFrom = from;


  var upCount = 0;
  var remainingPath = '';

  while (true) {
    if (to.startsWith(from)) {
      // match! record rest...?
      remainingPath = to.slice(from.length);
      break;
    } // FIXME: Break/throw if we hit bad edge case of no common root!


    from = _dirname(separator, from);
    upCount++;
  } // remove leading separator from remainingPath if there is any


  if (remainingPath.length > 0) {
    remainingPath = remainingPath.slice(1);
  }

  return ('..' + separator).repeat(upCount) + remainingPath;
}
/**
   * The `path.parse()` method returns an object whose properties represent
   * significant elements of the path. Trailing directory separators are ignored,
   * see `path.sep`.
   *
   * The returned object will have the following properties:
   *
   * - dir <string>
   * - root <string>
   * - base <string>
   * - name <string>
   * - ext <string>
   * @param  {string} separator platform-specific file separator
   * @param  {string} filepath [description]
   * @return {object}
   */


function _parse(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  var result = {
    root: '',
    dir: '',
    base: '',
    ext: '',
    name: '' };

  var length = filepath.length;

  if (length === 0) {
    return result;
  } // Cheat and just call our other methods for dirname/basename/extname?


  result.base = _basename(separator, filepath);
  result.ext = _extname(separator, result.base);
  var baseLength = result.base.length;
  result.name = result.base.slice(0, baseLength - result.ext.length);
  var toSubtract = baseLength === 0 ? 0 : baseLength + 1;
  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!

  var firstCharCode = filepath.charCodeAt(0); // both win32 and POSIX return '/' root

  if (firstCharCode === FORWARD_SLASH) {
    result.root = '/';
    return result;
  } // we're done with POSIX...


  if (separator === '/') {
    return result;
  } // for win32...


  if (firstCharCode === BACKWARD_SLASH) {
    // FIXME: Handle UNC paths like '\\\\host-name\\resource\\file_path'
    // need to retain '\\\\host-name\\resource\\' as root in that case!
    result.root = '\\';
    return result;
  } // check for C: style root


  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {
    if (length > 2) {
      // is it like C:\\?
      var thirdCharCode = filepath.charCodeAt(2);

      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {
        result.root = filepath.slice(0, 3);
        return result;
      }
    } // nope, just C:, no trailing separator


    result.root = filepath.slice(0, 2);
  }

  return result;
}
/**
   * The `path.format()` method returns a path string from an object. This is the
   * opposite of `path.parse()`.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {object} pathObject object of format returned by `path.parse()`
   * @param  {string} pathObject.dir directory name
   * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided
   * @param  {string} pathObject.base file basename
   * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists
   * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists
   * @return {string}
   */


function _format(separator, pathObject) {
  assertArgumentType(pathObject, 'pathObject', 'object');
  var base = pathObject.base || "".concat(pathObject.name || '').concat(pathObject.ext || ''); // append base to root if `dir` wasn't specified, or if
  // dir is the root

  if (!pathObject.dir || pathObject.dir === pathObject.root) {
    return "".concat(pathObject.root || '').concat(base);
  } // combine dir + / + base


  return "".concat(pathObject.dir).concat(separator).concat(base);
}
/**
   * On Windows systems only, returns an equivalent namespace-prefixed path for
   * the given path. If path is not a string, path will be returned without modifications.
   * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces
   * @param  {string} filepath [description]
   * @return {string}          [description]
   */


function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    return filepath;
  }

  if (filepath.length === 0) {
    return '';
  }

  var resolvedPath = _resolve('\\', [filepath]);

  var length = resolvedPath.length;

  if (length < 2) {
    // need '\\\\' or 'C:' minimum
    return filepath;
  }

  var firstCharCode = resolvedPath.charCodeAt(0); // if start with '\\\\', prefix with UNC root, drop the slashes

  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\') {
    // return as-is if it's an aready long path ('\\\\?\\' or '\\\\.\\' prefix)
    if (length >= 3) {
      var thirdChar = resolvedPath.charAt(2);

      if (thirdChar === '?' || thirdChar === '.') {
        return filepath;
      }
    }

    return '\\\\?\\UNC\\' + resolvedPath.slice(2);
  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {
    return '\\\\?\\' + resolvedPath;
  }

  return filepath;
}

var Win32Path = {
  sep: '\\',
  delimiter: ';',
  basename: function basename(filepath, ext) {
    return _basename(this.sep, filepath, ext);
  },
  normalize: function normalize(filepath) {
    return _normalize(this.sep, filepath);
  },
  join: function join() {
    for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
      paths[_key] = arguments[_key];
    }

    return _join(this.sep, paths);
  },
  extname: function extname(filepath) {
    return _extname(this.sep, filepath);
  },
  dirname: function dirname(filepath) {
    return _dirname(this.sep, filepath);
  },
  isAbsolute: function isAbsolute(filepath) {
    return _isAbsolute(false, filepath);
  },
  relative: function relative(from, to) {
    return _relative(this.sep, from, to);
  },
  resolve: function resolve() {
    for (var _len2 = arguments.length, paths = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      paths[_key2] = arguments[_key2];
    }

    return _resolve(this.sep, paths);
  },
  parse: function parse(filepath) {
    return _parse(this.sep, filepath);
  },
  format: function format(pathObject) {
    return _format(this.sep, pathObject);
  },
  toNamespacedPath: toNamespacedPath };

var PosixPath = {
  sep: '/',
  delimiter: ':',
  basename: function basename(filepath, ext) {
    return _basename(this.sep, filepath, ext);
  },
  normalize: function normalize(filepath) {
    return _normalize(this.sep, filepath);
  },
  join: function join() {
    for (var _len3 = arguments.length, paths = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      paths[_key3] = arguments[_key3];
    }

    return _join(this.sep, paths);
  },
  extname: function extname(filepath) {
    return _extname(this.sep, filepath);
  },
  dirname: function dirname(filepath) {
    return _dirname(this.sep, filepath);
  },
  isAbsolute: function isAbsolute(filepath) {
    return _isAbsolute(true, filepath);
  },
  relative: function relative(from, to) {
    return _relative(this.sep, from, to);
  },
  resolve: function resolve() {
    for (var _len4 = arguments.length, paths = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      paths[_key4] = arguments[_key4];
    }

    return _resolve(this.sep, paths);
  },
  parse: function parse(filepath) {
    return _parse(this.sep, filepath);
  },
  format: function format(pathObject) {
    return _format(this.sep, pathObject);
  },
  toNamespacedPath: function toNamespacedPath(filepath) {
    return filepath; // no-op
  } };

var path = isWin32 ? Win32Path : PosixPath;
path.win32 = Win32Path;
path.posix = PosixPath;

var isAndroid = Ti.Platform.osname === 'android';
var isIOS = !isAndroid && (Ti.Platform.osname === 'iphone' || Ti.Platform.osname === 'ipad');
var isWin32$1 = !isAndroid && !isIOS && Ti.Platform.name === 'windows';
var PosixConstants = {
  UV_UDP_REUSEADDR: 4,
  dlopen: {},
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18 },

  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12 },

  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20 } };

// default implementations

var OS = {
  EOL: '\n',
  arch: function arch() {
    return process.arch;
  },
  constants: PosixConstants,
  cpus: function cpus() {
    var count = Ti.Platform.processorCount;
    var array = [];

    for (var i = 0; i < count; i++) {
      array.push({
        model: 'unknown',
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0 } });


    }

    return array;
  },
  endianness: function endianness() {
    // TODO: Cache the value!
    var result = Ti.Codec.getNativeByteOrder();

    if (result === Ti.Codec.LITTLE_ENDIAN) {
      return 'LE';
    }

    return 'BE';
  },
  freemem: function freemem() {
    return Ti.Platform.availableMemory;
  },
  getPriority: function getPriority() {
    return 0;
  },
  // fake it
  homedir: function homedir() {
    return Ti.Filesystem.applicationDataDirectory;
  },
  // fake it
  hostname: function hostname() {
    return Ti.Platform.address;
  },
  // fake it
  loadavg: function loadavg() {
    return [0, 0, 0];
  },
  // fake it
  networkInterfaces: function networkInterfaces() {},
  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address
  platform: function platform() {
    return process.platform;
  },
  release: function release() {
    return Ti.Platform.version;
  },
  setPriority: function setPriority() {},
  // no-op, fake it

  /**
   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.
   * @return {string} [description]
   */
  tmpdir: function tmpdir() {
    return Ti.Filesystem.tempDirectory;
  },

  /**
      * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.
      * @return {integer} [description]
      */
  totalmem: function totalmem() {
    return Ti.Platform.totalMemory;
  },
  type: function type() {
    return 'Unknown';
  },
  // overridden per-platform at bottom

  /**
   * The `os.uptime()` method returns the system uptime in number of seconds.
   * @return {integer} [description]
   */
  uptime: function uptime() {
    return Ti.Platform.uptime;
  },
  userInfo: function userInfo() {
    // fake it!
    return {
      uid: -1,
      guid: -1,
      username: Ti.Platform.username,
      homedir: Ti.Filesystem.applicationDataDirectory,
      shell: null };

  } };
// On specific platforms, override implementations because we don't have them
// yet and need to fake it, or to hack them
// I'm also doing this in blocks to assign implementations that don't need to consult platform
// type at runtime (hopefully speeding up execution at runtime)

if (isIOS) {
  OS.type = function () {
    return 'Darwin';
  }; // Now a giant hack for looking up CPU info for OS.cpus() on iOS
  // https://www.theiphonewiki.com/wiki/List_of_iPhones


  var AppleMap = {
    // iPhone 11 Pro Max
    'iPhone12,5': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone 11 Pro
    'iPhone12,3': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone 11
    'iPhone12,1': ['Apple A13 Bionic @ 2.66 GHz', 2660],
    // iPhone XR
    'iPhone11,8': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone XS Max
    'iPhone11,6': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    'iPhone11,4': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone XS
    'iPhone11,2': ['Apple A12 Bionic @ 2.49 GHz', 2490],
    // iPhone X
    'iPhone10,6': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,3': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 8 Plus
    'iPhone10,5': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,2': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 8
    'iPhone10,4': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    'iPhone10,1': ['Apple A11 Bionic @ 2.39 GHz', 2390],
    // iPhone 7 Plus
    'iPhone9,4': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    'iPhone9,2': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    // iPhone 7
    'iPhone9,3': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    'iPhone9,1': ['Apple A10 Fusion @ 2.34 GHz', 2340],
    // iPhone SE
    'iPhone8,4': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6s Plus
    'iPhone8,2': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6s
    'iPhone8,1': ['Apple A9 Twister @ 1.85 GHz', 1850],
    // iPhone 6 Plus
    'iPhone7,1': ['Apple A8 Typhoon @ 1.38 GHz', 1380],
    // iPhone 6
    'iPhone7,2': ['Apple A8 Typhoon @ 1.38 GHz', 1380],
    // iPhone 5s
    'iPhone6,2': ['Apple A7 Cyclone @ 1.3 GHz', 1300],
    'iPhone6,1': ['Apple A7 Cyclone @ 1.3 GHz', 1300],
    // iPhone 5c
    'iPhone5,4': ['Apple A6 Swift @ 1.2 GHz', 1200],
    'iPhone5,3': ['Apple A6 Swift @ 1.2 GHz', 1200],
    // iPhone 5
    'iPhone5,1': ['Apple A6 Swift @ 1.2 GHz', 1200],
    'iPhone5,2': ['Apple A6 Swift @ 1.2 GHz', 1200],
    // iPhone 4s
    'iPhone4,1': ['Apple A5 @ 800 MHz', 800],
    // iPhone 4
    'iPhone3,3': ['Apple A4 @ 800 MHz', 800],
    'iPhone3,2': ['Apple A4 @ 800 MHz', 800],
    'iPhone3,1': ['Apple A4 @ 800 MHz', 800],
    // iPhone 3GS
    'iPhone2,1': ['Samsung S5L8920 @ 620 MHz', 620],
    // iPhone 3G
    'iPhone1,2': ['Samsung S5L8900 @ 412 MHz', 412],
    // iPhone
    'iPhone1,1': ['Samsung S5L8900 @ 412 MHz', 412],
    // ////// iPads
    // https://www.theiphonewiki.com/wiki/List_of_iPads
    // https://en.wikipedia.org/wiki/IPad
    // iPad Pro (12.9" 3rd gen)
    'iPad8,8': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,7': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,6': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,5': ['Apple A12X @ 2.49 GHz', 2490],
    // iPad Pro (11")
    'iPad8,4': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,3': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,2': ['Apple A12X @ 2.49 GHz', 2490],
    'iPad8,1': ['Apple A12X @ 2.49 GHz', 2490],
    // iPad (6th gen)
    'iPad7,6': ['Apple A10 @ 2.31 GHz', 2310],
    // FIXME: Wikipedia says 2.34 GHz
    'iPad7,5': ['Apple A10 @ 2.31 GHz', 2310],
    // iPad Pro (10.5")
    'iPad7,4': ['Apple A10X @ 2.38 GHz', 2380],
    'iPad7,3': ['Apple A10X @ 2.38 GHz', 2380],
    // iPad Pro (12.9" 2nd gen)
    'iPad7,2': ['Apple A10X @ 2.38 GHz', 2380],
    'iPad7,1': ['Apple A10X @ 2.38 GHz', 2380],
    // iPad (5th gen)
    'iPad6,12': ['Apple A9 @ 1.85 GHz', 1850],
    'iPad6,11': ['Apple A9 @ 1.85 GHz', 1850],
    // iPad Pro (12.9" 1st gen)
    'iPad6,8': ['Apple A9X @ 2.24 GHz', 2240],
    'iPad6,7': ['Apple A9X @ 2.24 GHz', 2240],
    // iPad Pro (9.7")
    'iPad6,4': ['Apple A9X @ 2.16 GHz', 2160],
    'iPad6,3': ['Apple A9X @ 2.16 GHz', 2160],
    // iPad Air 2
    'iPad5,4': ['Apple A8X @ 1.5 GHz', 1500],
    'iPad5,3': ['Apple A8X @ 1.5 GHz', 1500],
    // iPad Mini 4
    'iPad5,2': ['Apple A8 @ 1.49 GHz', 1490],
    'iPad5,1': ['Apple A8 @ 1.49 GHz', 1490],
    // iPad Mini 3
    'iPad4,9': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,8': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,7': ['Apple A7 @ 1.3 GHz', 1300],
    // iPad Mini 2
    'iPad4,6': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,5': ['Apple A7 @ 1.3 GHz', 1300],
    'iPad4,4': ['Apple A7 @ 1.3 GHz', 1300],
    // iPad Air 2
    'iPad4,3': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    'iPad4,2': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    'iPad4,1': ['Apple A7 Rev A @ 1.4 GHz', 1400],
    // iPad (4th gen)
    'iPad3,6': ['Apple A6X @ 1.4 GHz', 1400],
    'iPad3,5': ['Apple A6X @ 1.4 GHz', 1400],
    'iPad3,4': ['Apple A6X @ 1.4 GHz', 1400],
    // iPad (3rd gen)
    'iPad3,3': ['Apple A5X @ 1 GHz', 1000],
    'iPad3,2': ['Apple A5X @ 1 GHz', 1000],
    'iPad3,1': ['Apple A5X @ 1 GHz', 1000],
    // iPad Mini
    'iPad2,7': ['Apple A5 Rev A @ 1 GHz', 1000],
    'iPad2,6': ['Apple A5 Rev A @ 1 GHz', 1000],
    'iPad2,5': ['Apple A5 Rev A @ 1 GHz', 1000],
    // iPad 2
    'iPad2,4': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,3': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,2': ['Apple A5 @ 1 GHz', 1000],
    'iPad2,1': ['Apple A5 @ 1 GHz', 1000],
    // iPad
    'iPad1,1': ['Apple A4 @ 1 GHz', 1000] };

  /**
                                              * [cpuModel description]
                                              * @param  {string} model [description]
                                              * @return {array}       [description]
                                              */

  var cpuModelAndSpeed = function cpuModelAndSpeed(model) {
    var trimmed = model.replace(' (Simulator)', '').trim();
    return AppleMap[trimmed] || ['Unknown', 0];
  }; // override cpus impl


  OS.cpus = function () {
    // TODO: Cache the result!
    var count = Ti.Platform.processorCount;
    var modelAndSpeed = cpuModelAndSpeed(Ti.Platform.model);
    var array = [];

    for (var i = 0; i < count; i++) {
      array.push({
        model: modelAndSpeed[0],
        speed: modelAndSpeed[1],
        times: {} });

    }

    return array;
  };
} else if (isWin32$1) {
  OS.uptime = function () {
    return 0;
  }; // FIXME: Implement!


  OS.totalmem = function () {
    return Number.MAX_VALUE;
  }; // FIXME: Implement!


  OS.EOL = '\r\n';

  OS.type = function () {
    return 'Windows_NT';
  };

  OS.constants = {
    UV_UDP_REUSEADDR: 4,
    dlopen: {},
    errno: {
      E2BIG: 7,
      EACCES: 13,
      EADDRINUSE: 100,
      EADDRNOTAVAIL: 101,
      EAFNOSUPPORT: 102,
      EAGAIN: 11,
      EALREADY: 103,
      EBADF: 9,
      EBADMSG: 104,
      EBUSY: 16,
      ECANCELED: 105,
      ECHILD: 10,
      ECONNABORTED: 106,
      ECONNREFUSED: 107,
      ECONNRESET: 108,
      EDEADLK: 36,
      EDESTADDRREQ: 109,
      EDOM: 33,
      EEXIST: 17,
      EFAULT: 14,
      EFBIG: 27,
      EHOSTUNREACH: 110,
      EIDRM: 111,
      EILSEQ: 42,
      EINPROGRESS: 112,
      EINTR: 4,
      EINVAL: 22,
      EIO: 5,
      EISCONN: 113,
      EISDIR: 21,
      ELOOP: 114,
      EMFILE: 24,
      EMLINK: 31,
      EMSGSIZE: 115,
      ENAMETOOLONG: 38,
      ENETDOWN: 116,
      ENETRESET: 117,
      ENETUNREACH: 118,
      ENFILE: 23,
      ENOBUFS: 119,
      ENODATA: 120,
      ENODEV: 19,
      ENOENT: 2,
      ENOEXEC: 8,
      ENOLCK: 39,
      ENOLINK: 121,
      ENOMEM: 12,
      ENOMSG: 122,
      ENOPROTOOPT: 123,
      ENOSPC: 28,
      ENOSR: 124,
      ENOSTR: 125,
      ENOSYS: 40,
      ENOTCONN: 126,
      ENOTDIR: 20,
      ENOTEMPTY: 41,
      ENOTSOCK: 128,
      ENOTSUP: 129,
      ENOTTY: 25,
      ENXIO: 6,
      EOPNOTSUPP: 130,
      EOVERFLOW: 132,
      EPERM: 1,
      EPIPE: 32,
      EPROTO: 134,
      EPROTONOSUPPORT: 135,
      EPROTOTYPE: 136,
      ERANGE: 34,
      EROFS: 30,
      ESPIPE: 29,
      ESRCH: 3,
      ETIME: 137,
      ETIMEDOUT: 138,
      ETXTBSY: 139,
      EWOULDBLOCK: 140,
      EXDEV: 18,
      WSAEINTR: 10004,
      WSAEBADF: 10009,
      WSAEACCES: 10013,
      WSAEFAULT: 10014,
      WSAEINVAL: 10022,
      WSAEMFILE: 10024,
      WSAEWOULDBLOCK: 10035,
      WSAEINPROGRESS: 10036,
      WSAEALREADY: 10037,
      WSAENOTSOCK: 10038,
      WSAEDESTADDRREQ: 10039,
      WSAEMSGSIZE: 10040,
      WSAEPROTOTYPE: 10041,
      WSAENOPROTOOPT: 10042,
      WSAEPROTONOSUPPORT: 10043,
      WSAESOCKTNOSUPPORT: 10044,
      WSAEOPNOTSUPP: 10045,
      WSAEPFNOSUPPORT: 10046,
      WSAEAFNOSUPPORT: 10047,
      WSAEADDRINUSE: 10048,
      WSAEADDRNOTAVAIL: 10049,
      WSAENETDOWN: 10050,
      WSAENETUNREACH: 10051,
      WSAENETRESET: 10052,
      WSAECONNABORTED: 10053,
      WSAECONNRESET: 10054,
      WSAENOBUFS: 10055,
      WSAEISCONN: 10056,
      WSAENOTCONN: 10057,
      WSAESHUTDOWN: 10058,
      WSAETOOMANYREFS: 10059,
      WSAETIMEDOUT: 10060,
      WSAECONNREFUSED: 10061,
      WSAELOOP: 10062,
      WSAENAMETOOLONG: 10063,
      WSAEHOSTDOWN: 10064,
      WSAEHOSTUNREACH: 10065,
      WSAENOTEMPTY: 10066,
      WSAEPROCLIM: 10067,
      WSAEUSERS: 10068,
      WSAEDQUOT: 10069,
      WSAESTALE: 10070,
      WSAEREMOTE: 10071,
      WSASYSNOTREADY: 10091,
      WSAVERNOTSUPPORTED: 10092,
      WSANOTINITIALISED: 10093,
      WSAEDISCON: 10101,
      WSAENOMORE: 10102,
      WSAECANCELLED: 10103,
      WSAEINVALIDPROCTABLE: 10104,
      WSAEINVALIDPROVIDER: 10105,
      WSAEPROVIDERFAILEDINIT: 10106,
      WSASYSCALLFAILURE: 10107,
      WSASERVICE_NOT_FOUND: 10108,
      WSATYPE_NOT_FOUND: 10109,
      WSA_E_NO_MORE: 10110,
      WSA_E_CANCELLED: 10111,
      WSAEREFUSED: 10112 },

    signals: {
      SIGHUP: 1,
      SIGINT: 2,
      SIGILL: 4,
      SIGABRT: 22,
      SIGFPE: 8,
      SIGKILL: 9,
      SIGSEGV: 11,
      SIGTERM: 15,
      SIGBREAK: 21,
      SIGWINCH: 28 },

    priority: {
      PRIORITY_LOW: 19,
      PRIORITY_BELOW_NORMAL: 10,
      PRIORITY_NORMAL: 0,
      PRIORITY_ABOVE_NORMAL: -7,
      PRIORITY_HIGH: -14,
      PRIORITY_HIGHEST: -20 } };


} else if (isAndroid) {
  OS.cpus = function () {
    return Ti.Platform.cpus();
  };

  OS.type = function () {
    return 'Linux';
  };
}

var tty = {
  isatty: function isatty() {
    return false;
  },
  ReadStream: function ReadStream() {
    throw new Error('tty.ReadStream is not implemented');
  },
  WriteStream: function WriteStream() {
    throw new Error('tty.WriteStream is not implemented');
  } };


var MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var util = {
  // So node actually calls into native code for these checks, but I think for shim compatability this is good enough
  // There's overhead for doing the native checks, and it'd require a native module to achieve.
  types: {
    // TODO: We're missing a lot of the methods hanging off this namespace!
    isNumberObject: function isNumberObject(value) {
      return typeof value === 'object' && Object.prototype.toString.call(value) === '[object Number]';
    },
    isStringObject: function isStringObject(value) {
      return typeof value === 'object' && Object.prototype.toString.call(value) === '[object String]';
    },
    isBooleanObject: function isBooleanObject(value) {
      return typeof value === 'object' && Object.prototype.toString.call(value) === '[object Boolean]';
    },
    // isBigIntObject: value => {
    // 	return Object.prototype.toString.call(value) === '[object BigInt]';
    // },
    isSymbolObject: function isSymbolObject(value) {
      return typeof value === 'object' && Object.prototype.toString.call(value) === '[object Symbol]';
    },
    isBoxedPrimitive: function isBoxedPrimitive(value) {
      if (typeof value !== 'object') {
        return false;
      }

      return this.isNumberObject(value) || this.isStringObject(value) || this.isBooleanObject(value) // || this.isBigIntObject(value)
      || this.isSymbolObject(value);
    },
    isNativeError: function isNativeError(value) {
      // if not an instance of an Error, definitely not a native error
      if (!(value instanceof Error)) {
        return false;
      }

      if (!value || !value.constructor) {
        return false;
      }

      return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);
    },
    isPromise: function isPromise(value) {
      var valueType = typeof value;
      return (valueType === 'object' || valueType === 'function') && value.then && typeof value.then === 'function';
    },
    isSet: function isSet(value) {
      return value instanceof Set;
    },
    isMap: function isMap(value) {
      return value instanceof Map;
    },
    isDate: function isDate(value) {
      return value instanceof Date;
    },
    isRegexp: function isRegexp(value) {
      return value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]';
    } },

  isArray: function isArray(value) {
    return Array.isArray(value);
  },
  isBoolean: function isBoolean(value) {
    return typeof value === 'boolean';
  },
  isFunction: function isFunction(value) {
    return typeof value === 'function';
  },
  isNull: function isNull(value) {
    return value === null;
  },
  isNullOrUndefined: function isNullOrUndefined(value) {
    return value === undefined || value === null;
  },
  isNumber: function isNumber(value) {
    return typeof value === 'number';
  },
  isObject: function isObject(value) {
    return value !== null && typeof value === 'object';
  },
  isPrimitive: function isPrimitive(value) {
    return typeof value !== 'object' && typeof value !== 'function' || value === null;
  },
  isString: function isString(value) {
    return typeof value === 'string';
  },
  isSymbol: function isSymbol(value) {
    return typeof value === 'symbol';
  },
  isUndefined: function isUndefined(value) {
    return value === undefined;
  },
  log: function log(string) {
    var date = new Date();
    var time = "".concat(date.getHours().toString().padStart(2, '0'), ":").concat(date.getMinutes().toString().padStart(2, '0'), ":").concat(date.getSeconds().toString().padStart(2, '0')); // Produces output like: "21 Feb 10:04:23 - message"

    console.log("".concat(date.getDate(), " ").concat(MONTHS[date.getMonth()], " ").concat(time, " - ").concat(string));
  },
  print: function print() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return console.log(args.join(''));
  },
  // FIXME: Shouldn't add trailing newline like console.log does!
  puts: function puts() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return console.log(args.join('\n'));
  },
  error: function error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return console.error(args.join('\n'));
  },
  debug: function debug(string) {
    return console.error("DEBUG: ".concat(string));
  } };


util.isBuffer = function () {
  return false;
}; // FIXME: Check for Ti.Buffer? for node/browserify buffer?


util.isDate = function (value) {
  return util.types.isDate(value);
};

util.isError = function (value) {
  return util.types.isNativeError(value);
};

util.isRegexp = function (value) {
  return util.types.isRegexp(value);
};

function getConstructor(obj) {
  if (obj.constructor) {
    return obj.constructor.name;
  }

  return 'Object';
}

var defaultInspectOptions = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  breakLength: 60,
  compact: true,
  sorted: false,
  getters: false };


function formatArray(array, options) {
  var maxLength = Math.max(0, options.maxArrayLength);
  var arrayLength = array.length;
  var values = [];
  var consecutiveEmpties = 0;
  var i = 0; // for sparse arrays, consecutive empties count as a "single item" in terms of maxArrayLength

  for (; i < arrayLength; i++) {
    // don't go past end of array...
    var value = array[i];

    if (value === undefined) {
      // sparse array!
      consecutiveEmpties++;
      continue;
    } // non-empty index currently...


    if (consecutiveEmpties > 0) {
      // were we collecting consecutive empty indices as a single gap?
      values.push("<".concat(consecutiveEmpties, " empty item").concat(consecutiveEmpties > 1 ? 's' : '', ">"));
      consecutiveEmpties = 0; // reset our count

      if (values.length >= maxLength) {
        // don't show more than options.maxArrayLength "values"
        break;
      }
    } // push the current index value


    values.push(util.inspect(value, options));

    if (values.length >= maxLength) {
      // don't show more than options.maxArrayLength "values"
      i++; // so our "remaining" count is correct

      break;
    }
  }

  var remaining = arrayLength - i;

  if (remaining > 0) {
    // did we stop before the end of the array (due to options.maxArrayLength)?
    values.push("... ".concat(remaining, " more item").concat(remaining > 1 ? 's' : ''));
  } else if (consecutiveEmpties > 0) {
    // did the sparse array gaps run to the end of the array?
    values.push("<".concat(consecutiveEmpties, " empty item").concat(consecutiveEmpties > 1 ? 's' : '', ">"));
  }

  return values;
}
/**
   * @param {*} obj JS value or object to inspect
   * @param {object} [options] options for output
   * @param {Integer} [options.breakLength=60] length at which to break properties into individual lines
   * @param {boolean} [options.showHidden=false] whether to include hidden properties (non-enumerable)
   * @param {boolean} [options.sorted=false] whether to sort the property listings per-object
   * @param {boolean} [options.compact=true] if set to `false`, uses luxurious amount of spacing and newlines
   * @param {Integer} [options.depth=2] depth to recurse into objects
   * @returns {string}
   */


util.inspect = function (obj) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var mergedOptions = Object.assign({}, defaultInspectOptions, options); // increase our recursion counter to avoid going past depth

  if (mergedOptions.recursionCount === undefined) {
    mergedOptions.recursionCount = -1;
  }

  mergedOptions.recursionCount++;

  if (mergedOptions.indentLevel === undefined) {
    mergedOptions.indentLevel = 0;
  }

  try {
    var objType = typeof obj;

    if (objType === 'object' || objType === 'function') {
      if (obj === null) {
        return 'null';
      } // Guard against circular references


      mergedOptions.memo = mergedOptions.memo || [];

      if (mergedOptions.memo.includes(obj)) {
        return '[Circular]';
      }

      try {
        mergedOptions.memo.push(obj); // popped off in a finally block, so we only worry about circular references, not sibling references

        var constructorName = getConstructor(obj); // if the constructor name is not 'Object', pre-pend it!

        var prefix = '';

        if (constructorName !== 'Object') {
          prefix = "".concat(constructorName, " ");
        } // now grab the type tag if it has one!


        var tag = obj[Symbol.toStringTag];

        if (tag && tag !== constructorName) {
          prefix = "".concat(prefix, "[").concat(tag, "] ");
        } // what braces do we use to enclose the values/properties?


        var open = '{';
        var close = '}';
        var header = ''; // for special cases like Function where we pre-pend header info

        var values = []; // collect the values/properties we list!

        var isArray = Array.isArray(obj);

        if (isArray) {
          if (prefix === 'Array ') {
            prefix = ''; // wipe "normal" Array prefixes
          }

          open = '[';
          close = ']';
          // use array braces
          values.push.apply(values, _toConsumableArray(formatArray(obj, mergedOptions)));
        } else if (util.types.isMap(obj)) {
          if (obj.size > 0) {
            values.push.apply(values, _toConsumableArray(Array.from(obj).map(function (entry) {
              return "".concat(util.inspect(entry[0], mergedOptions), " => ").concat(util.inspect(entry[1], mergedOptions));
            })));
          }
        } else if (util.types.isSet(obj)) {
          if (obj.size > 0) {
            values.push.apply(values, _toConsumableArray(Array.from(obj).map(function (o) {
              return util.inspect(o, mergedOptions);
            })));
          }
        } else if (util.types.isRegexp(obj)) {
          // don't do prefix or any of that crap! TODO: Can we just call Regexp.prototype.toString.call()?
          return "/".concat(obj.source, "/").concat(obj.flags);
        } else if (util.isFunction(obj)) {
          if (prefix === 'Function ') {
            prefix = ''; // wipe "normal" Function prefixes
          } // Functions are special and we must use a "header"
          // if no values/properties, just print the "header"
          // if any, stick "header" inside braces before property/value listing


          if (obj.name) {
            header = "[Function: ".concat(obj.name, "]");
          } else {
            header = '[Function]';
          }
        } // If we've gone past our depth, just do a quickie result here, like '[Object]'


        if (mergedOptions.recursionCount > mergedOptions.depth) {
          return header || "[".concat(constructorName || tag || 'Object', "]");
        } // handle properties


        var properties = []; // if showing hidden, get all own properties, otherwise just enumerable

        var ownProperties = mergedOptions.showHidden ? Object.getOwnPropertyNames(obj) : Object.keys(obj); // FIXME: On V8/Android we are not getting 'arguments' and 'caller' properties!
        // This may be because in newer specs/strict mode they shouldn't be accessible?

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = ownProperties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var propName = _step.value;

            if (isArray && propName.match(/^\d+$/)) {
              // skip Array's index properties
              continue;
            }

            var propDesc = Object.getOwnPropertyDescriptor(obj, propName) || {
              value: obj[propName],
              enumerable: true };
            // fall back to faking a descriptor

            var key = propDesc.enumerable ? propName : "[".concat(propName, "]"); // If not enumerable, wrap name in []!

            if (propDesc.value !== undefined) {
              mergedOptions.indentLevel += 3; // Node uses 3 spaces for arrays/Objects?

              var space = ' ';

              var _value2 = util.inspect(propDesc.value, mergedOptions); // if value is breaking, break between key and top-level value


              if (_value2.length > mergedOptions.breakLength) {
                space = "\n".concat(' '.repeat(mergedOptions.indentLevel));
              }

              mergedOptions.indentLevel -= 3;
              properties.push("".concat(key, ":").concat(space).concat(_value2));
            } else if (propDesc.get !== undefined) {
              // TODO: Handle when options.getters === true, need to actually attempt to get and show value!
              if (propDesc.set !== undefined) {
                properties.push("".concat(key, ": [Getter/Setter]"));
              } else {
                properties.push("".concat(key, ": [Getter]"));
              }
            } else if (propDesc.set !== undefined) {
              properties.push("".concat(key, ": [Setter]"));
            } else {
              // weird case of a property defined with an explicit undefined value
              properties.push("".concat(key, ": undefined"));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (properties.length !== 0) {
          // TODO: Handle custom sorting option!
          if (mergedOptions.sorted) {
            properties.sort();
          }

          values.push.apply(values, properties);
        }

        var value = '';

        if (values.length === 0) {
          if (header.length > 0) {
            value = header; // i.e. '[Function: name]'
          } else {
            value = "".concat(open).concat(close); // no spaces, i.e. '{}' or '[]'
          }
        } else {
          var str = '';

          if (header.length > 0) {
            // i.e. '{ [Function] a: 1, b: 2 }'
            str = "".concat(header, " ");
          } // Handle breaking them by breakLength here!


          var length = 0;

          for (var _i = 0, _values = values; _i < _values.length; _i++) {
            var _value = _values[_i];
            length += _value.length + 1; // Node seems to add one for comma, but not more for spaces?

            if (length > mergedOptions.breakLength) {
              // break early if length > breakLength!
              break;
            }
          }

          if (length > mergedOptions.breakLength) {
            var indent = ' '.repeat(mergedOptions.indentLevel); // break them up!

            str += values.join(",\n".concat(indent, "  "));
          } else {
            str += values.join(', ');
          }

          value = "".concat(open, " ").concat(str, " ").concat(close); // spaces between braces and values/properties
        }

        return "".concat(prefix).concat(value);
      } finally {
        mergedOptions.memo.pop(obj);
      }
    } // only special case is -0


    if (objType === 'string') {
      return "'".concat(obj, "'");
    } else if (objType === 'number' && Object.is(obj, -0)) {
      // can't check for -0 using ===
      return '-0';
    } else if (util.isSymbol(obj)) {
      return obj.toString();
    } // TODO: Handle BigInt?


    return "".concat(obj);
  } finally {
    mergedOptions.recursionCount--;
  }
};
/**
    * Retruns result of `JSON.stringify()` if possible, falling back to `'[Circular]'` if that throws.
    * @param {*} value The value/object to stringify
    * @returns {string}
    */


function stringify(value) {
  try {
    return JSON.stringify(value);
  } catch (e) {
    if (e instanceof TypeError && (e.message.includes('circular') || e.message.includes('cyclic'))) {
      // "Converting circular structure to JSON"
      // JSC gives: "JSON.stringify cannot serialize cyclic structures."
      // TODO: Maybe force a circular reference object through and sniff the JS engine's message generated to match against?
      return '[Circular]';
    }

    throw e;
  }
}

util.format = function () {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  var firstArg = args[0];

  if (typeof firstArg === 'string') {
    // normal usage!
    if (args.length === 1) {
      return firstArg;
    } // TODO: ok, we really do have to look at the string to find the % specifiers
    // Do we loop over the args.length and find next index of '%', match what type it is and replace?


    var lastIndex = 0;
    var str = '';
    var i = 1; // start at second argument

    for (i; i < args.length;) {
      var curArg = args[i];
      var foundIndex = firstArg.indexOf('%', lastIndex);

      if (foundIndex === -1) {
        // No more placeholders left, so break and at bottom we'll append rest of string
        break;
      } // grab segment of string and append to str


      str += firstArg.slice(lastIndex, foundIndex); // now look at next char to see how to replace

      var nextChar = firstArg.charAt(foundIndex + 1);

      switch (nextChar) {
        case 's':
          // string
          str += String(curArg);
          i++; // consume argument

          break;

        case 'd':
          // Number
          if (util.isSymbol(curArg) || util.types.isSymbolObject(curArg)) {
            str += 'NaN';
          } else {
            str += Number(curArg);
          }

          i++; // consume argument

          break;

        case 'i':
          // Integer
          if (util.isSymbol(curArg) || util.types.isSymbolObject(curArg)) {
            str += 'NaN';
          } else {
            str += parseInt(curArg);
          }

          i++; // consume argument

          break;

        case 'f':
          // Float
          if (util.isSymbol(curArg) || util.types.isSymbolObject(curArg)) {
            str += 'NaN';
          } else {
            str += parseFloat(curArg);
          }

          i++; // consume argument

          break;

        case 'j':
          // JSON
          str += stringify(curArg);
          i++; // consume argument

          break;

        case 'o':
          // Object w/showHidden and showProxy
          str += util.inspect(curArg, {
            showHidden: true,
            showProxy: true,
            depth: 4 });

          i++; // consume argument

          break;

        case 'O':
          // Object w/o options
          str += util.inspect(curArg, {});
          i++; // consume argument

          break;

        case '%':
          // escaped %
          str += '%'; // Don't consume argument here!

          break;}


      lastIndex = foundIndex + 2;
    } // If we haven't reached end of string, append rest of it with no replacements!


    str += firstArg.slice(lastIndex, firstArg.length); // If we have args remaining, need to...
    // loop over rest of args and coerce to Strings and concat joined by spaces.
    // Unless typeof === 'object' or 'symbol', then do util.inspect() on them

    if (i < args.length) {
      str += " ".concat(args.slice(i).map(function (a) {
        var aType = typeof a;

        switch (aType) {
          case 'object':
          case 'symbol':
            return util.inspect(a);

          default:
            return String(a);}

      }).join(' '));
    }

    return str;
  } // first arg wasn't string, so we loop over args and call util.inspect on each


  return args.map(function (a) {
    return util.inspect(a);
  }).join(' ');
};
/**
    * @param {Function} constructor subclass
    * @param {Function} superConstructor base class
    * @returns {void}
    */


util.inherits = function (constructor, superConstructor) {
  assertArgumentType(constructor, 'constructor', 'Function');
  assertArgumentType(superConstructor, 'superConstructor', 'Function');
  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');
  Object.defineProperty(constructor, 'super_', {
    value: superConstructor });

  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);
};
/**
    * @param {Function} original original function to wrap which is expected to have a final callback argument
    * @returns {Function} function that returns a Promise
    */


util.promisify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped() {
    var _this = this;

    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return new Promise(function (resolve, reject) {
      original.call.apply(original, [_this].concat(args, [function (err, result) {
        if (err) {
          return reject(err);
        }

        return resolve(result);
      }]));
    });
  } // TODO: Copy properties from original to wrapped
  // TODO: hook prototype chain up from wrapped to original
  // TODO: Support custom promisify hooks


  return wrapped;
};
/**
    * @param {Function} original original function to convert from async/Promise return value to a callback style
    * @returns {Function} wrapped function
    */


util.callbackify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    var callback = args.pop();
    var promise = original.apply(this, args);
    promise.then(function (result) {
      // eslint-disable-line promise/always-return
      callback(null, result); // eslint-disable-line promise/no-callback-in-promise
    }).catch(function (err) {
      if (!err) {
        var wrappedError = new Error('Promise was rejected with falsy value');
        wrappedError.reason = err;
        err = wrappedError;
      }

      callback(err); // eslint-disable-line promise/no-callback-in-promise
    });
  }

  return wrapped;
};
/**
    * @param {Function} func function to deprecate/wrap
    * @param {string} string message to give when deprecation warning is emitted
    * @param {string} code deprecation code to use to group warnings
    * @returns {Function} wrapped function
    */


util.deprecate = function (func, string, code) {
  // eslint-disable-line no-unused-vars
  if (process.noDeprecation) {
    return func; // skip the wrapping!
  } // TODO: Support `code` argument by tracking a map of codes we've warned about


  function wrapped() {
    var warned = false;

    if (!warned) {
      process.emitWarning(string, 'DeprecationWarning');
      warned = true;
    }

    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    return func.apply(this, args);
  }

  return wrapped;
}; // TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?


var noop = function noop() {};

util.debuglog = function () {
  return noop;
};

var DEFAULT_MESSAGES = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:' };
// Fake enums to use internally

var COMPARE_TYPE = {
  Object: 0,
  Map: 1,
  Set: 2 };

var STRICTNESS = {
  Strict: 0,
  Loose: 1 };


var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    _classCallCheck(this, AssertionError);

    var actual = options.actual,
    expected = options.expected,
    message = options.message,
    operator = options.operator;

    if (!message) {
      // FIXME: Generate the rest of the message with diff of actual/expected!
      message = "".concat(DEFAULT_MESSAGES[operator], "\n\n");
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, message));
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    _this.generatedMessage = !message;
    _this.name = 'AssertionError [ERR_ASSERTION]';
    _this.code = 'ERR_ASSERTION';
    return _this;
  }

  return AssertionError;
}(_wrapNativeSuper(Error)); // TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class
// that class holds impls for shared methods, subclasses override specific
// comparisons used (Object.is vs ===)?


var assert = function assert(value, message) {
  return assert.ok(value, message);
};

assert.AssertionError = AssertionError;

assert.ok = function () {
  var value = arguments.length <= 0 ? undefined : arguments[0];

  if (value) {
    return;
  }

  var message = arguments.length <= 1 ? undefined : arguments[1];
  var generatedMessage = false; // Check if value (1st arg) was not supplied!
  // Have to use ugly hack on args definition to do so

  if (arguments.length === 0) {
    message = 'No value argument passed to `assert.ok()`';
    generatedMessage = true;
  } else if (message == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this
    // It treates ok failing like `value == true` failing
    message = 'The expression evaluated to a falsy value:\n\n';
    generatedMessage = true;
  } else if (message instanceof Error) {
    throw message;
  }

  var err = new AssertionError({
    actual: value,
    expected: true,
    message,
    operator: '==' });

  err.generatedMessage = generatedMessage;
  throw err;
};

function throwError(obj) {
  // If message is an Error object, throw that instead!
  if (obj.message instanceof Error) {
    throw obj.message;
  }

  throw new AssertionError(obj);
}

assert.equal = function (actual, expected, message) {
  if (actual == expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'equal' });

};

assert.strictEqual = function (actual, expected, message) {
  if (Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'strictEqual' });

};

assert.notEqual = function (actual, expected, message) {
  if (actual != expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notEqual' });

};

assert.notStrictEqual = function (actual, expected, message) {
  if (!Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notStrictEqual' });

};

var isPrimitive = function isPrimitive(value) {
  return typeof value !== 'object' && typeof value !== 'function' || value === null;
};
/**
    * @param {Map} actual map we are comparing
    * @param {Map} expected map we're comparing against
    * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare
    * @param {object} references memoized references to objects in the deepEqual hierarchy
    * @returns {boolean}
    */


function compareMaps(actual, expected, strictness, references) {
  var looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = actual[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
      key = _step$value[0],
      value = _step$value[1];

      if (typeof key === 'object' && key !== null) {
        // non-null object. We need to do our own checking, not use get()/has()
        looseChecks.add(key);
      } else {
        // handle "primitives"
        if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {
          // yay! a nice easy match - both key and value matched exactly - move on
          continue;
        }

        if (strictness === STRICTNESS.Strict) {
          // if we didn't match key/value perfectly in strict mode, fail right away
          return false;
        } // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again


        looseChecks.add(key);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // only go through the second Map once!


  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = expected[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = _slicedToArray(_step2.value, 2),
      expectedKey = _step2$value[0],
      expectedValue = _step2$value[1];

      // if it's not a non-null object in strict mode, fail!
      // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
      // Note that this shouldn't ever happen since we should be returning false immediately above
      if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {
        return false;
      } // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!


      var found = false;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = looseChecks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var key = _step3.value;

          // if both key and value matches
          if (deepEqual(key, expectedKey, strictness, references) && deepEqual(actual.get(key), expectedValue, strictness, references)) {
            found = true;
            looseChecks.delete(key); // remove from our looseChecks Set since we already matched it

            break;
          }
        } // if not found, we failed to match

      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (!found) {
        return false;
      }
    } // did we leave un-matched keys? if so, fail

  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return looseChecks.size === 0;
}
/**
   * @param {Set} actual map we are comparing
   * @param {Set} expected map we're comparing against
   * @param {strictness.Loose|strictness.Strict} strictness how to compare
   * @param {object} references memoized references to objects in the deepEqual hierarchy
   * @returns {boolean}
   */


function compareSets(actual, expected, strictness, references) {
  var looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = actual[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var value = _step4.value;

      if (typeof value === 'object' && value !== null) {
        // non-null object. We need to do our own checking, not use has()
        looseChecks.add(value);
      } else if (!expected.has(value)) {
        // FIXME: has does "same-value-zero" check, which is like Object.is except for -0/+0 being considered equal
        // so may need to special case that here, that'd have to be in an else below (since has will return true here)
        if (strictness === STRICTNESS.Strict) {
          // failed "same-value" match for primitive in strict mode, so fail right away
          return false;
        } // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here
        // add to set of values to check more thoroughly


        looseChecks.add(value);
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // Try to whittle down the loose checks set to be empty...
  // only go through the second Set once!


  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = expected[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var expectedValue = _step5.value;

      // if it's not a non-null object in strict mode, fail!
      // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
      // Note that this shouldn't ever happen since we should be returning false immediately above
      if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {
        return false;
      }

      var found = false;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = looseChecks[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var object = _step6.value;

          if (deepEqual(object, expectedValue, strictness, references)) {
            found = true; // found a match!

            looseChecks.delete(object); // remove from our looseChecks Set since we matched it

            break;
          }
        } // if not found, we failed to match

      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      if (!found) {
        return false;
      }
    } // did we leave un-matched values? if so, fail

  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return looseChecks.size === 0;
}
/**
   * @param {*} actual value we are comparing
   * @param {*} expected values we're comparing against
   * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do
   * @param {object} [references] optional object to keep track of circular references in the hierarchy
   * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth
   * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth
   * @param {number} [references.depth] The current depth of the hierarchy
   * @returns {boolean}
   */


function deepEqual(actual, expected, strictness, references) {
  // if primitives, compare using Object.is
  // This handles: null, undefined, number, string, boolean
  if (isPrimitive(actual) && isPrimitive(expected)) {
    if (strictness === STRICTNESS.Strict) {
      return Object.is(actual, expected);
    } else {
      return actual == expected; // eslint-disable-line eqeqeq
    }
  } // Now we have various objects/functions:
  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays
  // notably, this includes "boxed" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc
  // Type tags of objects should be the same


  var actualTag = Object.prototype.toString.call(actual);
  var expectedTag = Object.prototype.toString.call(expected);

  if (actualTag !== expectedTag) {
    return false;
  } // [[Prototype]] of objects are compared using the Strict Equality Comparison.


  if (strictness === STRICTNESS.Strict) {
    // don't check prototype when doing "loose"
    var actualPrototype = Object.getPrototypeOf(actual);
    var expectedPrototype = Object.getPrototypeOf(expected);

    if (actualPrototype !== expectedPrototype) {
      return false;
    }
  }

  var comparison = COMPARE_TYPE.Object;

  if (util.types.isRegexp(actual)) {
    // RegExp source and flags should match
    if (!util.types.isRegexp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isDate(actual)) {
    // Date's underlying time should match
    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {
      return false;
    } // continue on to check properties...

  } else if (actual instanceof Error) {
    // Error's name and message must match
    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {
      return false;
    } // continue on to check properties...

  } else if (Array.isArray(actual)) {
    // if array lengths differ, quick fail
    if (!Array.isArray(expected) || actual.length !== expected.length) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isBoxedPrimitive(actual)) {
    if (!util.types.isBoxedPrimitive(expected)) {
      return false;
    } // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!


    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {
      return false;
    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {
      return false;
    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {
      return false; // FIXME: Uncomment when we support BigInt cross-platform!
      // } else if (util.types.isBigIntObject(actual)
      // 	&& (!util.types.isBigIntObject(expected)
      // 		|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {
      // 	return false;
    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isSet(actual)) {
    if (!util.types.isSet(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Set; // continue on to check properties...
  } else if (util.types.isMap(actual)) {
    if (!util.types.isMap(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Map; // continue on to check properties...
  } // Now iterate over properties and compare them!


  var actualKeys = Object.keys(actual); // for an array, this will return the indices that have values

  var expectedKeys = Object.keys(expected); // and it just magically works
  // Must have same number of properties

  if (actualKeys.length !== expectedKeys.length) {
    return false;
  } // Are they the same keys? If one is missing, then no, fail right away


  if (!actualKeys.every(function (key) {
    return Object.prototype.hasOwnProperty.call(expected, key);
  })) {
    return false;
  } // Don't check own symbols when doing "loose"


  if (strictness === STRICTNESS.Strict) {
    var actualSymbols = Object.getOwnPropertySymbols(actual);
    var expectedSymbols = Object.getOwnPropertySymbols(expected); // Must have same number of symbols

    if (actualSymbols.length !== expectedSymbols.length) {
      return false;
    }

    if (actualSymbols.length > 0) {
      // Have to filter them down to enumerable symbols!
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = actualSymbols[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var key = _step7.value;
          var actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);
          var expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);

          if (actualIsEnumerable !== expectedIsEnumerable) {
            return false; // they differ on whetehr symbol is enumerable, fail!
          } else if (actualIsEnumerable) {
            // it's enumerable, add to keys to check
            actualKeys.push(key);
            expectedKeys.push(key);
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  } // Avoid circular references!
  // Record map from objects to depth in the hierarchy


  if (references === undefined) {
    references = {
      actual: new Map(),
      expected: new Map(),
      depth: 0 };

  } else {
    // see if we've already recorded these objects.
    // if so, make sure they refer to same depth in object hierarchy
    var memoizedActual = references.actual.get(actual);

    if (memoizedActual !== undefined) {
      var memoizedExpected = references.expected.get(expected);

      if (memoizedExpected !== undefined) {
        return memoizedActual === memoizedExpected;
      }
    }

    references.depth++;
  } // store the object -> depth mapping


  references.actual.set(actual, references.depth);
  references.expected.set(expected, references.depth); // When comparing Maps/Sets, compare elements before custom properties

  var result = true;

  if (comparison === COMPARE_TYPE.Set) {
    result = compareSets(actual, expected, strictness, references);
  } else if (comparison === COMPARE_TYPE.Map) {
    result = compareMaps(actual, expected, strictness, references);
  }

  if (result) {
    // Now loop over keys and compare them to each other!
    for (var _i = 0, _actualKeys = actualKeys; _i < _actualKeys.length; _i++) {
      var _key = _actualKeys[_i];

      if (!deepEqual(actual[_key], expected[_key], strictness, references)) {
        result = false;
        break;
      }
    }
  } // wipe the object to depth mapping for these objects now


  references.actual.delete(actual);
  references.expected.delete(expected);
  return result;
}

assert.deepStrictEqual = function (actual, expected, message) {
  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual' });

  }
};

assert.notDeepStrictEqual = function (actual, expected, message) {
  if (deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual' });

  }
};

assert.deepEqual = function (actual, expected, message) {
  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepEqual' });

  }
};

assert.notDeepEqual = function (actual, expected, message) {
  if (deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepEqual' });

  }
};

assert.fail = function () {
  var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Failed';
  return throwError({
    message });

};

var NO_EXCEPTION = {};

function execute(fn) {
  assertArgumentType(fn, 'fn', 'Function');

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

function isPromiseLike(fn) {
  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';
}

function executePromise(_x) {
  return _executePromise.apply(this, arguments);
}

function _executePromise() {
  _executePromise = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3(fn) {
    var promise, fnType;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            fnType = typeof fn;

            if (!(fnType === 'function')) {
              _context3.next = 7;
              break;
            }

            promise = fn();

            if (isPromiseLike(promise)) {
              _context3.next = 5;
              break;
            }

            throw new TypeError("Expected instanceof Promise to be returned from the \"fn\" function but got ".concat(typeof promise));

          case 5:
            _context3.next = 10;
            break;

          case 7:
            if (isPromiseLike(fn)) {
              _context3.next = 9;
              break;
            }

            throw new TypeError("The \"fn\" argument must be of type Function or Promise. Received type ".concat(fnType));

          case 9:
            promise = fn;

          case 10:
            _context3.prev = 10;
            _context3.next = 13;
            return promise;

          case 13:
            _context3.next = 18;
            break;

          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3["catch"](10);
            return _context3.abrupt("return", _context3.t0);

          case 18:
            return _context3.abrupt("return", NO_EXCEPTION);

          case 19:
          case "end":
            return _context3.stop();}

      }
    }, _callee3, null, [[10, 15]]);
  }));
  return _executePromise.apply(this, arguments);
}

assert.throws = function (fn, error, message) {
  var actual = execute(fn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'throws' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.rejects =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(asyncFn, error, message) {
    var actual;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return executePromise(asyncFn);

          case 2:
            actual = _context.sent;

            if (!(actual === NO_EXCEPTION)) {
              _context.next = 6;
              break;
            }

            // FIXME: append message if not null
            throwError({
              actual: undefined,
              expected: error,
              message: 'Missing expected exception.',
              operator: 'rejects' });

            return _context.abrupt("return");

          case 6:
            if (error) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return");

          case 8:
            if (checkError(actual, error, message)) {
              _context.next = 10;
              break;
            }

            throw actual;

          case 10:
          case "end":
            return _context.stop();}

      }
    }, _callee);
  }));

  return function (_x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

assert.doesNotThrow = function (fn, error, message) {
  var actual = execute(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: "Got unwanted exception".concat(message ? ': ' + message : '.') });

    return;
  } // doesn't match, re-throw


  throw actual;
};

assert.doesNotReject =
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(fn, error, message) {
    var actual;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return executePromise(fn);

          case 2:
            actual = _context2.sent;

            if (!(actual === NO_EXCEPTION)) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return");

          case 5:
            if (error) {
              _context2.next = 7;
              break;
            }

            throw actual;

          case 7:
            if (!checkError(actual, error)) {
              _context2.next = 10;
              break;
            }

            throwError({
              actual,
              expected: error,
              operator: 'doesNotThrow',
              message: "Got unwanted exception".concat(message ? ': ' + message : '.') });

            return _context2.abrupt("return");

          case 10:
            throw actual;

          case 11:
          case "end":
            return _context2.stop();}

      }
    }, _callee2);
  }));

  return function (_x5, _x6, _x7) {
    return _ref2.apply(this, arguments);
  };
}();
/**
      * @param {Error} actual the actual Error generated by the wrapped function/block
      * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error
      * @param {string} [message] custom message to append
      * @returns {boolean} true if the Error matches the expected value/object
      */


function checkError(actual, expected, message) {
  // What we do here depends on what `expected` is:
  // function - call it to validate
  // object - test properties against actual
  // Regexp - test against actual.toString()
  // Error type - check type matches
  // Error instance - compare properties
  if (typeof expected === 'object') {
    if (util.types.isRegexp(expected)) {
      return expected.test(actual); // does the error match the RegExp expression? if so, pass
    } // Test properties (`expected` is either a generic Object or an Error instance)


    var keys = Object.keys(expected); // If we're testing against an instance of an Error, we need to hack in name/message properties.

    if (expected instanceof Error) {
      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error
    }

    for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
      var key = _keys[_i2];

      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {
        if (!message) {
          // generate a meaningful message! Cheat by treating like equality check of values
          // then steal the message it generated
          try {
            throwError({
              actual: actual[key],
              expected: expected[key],
              operator: 'deepStrictEqual' });

          } catch (err) {
            message = err.message;
          }
        }

        throwError({
          actual,
          expected,
          message,
          operator: 'throws' });

        return false;
      }
    }

    return true; // They all matched, pass!
  } else if (typeof expected === 'function') {
    // if `expected` is a "type" and actual is an instance of that type, then pass
    if (expected.prototype != null && actual instanceof expected) {
      // eslint-disable-line no-eq-null,eqeqeq
      return true;
    } // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail


    if (Object.prototype.isPrototypeOf.call(Error, expected)) {
      return false;
    } // ok, let's assume what's left is that `expected` was a validation function,
    // so call it with empty `this` and single argument of the actual error we received


    return expected.call({}, actual);
  }

  return false;
}

assert.ifError = function (value) {
  if (value === null || value === undefined) {
    return;
  }

  throwError({
    actual: value,
    expected: null,
    message: "ifError got unwanted exception: ".concat(value),
    operator: 'ifError' });

}; // Create "strict" copy which overrides "loose" methods to call strict equivalents


assert.strict = function (value, message) {
  return assert.ok(value, message);
}; // "Copy" methods from assert to assert.strict!


Object.assign(assert.strict, assert); // Override the "loose" methods to point to the strict ones

assert.strict.deepEqual = assert.deepStrictEqual;
assert.strict.notDeepEqual = assert.notDeepStrictEqual;
assert.strict.equal = assert.strictEqual;
assert.strict.notEqual = assert.notStrictEqual; // hang strict off itself

assert.strict.strict = assert.strict;

var kNodeModulesRE = /^(.*)[\\/]node_modules[\\/]/;
var getStructuredStack;

var StackTraceError =
/*#__PURE__*/
function (_Error) {
  _inherits(StackTraceError, _Error);

  function StackTraceError() {
    _classCallCheck(this, StackTraceError);

    return _possibleConstructorReturn(this, _getPrototypeOf(StackTraceError).apply(this, arguments));
  }

  return StackTraceError;
}(_wrapNativeSuper(Error));

StackTraceError.prepareStackTrace = function (err, trace) {
  return trace;
};

StackTraceError.stackTraceLimit = Infinity;
function isInsideNodeModules() {
  if (getStructuredStack === undefined) {
    getStructuredStack = function getStructuredStack() {
      return new StackTraceError().stack;
    };
  }

  var stack = getStructuredStack(); // stack is only an array on v8, try to convert manually if string

  if (typeof stack === 'string') {
    var stackFrames = [];
    var lines = stack.split(/\n/);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var line = _step.value;
        var lineInfo = line.match(/(.*)@(.*):(\d+):(\d+)/);

        if (lineInfo) {
          (function () {
            var filename = lineInfo[2].replace('file://', '');
            stackFrames.push({
              getFileName: function getFileName() {
                return filename;
              } });

          })();
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    stack = stackFrames;
  } // Iterate over all stack frames and look for the first one not coming
  // from inside Node.js itself:


  if (Array.isArray(stack)) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = stack[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var frame = _step2.value;
        var filename = frame.getFileName(); // If a filename does not start with / or contain \,
        // it's likely from Node.js core.

        if (!/^\/|\\/.test(filename)) {
          continue;
        }

        return kNodeModulesRE.test(filename);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  return false;
}

var TI_CODEC_MAP = new Map();
TI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII); // We have no equivalents of base64 or hex, so we convert them internally here

var VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le']; // Used to cheat for read/writes of doubles

var doubleArray = new Float64Array(1);
var uint8DoubleArray = new Uint8Array(doubleArray.buffer); // Used to cheat to read/write floats

var floatArray = new Float32Array(1);
var uint8FloatArray = new Uint8Array(floatArray.buffer);

var Buffer =
/*#__PURE__*/
function () {
  /**
              * Constructs a new buffer.
              *
              * Primarily used internally in this module together with `newBuffer` to
              * create a new Buffer instance wrapping a Ti.Buffer.
              *
              * Also supports the deprecated Buffer() constructors which are safe
              * to use outside of this module.
              *
              * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg
              * @param {string|integer} encodingOrOffset
              * @param {integer} length
              */
  function Buffer(arg, encodingOrOffset, length) {
    _classCallCheck(this, Buffer);

    if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {
      showFlaggedDeprecation();

      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError("The \"string\" argument must be of type \"string\". Received type ".concat(typeof arg));
        }

        return Buffer.alloc(arg);
      }

      return Buffer.from(arg, encodingOrOffset, length);
    }

    var tiBuffer = arg;
    var start = encodingOrOffset;
    this._tiBuffer = tiBuffer;

    if (start === undefined) {
      start = 0;
    }

    this.byteOffset = start;

    if (length === undefined) {
      this.length = tiBuffer.length - this.byteOffset;
    } else {
      this.length = length;
    }

    this._isBuffer = true; // FIXME: Support .buffer property that holds an ArrayBuffer!
  }
  /**
     * 0 is returned if target is the same as buf
     * 1 is returned if target should come before buf when sorted.
     * -1 is returned if target should come after buf when sorted.
     * @param {Buffer} target Buffer to compare against
     * @param {integer} [targetStart=0] index to start in target
     * @param {integer} [targetEnd=target.length] index to end in target
     * @param {integer} [sourceStart=0] index to start in this Buffer
     * @param {integer} [sourceEnd=this.length] index to end in this Buffer
     * @returns {integer}
     */


  _createClass(Buffer, [{
    key: "compare",
    value: function compare(target, targetStart, targetEnd, sourceStart, sourceEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type ".concat(typeof buf1));
      }

      if (targetStart === undefined) {
        targetStart = 0;
      }

      if (sourceStart === undefined) {
        sourceStart = 0;
      }

      if (targetEnd === undefined) {
        targetEnd = target.length;
      }

      if (sourceEnd === undefined) {
        sourceEnd = this.length;
      } // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength


      if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {
        throw new RangeError('Index out of range'); // FIXME: set "code" to ERR_INDEX_OUT_OF_RANGE
      } // Use slices to make the loop easier


      var source = this.slice(sourceStart, sourceEnd);
      var sourceLength = source.length;
      var dest = target.slice(targetStart, targetEnd);
      var destLength = dest.length;
      var length = Math.min(sourceLength, destLength);

      for (var i = 0; i < length; i++) {
        var targetValue = getAdjustedIndex(dest, i);
        var sourceValue = getAdjustedIndex(source, i);

        if (targetValue !== sourceValue) {
          // No match! Return 1 or -1 based on what is greater!
          if (sourceValue < targetValue) {
            return -1;
          }

          return 1;
        }
      } // sort based on length!


      if (sourceLength < destLength) {
        return -1;
      }

      if (sourceLength > destLength) {
        return 1;
      }

      return 0;
    }
    /**
       * Copies from this to target
       * @param {Buffer} target destination we're copying into
       * @param {integer} [targetStart=0] start index to copy into in destination Buffer
       * @param {integer} [sourceStart=0] start index to copy from within `this`
       * @param {integer} [sourceEnd=this.length] end index to copy from within `this`
       * @returns {integer} number of bytes copied
       */ },

  {
    key: "copy",
    value: function copy(target, targetStart, sourceStart, sourceEnd) {
      if (targetStart === undefined) {
        targetStart = 0;
      }

      if (sourceStart === undefined) {
        sourceStart = 0;
      }

      if (sourceEnd === undefined) {
        sourceEnd = this.length;
      }

      if (sourceStart === sourceEnd) {
        return 0;
      }

      if (target.length === 0 || this.length === 0) {
        return 0;
      } // TODO: check for out of bounds?


      var length = sourceEnd - sourceStart; // Cap length to remaining bytes in target!

      var remaining = target.length - targetStart;

      if (length > remaining) {
        length = remaining;
      } // TODO: handle overlap when target === this!
      // TODO: Do we need to take target or this.byteOffset into account here?


      target._tiBuffer.copy(this._tiBuffer, targetStart, sourceStart, length);

      return length;
    }
    /**
       * Creates and returns an iterator of [index, byte] pairs from the contents of buf.
       * @returns {Iterator}
       */ },

  {
    key: "entries",
    value: function entries() {
      var buffer = this;
      var nextIndex = 0;
      var end = this.length;
      var entryIterator = {
        next: function next() {
          if (nextIndex < end) {
            var result = {
              value: [nextIndex, getAdjustedIndex(buffer, nextIndex)],
              done: false };

            nextIndex++;
            return result;
          }

          return {
            value: undefined,
            done: true };

        },
        [Symbol.iterator]: function () {
          return this;
        } };

      return entryIterator;
    } },
  {
    key: "equals",
    value: function equals(otherBuffer) {
      if (!Buffer.isBuffer(otherBuffer)) {
        throw new TypeError('argument must be a Buffer');
      }

      if (otherBuffer === this) {
        return true;
      }

      return this.compare(otherBuffer) === 0;
    }
    /**
       * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.
       * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`
       * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default
       * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.
       * @returns {this}
       */ },

  {
    key: "fill",
    value: function fill(value, offset, end, encoding) {
      var offsetType = typeof offset;

      if (offsetType === 'undefined') {
        // value supplied
        offset = 0;
        end = this.length;
        encoding = 'utf8';
      } else if (offsetType === 'string') {
        // value, encoding supplied
        encoding = offset;
        offset = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        // value, offset, encoding supplied
        encoding = end;
        end = this.length;
      }

      var valueType = typeof value;

      if (valueType === 'string') {
        var bufToFillWith = Buffer.from(value, encoding);
        var fillBufLength = bufToFillWith.length;

        if (fillBufLength === 0) {
          throw new Error('no valid fill data');
        } // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);


        if (fillBufLength === 1) {
          this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);

          return this;
        } // multiple byte fill!


        var length = end - offset;

        for (var i = 0; i < length; i++) {
          // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
          var fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
          this._tiBuffer[i + offset] = fillChar;
        }

        return this;
      } // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();


      this._tiBuffer.fill(value, offset, end);

      return this;
    } },
  {
    key: "includes",
    value: function includes(value, byteOffset, encoding) {
      return this.indexOf(value, byteOffset, encoding) !== -1;
    }
    /**
       * @param {string|Buffer|integer} value What to search for
       * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf
       * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf
       * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.
       */ },

  {
    key: "indexOf",
    value: function indexOf(value, byteOffset, encoding) {
      if (this.length === 0) {
        // empty buffer? can't find anything!
        return -1;
      } // if byteOffset is undefined, make it 0


      if (typeof byteOffset === 'undefined') {
        byteOffset = 0;
      } else if (typeof byteOffset === 'string') {
        // if it's a string, that's actually encoding
        encoding = byteOffset;
        byteOffset = 0;
      } // if we don't have an encoding yet, use utf8


      if (typeof encoding !== 'string') {
        encoding = 'utf8';
      }

      if (byteOffset < 0) {
        // convert negative indices
        byteOffset = this.length + byteOffset;

        if (byteOffset < 0) {
          // still negative? start at 0
          byteOffset = 0;
        }
      } else if (byteOffset >= this.length) {
        return -1; // can't find past end of buffer!
      }

      if (typeof value === 'number') {
        value &= 0xFF; // clamp to 255
        // This is a simpler case, we have a single byte we need to search for
        // so just loop through and try to find it

        return _indexOf(this, value, byteOffset);
      } // coerce a string to a Buffer


      if (typeof value === 'string') {
        value = Buffer.from(value, encoding);
      } // value is now a Buffer...


      var matchLength = value.length;

      if (matchLength === 0) {
        return -1; // never find empty value!
      }

      if (matchLength === 1) {
        // simple case, match one byte!
        return _indexOf(this, value[0], byteOffset);
      }

      var currentIndex = byteOffset;
      var thisLength = this.length;

      if (matchLength > thisLength) {
        return -1; // can't match if the value is longer than this Buffer!
      } // FIXME: Can we rewrite this in a less funky way?
      // FIXME: Can stop earlier based on matchLength!


      firstMatch: while (currentIndex < thisLength) {
        // eslint-disable-line no-labels
        // match first byte!
        var firstByteMatch = _indexOf(this, value[0], currentIndex);

        if (firstByteMatch === -1) {
          // couldn't even match the very first byte, so no match overall!
          return -1;
        } // ok, we found the first byte, now we need to see if the next consecutive bytes match!


        for (var x = 1; x < matchLength; x++) {
          if (firstByteMatch + x >= thisLength) {
            currentIndex = firstByteMatch + 1; // move past our first match

            continue firstMatch; // eslint-disable-line no-labels
          }

          if (this[firstByteMatch + x] !== value[x]) {
            // didn't match!
            currentIndex = firstByteMatch + 1; // move past our first match

            continue firstMatch; // eslint-disable-line no-labels
          }
        }

        return firstByteMatch; // the rest matched, hurray!
      }

      return -1;
    } },
  {
    key: "keys",
    value: function keys() {
      var nextIndex = 0;
      var end = this.length;
      var myIterator = {
        next: function next() {
          if (nextIndex < end) {
            var result = {
              value: nextIndex,
              done: false };

            nextIndex++;
            return result;
          }

          return {
            value: undefined,
            done: true };

        },
        [Symbol.iterator]: function () {
          return this;
        } };

      return myIterator;
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
       * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
       */ },

  {
    key: "readDoubleBE",
    value: function readDoubleBE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
      // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
      // FIXME: This assumes LE system byteOrder

      uint8DoubleArray[7] = this[offset++];
      uint8DoubleArray[6] = this[offset++];
      uint8DoubleArray[5] = this[offset++];
      uint8DoubleArray[4] = this[offset++];
      uint8DoubleArray[3] = this[offset++];
      uint8DoubleArray[2] = this[offset++];
      uint8DoubleArray[1] = this[offset++];
      uint8DoubleArray[0] = this[offset++];
      return doubleArray[0];
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
       * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
       */ },

  {
    key: "readDoubleLE",
    value: function readDoubleLE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
      // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
      // FIXME: This assumes LE system byteOrder

      uint8DoubleArray[0] = this[offset++];
      uint8DoubleArray[1] = this[offset++];
      uint8DoubleArray[2] = this[offset++];
      uint8DoubleArray[3] = this[offset++];
      uint8DoubleArray[4] = this[offset++];
      uint8DoubleArray[5] = this[offset++];
      uint8DoubleArray[6] = this[offset++];
      uint8DoubleArray[7] = this[offset++];
      return doubleArray[0];
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
       * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
       */ },

  {
    key: "readFloatBE",
    value: function readFloatBE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
      // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
      // FIXME: This assumes LE system byteOrder

      uint8FloatArray[3] = this[offset++];
      uint8FloatArray[2] = this[offset++];
      uint8FloatArray[1] = this[offset++];
      uint8FloatArray[0] = this[offset++];
      return floatArray[0];
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
       * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
       */ },

  {
    key: "readFloatLE",
    value: function readFloatLE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
      // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
      // FIXME: This assumes LE system byteOrder

      uint8FloatArray[0] = this[offset++];
      uint8FloatArray[1] = this[offset++];
      uint8FloatArray[2] = this[offset++];
      uint8FloatArray[3] = this[offset++];
      return floatArray[0];
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
       * @returns {integer}
       */ },

  {
    key: "readInt8",
    value: function readInt8() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var unsignedValue = this.readUInt8(offset);
      return unsignedToSigned(unsignedValue, 1);
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "readInt16BE",
    value: function readInt16BE(offset) {
      var unsignedValue = this.readUInt16BE(offset);
      return unsignedToSigned(unsignedValue, 2);
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "readInt16LE",
    value: function readInt16LE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var unsignedValue = this.readUInt16LE(offset);
      return unsignedToSigned(unsignedValue, 2);
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "readInt32BE",
    value: function readInt32BE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var unsignedValue = this.readUInt32BE(offset);
      return unsignedToSigned(unsignedValue, 4);
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "readInt32LE",
    value: function readInt32LE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var unsignedValue = this.readUInt32LE(offset);
      return unsignedToSigned(unsignedValue, 4);
    }
    /**
       * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
       * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "readIntBE",
    value: function readIntBE(offset, byteLength) {
      var unsignedValue = this.readUIntBE(offset, byteLength);
      return unsignedToSigned(unsignedValue, byteLength);
    }
    /**
       * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
       * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "readIntLE",
    value: function readIntLE(offset, byteLength) {
      var unsignedValue = this.readUIntLE(offset, byteLength);
      return unsignedToSigned(unsignedValue, byteLength);
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
       * @returns {integer}
       */ },

  {
    key: "readUInt8",
    value: function readUInt8() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 1);
      return this[offset];
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "readUInt16BE",
    value: function readUInt16BE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 2); // first byte shifted and OR'd with second byte

      return this[offset] << 8 | this[offset + 1];
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "readUInt16LE",
    value: function readUInt16LE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 2); // first byte OR'd with second byte shifted

      return this[offset] | this[offset + 1] << 8;
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "readUInt32BE",
    value: function readUInt32BE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 4);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]); // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the "sign bit"
      // (because bit-wise operators assume a 32-bit number)
    }
    /**
       * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "readUInt32LE",
    value: function readUInt32LE() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      checkOffset(this, offset, 4);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000; // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the "sign bit"
    }
    /**
       * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "readUIntBE",
    value: function readUIntBE(offset, byteLength) {
      if (byteLength <= 0 || byteLength > 6) {
        throw new RangeError('Index out of range');
      }

      checkOffset(this, offset, byteLength);
      var result = 0;
      var multiplier = 1; // we use a multipler for each byte
      // we're doing the same loop as #readUIntLE, just backwards!

      for (var i = byteLength - 1; i >= 0; i--) {
        result += getAdjustedIndex(this, offset + i) * multiplier;
        multiplier *= 0x100; // move multiplier to next byte
      }

      return result;
    }
    /**
       * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "readUIntLE",
    value: function readUIntLE(offset, byteLength) {
      if (byteLength <= 0 || byteLength > 6) {
        throw new RangeError('Index out of range');
      }

      checkOffset(this, offset, byteLength);
      var result = 0;
      var multiplier = 1; // we use a multipler for each byte

      for (var i = 0; i < byteLength; i++) {
        result += getAdjustedIndex(this, offset + i) * multiplier;
        multiplier *= 0x100; // move multiplier to next byte
      }

      return result;
    }
    /**
       * @param {integer} [start=0] Where the new `Buffer` will start.
       * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
       * @returns {Buffer}
       */ },

  {
    key: "slice",
    value: function slice(start, end) {
      var thisLength = this.length;

      if (typeof start === 'undefined') {
        start = 0;
      } else if (start < 0) {
        start = thisLength + start;

        if (start < 0) {
          // if this is still negative, use 0 (that matches Node)
          start = 0;
        }
      }

      if (typeof end === 'undefined') {
        end = thisLength;
      } else if (end < 0) {
        end = thisLength + end;
      } // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.


      if (end > thisLength) {
        end = thisLength;
      } // What if end is less than start?


      var length = end - start;

      if (length <= 0) {
        length = 0; // return empty view of Buffer! retain byte offset, set length to 0
      } // Wrap the same Ti.Buffer object but specify the start/end to "crop" with


      return newBuffer(this._tiBuffer, this.byteOffset + start, length);
    }
    /**
       * @param {integer} [start=0] Where the new `Buffer` will start.
       * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
       * @returns {Buffer}
       */ },

  {
    key: "subarray",
    value: function subarray(start, end) {
      return this.slice(start, end);
    }
    /**
       * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.
       * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.
       * @returns {Buffer}
       */ },

  {
    key: "swap16",
    value: function swap16() {
      var length = this.length;

      if (length % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < length; i += 2) {
        var first = getAdjustedIndex(this, i);
        var second = getAdjustedIndex(this, i + 1);
        setAdjustedIndex(this, i, second);
        setAdjustedIndex(this, i + 1, first);
      }

      return this;
    }
    /**
       * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.
       * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.
       * @returns {Buffer}
       */ },

  {
    key: "swap32",
    value: function swap32() {
      var length = this.length;

      if (length % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < length; i += 4) {
        var first = getAdjustedIndex(this, i);
        var second = getAdjustedIndex(this, i + 1);
        var third = getAdjustedIndex(this, i + 2);
        var fourth = getAdjustedIndex(this, i + 3);
        setAdjustedIndex(this, i, fourth);
        setAdjustedIndex(this, i + 1, third);
        setAdjustedIndex(this, i + 2, second);
        setAdjustedIndex(this, i + 3, first);
      }

      return this;
    }
    /**
       * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.
       * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.
       * @returns {Buffer}
       */ },

  {
    key: "swap64",
    value: function swap64() {
      var length = this.length;

      if (length % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < length; i += 8) {
        var first = getAdjustedIndex(this, i);
        var second = getAdjustedIndex(this, i + 1);
        var third = getAdjustedIndex(this, i + 2);
        var fourth = getAdjustedIndex(this, i + 3);
        var fifth = getAdjustedIndex(this, i + 4);
        var sixth = getAdjustedIndex(this, i + 5);
        var seventh = getAdjustedIndex(this, i + 6);
        var eighth = getAdjustedIndex(this, i + 7);
        setAdjustedIndex(this, i, eighth);
        setAdjustedIndex(this, i + 1, seventh);
        setAdjustedIndex(this, i + 2, sixth);
        setAdjustedIndex(this, i + 3, fifth);
        setAdjustedIndex(this, i + 4, fourth);
        setAdjustedIndex(this, i + 5, third);
        setAdjustedIndex(this, i + 6, second);
        setAdjustedIndex(this, i + 7, first);
      }

      return this;
    }
    /**
       * @returns {object}
       */ },

  {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: 'Buffer',
        // Take advantage of slice working on "Array-like" objects (juts like `arguments`)
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
        data: [].slice.call(this) };

    }
    /**
       * @param {string} [encoding='utf8'] The character encoding to use
       * @param {integer} [start=0] The byte offset to start decoding at
       * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default
       * @returns {string}
       */ },

  {
    key: "toString",
    value: function toString(encoding, start, end) {
      // fast case of no args
      if (arguments.length === 0) {
        return this._tiBuffer.toString();
      }

      var length = this.length;

      if (start >= length) {
        return ''; // start is past end of buffer, return empty string
      }

      if (start < 0 || typeof start !== 'number') {
        start = 0;
      }

      if (end > length || typeof end !== 'number') {
        // no end specified, or past end of buffer, use length of buffer
        end = length;
      } // else keep end as passed in


      if (end <= start) {
        return ''; // if end is before start return empty string
      } // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?


      if (start !== 0 || end !== length) {
        return this.slice(start, end).toString(encoding);
      } // base case, start is 0, end is length


      if (encoding === undefined) {
        encoding = 'utf8';
      } else {
        encoding = encoding.toLowerCase(); // Throw if bad encoding!

        if (!Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: ".concat(encoding));
        }
      }

      if (encoding === 'utf8' || encoding === 'utf-8') {
        // if this is the original underlying buffer just return it's toString() value
        if (this.byteOffset === 0 && this.length === this._tiBuffer.length) {
          return this._tiBuffer.toString(); // we return utf-8 by default natively
        } // if we're offset or cropping in nay way, clone the range and return that buffer's toString()


        return this._tiBuffer.clone(this.byteOffset, this.length).toString();
      }

      if (encoding === 'base64') {
        var blob; // if this is the original underlying buffer just return it's toString() value

        if (this.byteOffset === 0 && this.length === this._tiBuffer.length) {
          blob = Ti.Utils.base64encode(this._tiBuffer.toBlob());
        } else {
          // if we're offset or cropping in any way, clone the range and return that buffer's toString()
          blob = Ti.Utils.base64encode(this._tiBuffer.clone(this.byteOffset, this.length).toBlob());
        }

        return blob.toString();
      }

      if (encoding === 'hex') {
        var hexStr = '';

        for (var i = 0; i < length; i++) {
          // each one is a "byte"
          var hex = (getAdjustedIndex(this, i) & 0xff).toString(16);
          hex = hex.length === 1 ? '0' + hex : hex;
          hexStr += hex;
        }

        return hexStr;
      }

      if (encoding === 'latin1' || encoding === 'binary') {
        var latin1String = '';

        for (var _i = 0; _i < length; _i++) {
          // each one is a "byte"
          latin1String += String.fromCharCode(getAdjustedIndex(this, _i));
        }

        return latin1String;
      }

      if (encoding === 'ascii') {
        var ascii = '';

        for (var _i2 = 0; _i2 < length; _i2++) {
          // we store bytes (8-bit), but ascii is 7-bit. Node "masks" the last bit off, so let's do the same
          ascii += String.fromCharCode(getAdjustedIndex(this, _i2) & 0x7F);
        }

        return ascii;
      } // UCS2/UTF16


      return bufferToUTF16String(this._tiBuffer, this.byteOffset, this.length);
    }
    /**
       * Creates and returns an iterator for buf values (bytes)
       * @returns {Iterator}
       */ },

  {
    key: "values",
    value: function values() {
      var buffer = this;
      var nextIndex = 0;
      var end = this.length;
      var myIterator = {
        next: function next() {
          if (nextIndex < end) {
            var result = {
              value: getAdjustedIndex(buffer, nextIndex),
              done: false };

            nextIndex++;
            return result;
          }

          return {
            value: undefined,
            done: true };

        },
        [Symbol.iterator]: function () {
          return this;
        } };

      return myIterator;
    }
    /**
       * Called when buffer is used in a for..of loop. Delegates to #values()
       * @returns {Iterator}
       */ },

  {
    key: Symbol.iterator,
    value: function value() {
      return this.values();
    }
    /**
       * Writes string to buf at offset according to the character encoding in encoding.
       * The length parameter is the number of bytes to write. If buf did not contain enough space to
       * fit the entire string, only part of string will be written. However, partially encoded
       * characters will not be written.
       * @param {string} string String to write to `buf`.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write string
       * @param {integer} [length=buf.length - offset] Number of bytes to write
       * @param {string} [encoding='utf8'] The character encoding of string
       * @returns {integer}
       */ },

  {
    key: "write",
    value: function write(string, offset, length, encoding) {
      if (typeof offset === 'string') {
        encoding = offset;
        offset = 0;
        length = this.length;
      } else if (typeof length === 'string') {
        encoding = length;
        length = this.length - offset;
      } else {
        // we cap `length` at the length of our buffer
        var remaining = this.length - offset;

        if (length > remaining) {
          length = remaining;
        }
      }

      encoding = encoding || 'utf8'; // so we need to convert `remaining` bytes of our string into a byte array/buffer

      var src = Buffer.from(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?
      // then stick that into our buffer starting at `offset`!

      return copyBuffer(src._tiBuffer, this._tiBuffer, offset, length);
    } },
  {
    key: "writeDoubleBE",
    value: function writeDoubleBE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 8);
      doubleArray[0] = value;
      setAdjustedIndex(this, offset++, uint8DoubleArray[7]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[6]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[5]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[4]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[3]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[2]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[1]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[0]);
      return offset; // at this point, we should have already added 8 to offset
    } },
  {
    key: "writeDoubleLE",
    value: function writeDoubleLE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 8);
      doubleArray[0] = value;
      setAdjustedIndex(this, offset++, uint8DoubleArray[0]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[1]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[2]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[3]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[4]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[5]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[6]);
      setAdjustedIndex(this, offset++, uint8DoubleArray[7]);
      return offset; // at this point, we should have already added 8 to offset
    } },
  {
    key: "writeFloatBE",
    value: function writeFloatBE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 4);
      floatArray[0] = value;
      setAdjustedIndex(this, offset++, uint8FloatArray[3]);
      setAdjustedIndex(this, offset++, uint8FloatArray[2]);
      setAdjustedIndex(this, offset++, uint8FloatArray[1]);
      setAdjustedIndex(this, offset++, uint8FloatArray[0]);
      return offset; // at this point, we should have already added 4 to offset
    } },
  {
    key: "writeFloatLE",
    value: function writeFloatLE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 4);
      floatArray[0] = value;
      setAdjustedIndex(this, offset++, uint8FloatArray[0]);
      setAdjustedIndex(this, offset++, uint8FloatArray[1]);
      setAdjustedIndex(this, offset++, uint8FloatArray[2]);
      setAdjustedIndex(this, offset++, uint8FloatArray[3]);
      return offset; // at this point, we should have already added 4 to offset
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
       * @returns {integer}
       */ },

  {
    key: "writeInt8",
    value: function writeInt8(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 1);
      checkValue(value, -128, 127);

      if (value >= 0) {
        // just write it normally
        setAdjustedIndex(this, offset, value);
      } else {
        // convert from signed to 2's complement bits
        setAdjustedIndex(this, offset, 0xFF + value + 1); // max value, plus the negative number, add one
      }

      return offset + 1;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "writeInt16BE",
    value: function writeInt16BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 2);
      checkValue(value, -32768, 32767);
      setAdjustedIndex(this, offset, value >>> 8); // just shift over a byte

      setAdjustedIndex(this, offset + 1, value & 0xFF); // mask to first byte

      return offset + 2;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "writeInt16LE",
    value: function writeInt16LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 2);
      checkValue(value, -32768, 32767);
      setAdjustedIndex(this, offset, value & 0xFF);
      setAdjustedIndex(this, offset + 1, value >>> 8);
      return offset + 2;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "writeInt32BE",
    value: function writeInt32BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 4);
      checkValue(value, -2147483648, 2147483647);
      setAdjustedIndex(this, offset, value >>> 24);
      setAdjustedIndex(this, offset + 1, value >>> 16);
      setAdjustedIndex(this, offset + 2, value >>> 8);
      setAdjustedIndex(this, offset + 3, value & 0xFF);
      return offset + 4;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "writeInt32LE",
    value: function writeInt32LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 4);
      checkValue(value, -2147483648, 2147483647);
      setAdjustedIndex(this, offset, value & 0xFF);
      setAdjustedIndex(this, offset + 1, value >>> 8);
      setAdjustedIndex(this, offset + 2, value >>> 16);
      setAdjustedIndex(this, offset + 3, value >>> 24);
      return offset + 4;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "writeIntBE",
    value: function writeIntBE(value, offset, byteLength) {
      if (byteLength <= 0 || byteLength > 6) {
        throw new RangeError('Index out of range');
      }

      checkOffset(this, offset, byteLength);
      var minMaxBase = Math.pow(2, 8 * byteLength - 1);
      checkValue(value, -minMaxBase, minMaxBase - 1);

      if (value < 0) {
        value = minMaxBase * 2 + value;
      }

      var multiplier = 1;

      for (var i = byteLength - 1; i >= 0; i--) {
        var byteValue = value / multiplier & 0xFF;
        setAdjustedIndex(this, offset + i, byteValue);
        multiplier *= 0x100;
      }

      return offset + byteLength;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "writeIntLE",
    value: function writeIntLE(value, offset, byteLength) {
      if (byteLength <= 0 || byteLength > 6) {
        throw new RangeError('Index out of range');
      }

      checkOffset(this, offset, byteLength);
      var minMaxBase = Math.pow(2, 8 * byteLength - 1);
      checkValue(value, -minMaxBase, minMaxBase - 1);

      if (value < 0) {
        value = minMaxBase * 2 + value;
      }

      var multiplier = 1;

      for (var i = 0; i < byteLength; i++) {
        var byteValue = value / multiplier & 0xFF;
        setAdjustedIndex(this, offset + i, byteValue);
        multiplier *= 0X100;
      }

      return offset + byteLength;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
       * @returns {integer}
       */ },

  {
    key: "writeUInt8",
    value: function writeUInt8(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 1);
      checkValue(value, 0, 255);
      setAdjustedIndex(this, offset, value);
      return offset + 1;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "writeUInt16BE",
    value: function writeUInt16BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 2);
      checkValue(value, 0, 65535);
      setAdjustedIndex(this, offset, value >>> 8);
      setAdjustedIndex(this, offset + 1, value & 0xff);
      return offset + 2;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
       * @returns {integer}
       */ },

  {
    key: "writeUInt16LE",
    value: function writeUInt16LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 2);
      checkValue(value, 0, 65535);
      setAdjustedIndex(this, offset, value & 0xff);
      setAdjustedIndex(this, offset + 1, value >>> 8);
      return offset + 2;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "writeUInt32BE",
    value: function writeUInt32BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 4);
      checkValue(value, 0, 4294967295);
      setAdjustedIndex(this, offset, value >>> 24);
      setAdjustedIndex(this, offset + 1, value >>> 16);
      setAdjustedIndex(this, offset + 2, value >>> 8);
      setAdjustedIndex(this, offset + 3, value & 0xff);
      return offset + 4;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
       * @returns {integer}
       */ },

  {
    key: "writeUInt32LE",
    value: function writeUInt32LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      checkOffset(this, offset, 4);
      checkValue(value, 0, 4294967295);
      setAdjustedIndex(this, offset, value & 0xff);
      setAdjustedIndex(this, offset + 1, value >>> 8);
      setAdjustedIndex(this, offset + 2, value >>> 16);
      setAdjustedIndex(this, offset + 3, value >>> 24);
      return offset + 4;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "writeUIntBE",
    value: function writeUIntBE(value, offset, byteLength) {
      if (byteLength <= 0 || byteLength > 6) {
        throw new RangeError('Index out of range');
      }

      checkOffset(this, offset, byteLength);
      checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
      var multiplier = 1;

      for (var i = byteLength - 1; i >= 0; i--) {
        var byteValue = value / multiplier & 0xFF;
        setAdjustedIndex(this, offset + i, byteValue);
        multiplier *= 0X100;
      }

      return offset + byteLength;
    }
    /**
       * @param {integer} value Number to be written to buf.
       * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
       * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
       * @returns {integer}
       */ },

  {
    key: "writeUIntLE",
    value: function writeUIntLE(value, offset, byteLength) {
      if (byteLength <= 0 || byteLength > 6) {
        throw new RangeError('Index out of range');
      }

      checkOffset(this, offset, byteLength);
      checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
      var multiplier = 1;

      for (var i = 0; i < byteLength; i++) {
        var byteValue = value / multiplier & 0xFF;
        setAdjustedIndex(this, offset + i, byteValue);
        multiplier *= 0X100;
      }

      return offset + byteLength;
    } // TODO: Implement remaining instance methods:
    // buf.lastIndexOf(value[, byteOffset][, encoding])
    // buf.readBigInt64BE([offset])
    // buf.readBigInt64LE([offset])
    // buf.readBigUInt64BE([offset])
    // buf.readBigUInt64LE([offset])
    // buf.writeBigInt64BE(value[, offset])
    // buf.writeBigInt64LE(value[, offset])
    // buf.writeBigUInt64BE(value[, offset])
    // buf.writeBigUInt64LE(value[, offset])
  }],
  [{
    key: "allocUnsafe",
    value: function allocUnsafe(length) {
      return newBuffer(Ti.createBuffer({
        length }));

    } },
  {
    key: "allocUnsafeSlow",
    value: function allocUnsafeSlow(length) {
      return Buffer.allocUnsafe(length);
    } },
  {
    key: "alloc",
    value: function alloc(length) {
      var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';
      var buf = Buffer.allocUnsafe(length);
      buf.fill(fill, encoding);
      return buf;
    }
    /**
       * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string
       * @param {string} [encoding='utf8'] encoding whose byte length we need to grab
       * @returns {integer}
       */ },

  {
    key: "byteLength",
    value: function byteLength(string) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';

      if (typeof string !== 'string') {
        if (Buffer.isBuffer(string)) {
          return string.length; // return Buffer's length
        }

        return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView
      }

      var length = string.length;

      switch (encoding.toLowerCase()) {
        case 'utf8':
        case 'utf-8':
          return utf8ByteLength(string);

        case 'latin1':
        case 'binary':
        case 'ascii':
          return length;

        case 'ucs-2':
        case 'ucs2':
        case 'utf16le':
        case 'utf16-le':
          return 2 * length;

        case 'hex':
          return length / 2;

        case 'base64':
          // Subtract up to two padding chars from end of string!
          if (length > 1 && string.charAt(length - 1) === '=') {
            length--;
          }

          if (length > 1 && string.charAt(length - 1) === '=') {
            length--;
          }

          return Math.floor(length * 3 / 4);
        // drop fractional value
      }

      return utf8ByteLength(string);
    } },
  {
    key: "compare",
    value: function compare(buf1, buf2) {
      if (!Buffer.isBuffer(buf1)) {
        throw new TypeError("The \"buf1\" argument must be one of type Buffer or Uint8Array. Received type ".concat(typeof buf1));
      } // TODO: Wrap UInt8Array args in buffers?


      return buf1.compare(buf2);
    }
    /**
       * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate
       * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.
       * @returns {Buffer}
       */ },

  {
    key: "concat",
    value: function concat(list, totalLength) {
      if (!Array.isArray(list)) {
        throw new TypeError('list argument must be an Array');
      }

      if (list.length === 0) {
        return Buffer.alloc(0); // one empty Buffer!
      } // allocate one Buffer of `totalLength`? Cap at totalLength?


      if (totalLength === undefined) {
        totalLength = 0; // generate the total length from each buffer's length?

        for (var i = 0; i < list.length; i++) {
          totalLength += list[i].length;
        }
      }

      var result = Buffer.allocUnsafe(totalLength);
      var position = 0;

      for (var _i3 = 0; _i3 < list.length; _i3++) {
        var buf = list[_i3];
        buf.copy(result, position);
        position += buf.length;

        if (position >= totalLength) {
          break;
        }
      }

      return result;
    }
    /**
       * @param {integer[]|Buffer|string} value value we're wrapping
       * @param {string} [encoding='utf8'] The encoding of string.
       * @returns {Buffer}
       */ },

  {
    key: "from",
    value: function from(value) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';
      var valueType = typeof value;

      if (valueType === 'string') {
        if (!Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: ".concat(encoding));
        }

        encoding = encoding.toLowerCase();

        if (encoding === 'base64') {
          var blob = Ti.Utils.base64decode(value);
          var blobStream = Ti.Stream.createStream({
            source: blob,
            mode: Ti.Stream.MODE_READ });

          var buffer = Ti.Stream.readAll(blobStream);
          blobStream.close();
          return newBuffer(buffer);
        }

        if (encoding === 'hex') {
          return Buffer.from(stringToHexBytes(value));
        }

        return newBuffer(Ti.createBuffer({
          value: value,
          type: getTiCodecCharset(encoding) }));

      } else if (valueType === 'object') {
        if (Buffer.isBuffer(value)) {
          var length = value.length;

          var _buffer = Buffer.allocUnsafe(length);

          if (length === 0) {
            return _buffer;
          }

          value.copy(_buffer, 0, 0, length);
          return _buffer;
        }

        if (Array.isArray(value) || value instanceof Uint8Array) {
          var _length = value.length;

          if (_length === 0) {
            return Buffer.allocUnsafe(0);
          }

          var tiBuffer = Ti.createBuffer({
            length: _length });


          for (var i = 0; i < _length; i++) {
            tiBuffer[i] = value[i] & 0xFF; // mask to one byte
          }

          return newBuffer(tiBuffer);
        }

        if (value.apiName && value.apiName === 'Ti.Buffer') {
          return newBuffer(value);
        }
      }

      throw new TypeError('The \'value\' argument must be one of type: \'string\', \'Array\', \'Buffer\', \'Ti.Buffer\'');
    }
    /**
       * @param {string} encoding possible encoding name
       * @returns {boolean}
       */ },

  {
    key: "isEncoding",
    value: function isEncoding(encoding) {
      if (typeof encoding !== 'string') {
        return false;
      }

      return VALID_ENCODINGS.includes(encoding.toLowerCase());
    }
    /**
       * @param {*} obj possible Buffer instance
       * @returns {boolean}
       */ },

  {
    key: "isBuffer",
    value: function isBuffer(obj) {
      return obj !== null && obj !== undefined && obj._isBuffer === true;
    } }]);


  return Buffer;
}();

Buffer.poolSize = 8192;
var BufferModule = {
  Buffer,
  // TODO: Implement transcode()!
  transcode: function transcode(_source, _fromEncoding, _toEncoding) {},
  INSPECT_MAX_BYTES: 50,
  kMaxLength: 2147483647,
  kStringMaxLength: 1073741799,
  constants: {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 1073741799 } };


/**
                                        * Searches a Buffer for the index of a single byte.
                                        * @param {Buffer} buffer buffer to search
                                        * @param {integer} singleByte byte we're looking for
                                        * @param {integer} offset start offset we search at
                                        * @returns {integer}
                                        */

function _indexOf(buffer, singleByte, offset) {
  var length = buffer.length;

  for (var i = offset; i < length; i++) {
    if (getAdjustedIndex(buffer, i) === singleByte) {
      return i;
    }
  }

  return -1;
}
/**
   * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.
   * It's possible we may be able to use them when byteLength < 4 if that's faster.
   *
   * @param {integer} unsignedValue value before converting back to signed
   * @param {integer} byteLength number of bytes
   * @returns {integer} the signed value that is represented by the unsigned value's bytes
   */


function unsignedToSigned(unsignedValue, byteLength) {
  var bitLength = byteLength * 8;
  var maxPositiveValue = Math.pow(2, bitLength - 1);

  if (unsignedValue < maxPositiveValue) {
    return unsignedValue;
  }

  var maxUnsignedValue = Math.pow(2, bitLength);
  unsignedValue -= maxUnsignedValue;
  return unsignedValue;
}
/**
   * @param {Ti.Buffer} src source Buffer we're copying from
   * @param {Ti.Buffer} dest destination Buffer we're copying into
   * @param {integer} offset start offset we're copying to in destination
   * @param {integer} length number of bytes to copy
   * @returns {integer} actual number of bytes copied
   */


function copyBuffer(src, dest, offset, length) {
  var srcLength = src.length;
  var destLength = dest.length;
  var i = 0;

  for (; i < length; i++) {
    var destIndex = i + offset; // are we trying to write past end of destination? Or read past end of source? Stop!

    if (destIndex >= destLength || i >= srcLength) {
      break;
    }

    dest[destIndex] = src[i];
  }

  return i;
}
/**
   * @param {string} string utf-8 string
   * @returns {integer}
   */


function utf8ByteLength(string) {
  // Just convert to a Ti.Buffer and let it tell us the length
  var buf = Ti.createBuffer({
    value: string,
    type: Ti.Codec.CHARSET_UTF8 });

  var length = buf.length;
  buf.release(); // release the buffer since we just needed the length

  return length;
}
/**
   * @param {string} encoding desired encoding name
   * @returns {integer} Ti.Codec constant that maps to the encoding
   */


function getTiCodecCharset(encoding) {
  return TI_CODEC_MAP.get(encoding);
}

function bufferToUTF16String(tiBuffer, start, length) {
  var out = '';
  var i = start;

  while (i < length) {
    // utf-16/ucs-2 is 2-bytes per character
    var byte1 = tiBuffer[i++];
    var byte2 = tiBuffer[i++];
    var code_unit = (byte2 << 8) + byte1; // we mash together the two bytes

    out += String.fromCodePoint(code_unit);
  }

  return out;
}
/**
   * loop over input, every 2 characters, parse as an int
   * basically each two characters are a "byte" or an 8-bit uint
   * we append them all together to form a single buffer holding all the values
   * @param {string} value string we're encoding in hex
   * @returns {integer[]} array of encoded bytes
   */


function stringToHexBytes(value) {
  var length = value.length / 2;
  var byteArray = [];

  for (var i = 0; i < length; i++) {
    var numericValue = parseInt(value.substr(i * 2, 2), 16);

    if (!Number.isNaN(numericValue)) {
      // drop bad hex characters
      byteArray.push(numericValue);
    }
  }

  return byteArray;
} // Use a Proxy to hack array style index accessors


var arrayIndexHandler = {
  get(target, propKey, receiver) {
    if (typeof propKey === 'string') {
      var num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        return getAdjustedIndex(target, num);
      }
    }

    return Reflect.get(target, propKey, receiver);
  },

  set(target, propKey, value, receiver) {
    if (typeof propKey === 'string') {
      var num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        return setAdjustedIndex(target, num, value);
      }
    }

    return Reflect.set(target, propKey, value, receiver);
  },

  has(target, key) {
    if (typeof key === 'string') {
      var num = Number(key);

      if (Number.isSafeInteger(num)) {
        // ensure it's a positive "safe" integer within the range of the buffer
        return num >= 0 && num < target._tiBuffer.length;
      }
    }

    return key in target;
  } };



function getAdjustedIndex(buf, index) {
  if (index < 0 || index >= buf._tiBuffer.length) {
    return undefined;
  }

  return buf._tiBuffer[index + buf.byteOffset];
}

function setAdjustedIndex(buf, index, value) {
  if (index >= 0 || index < buf._tiBuffer.length) {
    buf._tiBuffer[index + buf.byteOffset] = value;
  }

  return value;
}
/**
   * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access
   * @param  {...any} args argunents ot Buffer constructor
   * @returns {Buffer} wrapped inside a Proxy
   */


function newBuffer() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return new Proxy(_construct(Buffer, args), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer
}
/**
   * Throws a RangeError if offset is out of bounds
   * @param {Buffer} buffer buffer we're operating on
   * @param {integer} offset user supplied offset
   * @param {integer} byteLength number of bytes needed in range
   * @throws {RangeError}
   */


function checkOffset(buffer, offset, byteLength) {
  var endOffset = buffer.length - byteLength;

  if (offset < 0 || offset > endOffset) {
    throw new RangeError("The value of \"offset\" is out of range. It must be >= 0 and <= ".concat(endOffset, ". Received ").concat(offset));
  }
}
/**
   * @param {integer} value user-supplied value
   * @param {integer} min minimum valid value
   * @param {integer} max maximum valid value
   * @throws {RangeError}
   */


function checkValue(value, min, max) {
  if (value < min || value > max) {
    throw new RangeError("The value of \"value\" is out of range. It must be >= ".concat(min, " and <= ").concat(max, ". Received ").concat(value));
  }
}

var bufferWarningAlreadyEmitted = false;
var nodeModulesCheckCounter = 0;
var bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';

function showFlaggedDeprecation() {
  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {
    // We don't emit a warning, because we either:
    // - Already did so, or
    // - Already checked too many times whether a call is coming
    //   from node_modules and want to stop slowing down things, or
    // - The code is inside `node_modules`.
    return;
  }

  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');
  bufferWarningAlreadyEmitted = true;
}

/**
   * This file is used to hijack the standard require to allow for JS
   * implementations of "core" modules.
   *
   * You add a binding from the "core" module id to the under the hood JS
   * implementation. We then intercept require calls to handle requests for these modules
   * and lazily load the file.
   */

/**
       * Used by @function bindObjectToCoreModuleId
       * @type {map<string, object>}
       */
var bindings = new Map();
/**
                           * Used by @function redirectCoreModuleIdToPath
                           * @type {map<string, string>}
                           */

var redirects = new Map();
/**
                            * Does the request look like a typical core module? (no '.' or '/' characters)
                            * @param {string} path original require path/id
                            * @returns {boolean}
                            */

function isHijackableModuleId(path) {
  if (!path || path.length < 1) {
    return false;
  }

  var firstChar = path.charAt(0);
  return firstChar !== '.' && firstChar !== '/';
} // Hack require to point to this as a core module "binding"


var originalRequire = global.require; // This works for iOS as-is, and also intercepts the call on Android for ti.main.js (the first file executed)

global.require = function (moduleId) {
  if (bindings.has(moduleId)) {
    return bindings.get(moduleId);
  }

  if (redirects.has(moduleId)) {
    moduleId = redirects.get(moduleId);
  }

  return originalRequire(moduleId);
};

if (Ti.Platform.name === 'android') {
  // ... but we still need to hack it when requiring from other files for Android
  var originalModuleRequire = global.Module.prototype.require;

  global.Module.prototype.require = function (path, context) {
    if (bindings.has(path)) {
      return bindings.get(path);
    }

    if (redirects.has(path)) {
      path = redirects.get(path);
    }

    return originalModuleRequire.call(this, path, context);
  };
}
/**
   * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id
   *
   * @param {string} moduleId the module id to "hijack"
   * @param {*} binding an already constructured value/object to return
   */


function register(moduleId, binding) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error("Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ".concat(moduleId, ")"));
  }

  if (redirects.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
    redirects.delete(moduleId);
  } else if (bindings.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
  }

  bindings.set(moduleId, binding);
}
/**
   * Registers a binding from a short module id to the full under the hood filepath if given a string.
   * This allows for lazy instantiation of the module on-demand
   *
   * @param {string} moduleId the module id to "hijack"
   * @param {string} filepath the full filepath to require under the hood.
   *                              This should be an already resolved absolute path,
   *                              as otherwise the context of the call could change what gets loaded!
   */

function redirect(moduleId, filepath) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error("Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ".concat(moduleId, ")"));
  }

  if (bindings.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
    bindings.delete(moduleId);
  } else if (redirects.has(moduleId)) {
    Ti.API.warn("Another binding has already registered for module id: '".concat(moduleId, "', it will be overwritten..."));
  }

  redirects.set(moduleId, filepath);
}
var binding = {
  register,
  redirect };

global.binding = binding;

// Load all the node compatible core modules
register('path', path);
register('os', OS);
register('tty', tty);
register('util', util);
register('assert', assert);
register('events', EventEmitter);
register('buffer', BufferModule); // Register require('buffer').Buffer as global

global.Buffer = BufferModule.Buffer;

/**
                                      * Appcelerator Titanium Mobile
                                      * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
                                      * Licensed under the terms of the Apache Public License
                                      * Please see the LICENSE included with this distribution for details.
                                      *
                                      * Description:
                                      * This script loads all JavaScript files ending with the name "*.bootstrap.js" and then executes them.
                                      * The main intention of this feature is to allow JavaScript files to kick-off functionality or
                                      * display UI to the end-user before the "app.js" gets loaded. This feature is the CommonJS
                                      * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.
                                      *
                                      * Use-Cases:
                                      * - Automatically kick-off analytics functionality on app startup.
                                      * - Ensure "Google Play Services" is installed/updated on app startup on Android.
                                      */

/**
                                          * Attempts to load all bootstraps from a "bootstrap.json" file created by the app build system.
                                          * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.
                                          * This JSON file, if provided, must be in the same directory as this script.
                                          * @returns {string[]}
                                          * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.
                                          * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.
                                          * Returns null if JSON file was not found.
                                          */
function fetchScriptsFromJson() {
  var JSON_FILE_NAME = 'bootstrap.json';

  try {
    var jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, "ti.internal/".concat(JSON_FILE_NAME));

    if (jsonFile.exists()) {
      var settings = JSON.parse(jsonFile.read().text);

      if (Array.isArray(settings.scripts)) {
        return settings.scripts;
      }

      return [];
    }
  } catch (error) {
    Ti.API.error("Failed to read \"".concat(JSON_FILE_NAME, "\". Reason: ").concat(error.message));
  }

  return null;
}
/**
   * Recursively searches the "Resources" directory for all "*.bootstrap.js" files.
   * @returns {Array.<string>}
   * Returns an array of require() compatible strings for each bootstrap found in the search.
   * Returns an empty array if no bootstrap files were found.
   */


function fetchScriptsFromResourcesDirectory() {
  var resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);
  var resourceDirectoryPathLength = resourceDirectory.nativePath.length;
  var bootstrapScripts = [];

  function loadFrom(file) {
    if (file) {
      if (file.isDirectory()) {
        // This is a directory. Recursively look for bootstrap files under it.
        var fileNameArray = file.getDirectoryListing();

        if (fileNameArray) {
          for (var index = 0; index < fileNameArray.length; index++) {
            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));
          }
        }
      } else if (file.name.search(/.bootstrap.js$/) >= 0) {
        // This is a bootstrap file.
        // Convert its path to something loadable via require() and add it to the array.
        var bootstrapPath = file.nativePath;
        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);
        bootstrapScripts.push(bootstrapPath);
      }
    }
  }

  loadFrom(resourceDirectory);
  return bootstrapScripts;
}
/**
   * Non-blocking function which loads and executes all bootstrap scripts configured for the app.
   * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.
   */


function loadAsync(finished) {
  // Acquire an array of all bootstrap scripts included with the app.
  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.
  // - If JSON file not found (will return null), then search "Resources" directory for bootstrap files.
  var bootstrapScripts = fetchScriptsFromJson();

  if (!bootstrapScripts) {
    bootstrapScripts = fetchScriptsFromResourcesDirectory();
  } // Do not continue if no bootstraps were found.


  if (!bootstrapScripts || bootstrapScripts.length <= 0) {
    finished();
    return;
  } // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.


  bootstrapScripts.sort(); // Loads all bootstrap scripts found.

  function loadBootstrapScripts(finished) {
    var bootstrapIndex = 0;

    function doLoad() {
      // Attempt to load all bootstrap scripts.
      while (bootstrapIndex < bootstrapScripts.length) {
        // Load the next bootstrap.
        var fileName = bootstrapScripts[bootstrapIndex];

        var bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require
        // Invoke the bootstrap's execute() method if it has one. (This is optional.)
        // We must wait for the given callback to be invoked before loading the next script.
        // Note: This is expected to be used to display UI to the end-user.


        if (bootstrap.execute) {
          bootstrap.execute(onBootstrapExecutionFinished);
          return;
        } // We're done with the current bootstrap. Time to load the next one.


        bootstrapIndex++;
      } // Invoke given callback to inform caller that all loading is done.


      finished();
    }

    function onBootstrapExecutionFinished() {
      // Last bootstrap has finished execution. Time to load the next one.
      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.
      bootstrapIndex++;
      setTimeout(function () {
        return doLoad();
      }, 1);
    }

    doLoad();
  } // We've finished loading/executing all bootstrap scripts.
  // Inform caller by invoking the callback given to loadAsync().


  loadBootstrapScripts(finished);
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   *
   * This script is loaded on app startup on all platforms. It is used to do the following:
   * - Provide consistent startup behavior between platforms, such as logging Titanium version.
   * - Load Titanium's core JavaScript extensions shared by all platforms.
   * - Provide "*.bootstrap.js" script support. (Similar to native module onAppCreate()/load() support.)
   * - Load the app developer's main "app.js" script after doing all of the above.
   */
// Log the app name, app version, and Titanium version on startup.
Ti.API.info("".concat(Ti.App.name, " ").concat(Ti.App.version, " (Powered by Titanium ").concat(Ti.version, ".").concat(Ti.buildHash, ")")); // Attempt to load crash analytics module.
// NOTE: This should be the first module that loads on startup.

try {
  require('com.appcelerator.aca');
} catch (e) {} // Could not load module, silently ignore exception.
loadAsync(function () {
  // We've finished loading/executing all bootstrap scripts.
  // We can now proceed to run the main "app.js" script.
  require('./app'); // This event is to be fired after "app.js" execution. Reasons:
  // - Allow system to queue startup related events until "app.js" has had a chance to add listeners.
  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.


  Ti.App.fireEvent('started');
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRpLm1haW4uanMiXSwibmFtZXMiOlsiY3JlYXRlQ29tbW9uanNNb2R1bGUiLCJmbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJfZ2xvYmFsIiwiZ2xvYmFsIiwid2luZG93IiwiTWF0aCIsInNlbGYiLCJGdW5jdGlvbiIsIl9fZyIsIl9jb3JlIiwiY29yZSIsInZlcnNpb24iLCJfX2UiLCJfY29yZV8xIiwiX2lzT2JqZWN0IiwiaXQiLCJfYW5PYmplY3QiLCJUeXBlRXJyb3IiLCJfZmFpbHMiLCJleGVjIiwiZSIsIl9kZXNjcmlwdG9ycyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYSIsImRvY3VtZW50JDEiLCJkb2N1bWVudCIsImlzIiwiY3JlYXRlRWxlbWVudCIsIl9kb21DcmVhdGUiLCJfaWU4RG9tRGVmaW5lIiwiX3RvUHJpbWl0aXZlIiwiUyIsInZhbCIsInRvU3RyaW5nIiwiY2FsbCIsInZhbHVlT2YiLCJkUCIsImYiLCJPIiwiUCIsIkF0dHJpYnV0ZXMiLCJ2YWx1ZSIsIl9vYmplY3REcCIsIl9wcm9wZXJ0eURlc2MiLCJiaXRtYXAiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfaGlkZSIsIm9iamVjdCIsImtleSIsImhhc093blByb3BlcnR5IiwiX2hhcyIsImlkIiwicHgiLCJyYW5kb20iLCJfdWlkIiwiY29uY2F0IiwidW5kZWZpbmVkIiwiX2xpYnJhcnkiLCJfc2hhcmVkIiwiU0hBUkVEIiwic3RvcmUiLCJwdXNoIiwibW9kZSIsImNvcHlyaWdodCIsIl9mdW5jdGlvblRvU3RyaW5nIiwiX3JlZGVmaW5lIiwiU1JDIiwiVE9fU1RSSU5HIiwiVFBMIiwic3BsaXQiLCJpbnNwZWN0U291cmNlIiwic2FmZSIsImlzRnVuY3Rpb24iLCJqb2luIiwiU3RyaW5nIiwicHJvdG90eXBlIiwiX2FGdW5jdGlvbiIsIl9jdHgiLCJ0aGF0IiwibGVuZ3RoIiwiYiIsImMiLCJhcHBseSIsImFyZ3VtZW50cyIsIlBST1RPVFlQRSIsIiRleHBvcnQiLCJ0eXBlIiwibmFtZSIsInNvdXJjZSIsIklTX0ZPUkNFRCIsIkYiLCJJU19HTE9CQUwiLCJHIiwiSVNfU1RBVElDIiwiSVNfUFJPVE8iLCJJU19CSU5EIiwiQiIsInRhcmdldCIsImV4cFByb3RvIiwib3duIiwib3V0IiwiZXhwIiwiVSIsIlciLCJSIiwiX2V4cG9ydCIsIl9jb2YiLCJzbGljZSIsIl9pc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiYXJnIiwiY2VpbCIsImZsb29yIiwiX3RvSW50ZWdlciIsImlzTmFOIiwibWluIiwiX3RvTGVuZ3RoIiwiX3drcyIsIlN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsIklTX0NPTkNBVF9TUFJFQURBQkxFIiwiZmxhdHRlbkludG9BcnJheSIsIm9yaWdpbmFsIiwic291cmNlTGVuIiwic3RhcnQiLCJkZXB0aCIsIm1hcHBlciIsInRoaXNBcmciLCJ0YXJnZXRJbmRleCIsInNvdXJjZUluZGV4IiwibWFwRm4iLCJlbGVtZW50Iiwic3ByZWFkYWJsZSIsIl9mbGF0dGVuSW50b0FycmF5IiwiX2RlZmluZWQiLCJfdG9PYmplY3QiLCJTUEVDSUVTIiwiX2FycmF5U3BlY2llc0NvbnN0cnVjdG9yIiwiQyIsImNvbnN0cnVjdG9yIiwiX2FycmF5U3BlY2llc0NyZWF0ZSIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90byIsIl9hZGRUb1Vuc2NvcGFibGVzIiwiZmxhdE1hcCIsImNhbGxiYWNrZm4iLCJBIiwiX2l0ZXJDYWxsIiwiaXRlcmF0b3IiLCJlbnRyaWVzIiwicmV0IiwiX2l0ZXJhdG9ycyIsIklURVJBVE9SIiwiQXJyYXlQcm90byQxIiwiX2lzQXJyYXlJdGVyIiwiX2NyZWF0ZVByb3BlcnR5IiwiaW5kZXgiLCJUQUciLCJBUkciLCJ0cnlHZXQiLCJfY2xhc3NvZiIsIlQiLCJjYWxsZWUiLCJJVEVSQVRPUiQxIiwiY29yZV9nZXRJdGVyYXRvck1ldGhvZCIsImdldEl0ZXJhdG9yTWV0aG9kIiwiSVRFUkFUT1IkMiIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwiZnJvbSIsIl9pdGVyRGV0ZWN0Iiwic2tpcENsb3NpbmciLCJhcnIiLCJpdGVyIiwibmV4dCIsImRvbmUiLCJhcnJheUxpa2UiLCJhTGVuIiwibWFwZm4iLCJtYXBwaW5nIiwiaXRlckZuIiwicmVzdWx0Iiwic3RlcCIsIl9pb2JqZWN0IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfdG9Jb2JqZWN0IiwibWF4IiwibWluJDEiLCJfdG9BYnNvbHV0ZUluZGV4IiwiX2FycmF5SW5jbHVkZXMiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZWwiLCJmcm9tSW5kZXgiLCIkaW5jbHVkZXMiLCJpbmNsdWRlcyIsIl9zdHJpY3RNZXRob2QiLCJtZXRob2QiLCIkc29ydCIsInNvcnQiLCJ0ZXN0IiwiY29tcGFyZWZuIiwiU1BFQ0lFUyQxIiwiX3NldFNwZWNpZXMiLCJLRVkiLCJEYXRlIiwiTmFOIiwidG9KU09OIiwidG9JU09TdHJpbmciLCJwdiIsImlzRmluaXRlIiwiTlVNQkVSIiwiX2RhdGVUb1ByaW1pdGl2ZSIsImhpbnQiLCJUT19QUklNSVRJVkUiLCJwcm90byIsInNoYXJlZCIsIl9zaGFyZWRLZXkiLCJJRV9QUk9UTyIsIk9iamVjdFByb3RvIiwiX29iamVjdEdwbyIsImdldFByb3RvdHlwZU9mIiwiSEFTX0lOU1RBTkNFIiwiRnVuY3Rpb25Qcm90byIsImFycmF5SW5kZXhPZiIsIklFX1BST1RPJDEiLCJfb2JqZWN0S2V5c0ludGVybmFsIiwibmFtZXMiLCJpIiwiX2VudW1CdWdLZXlzIiwiX29iamVjdEtleXMiLCJrZXlzIiwiX29iamVjdERwcyIsImRlZmluZVByb3BlcnRpZXMiLCJQcm9wZXJ0aWVzIiwiZG9jdW1lbnQkMiIsIl9odG1sIiwiZG9jdW1lbnRFbGVtZW50IiwiSUVfUFJPVE8kMiIsIkVtcHR5IiwiUFJPVE9UWVBFJDEiLCJfY3JlYXRlRGljdCIsImNyZWF0ZURpY3QiLCJpZnJhbWUiLCJsdCIsImd0IiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsInNyYyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwid3JpdGUiLCJjbG9zZSIsIl9vYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJfcmVkZWZpbmVBbGwiLCJfYW5JbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiZm9yYmlkZGVuRmllbGQiLCJfZm9yT2YiLCJCUkVBSyIsIlJFVFVSTiIsIml0ZXJhYmxlIiwiZGVmIiwiVEFHJDEiLCJfc2V0VG9TdHJpbmdUYWciLCJ0YWciLCJzdGF0IiwiSXRlcmF0b3JQcm90b3R5cGUiLCJfaXRlckNyZWF0ZSIsIk5BTUUiLCJJVEVSQVRPUiQzIiwiQlVHR1kiLCJGRl9JVEVSQVRPUiIsIktFWVMiLCJWQUxVRVMiLCJyZXR1cm5UaGlzIiwiX2l0ZXJEZWZpbmUiLCJCYXNlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldE1ldGhvZCIsImtpbmQiLCJ2YWx1ZXMiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIm1ldGhvZHMiLCJfaXRlclN0ZXAiLCJfbWV0YSIsIk1FVEEiLCJzZXREZXNjIiwiaXNFeHRlbnNpYmxlIiwiRlJFRVpFIiwicHJldmVudEV4dGVuc2lvbnMiLCJzZXRNZXRhIiwidyIsImZhc3RLZXkiLCJnZXRXZWFrIiwib25GcmVlemUiLCJtZXRhIiwiTkVFRCIsIl9tZXRhXzEiLCJfbWV0YV8yIiwiX21ldGFfMyIsIl9tZXRhXzQiLCJfbWV0YV81IiwiX3ZhbGlkYXRlQ29sbGVjdGlvbiIsIlRZUEUiLCJfdCIsImRQJDEiLCJTSVpFIiwiZ2V0RW50cnkiLCJlbnRyeSIsIl9pIiwiX2YiLCJuIiwiayIsIl9jb2xsZWN0aW9uU3Ryb25nIiwiZ2V0Q29uc3RydWN0b3IiLCJ3cmFwcGVyIiwiSVNfTUFQIiwiQURERVIiLCJfbCIsImNsZWFyIiwiZGF0YSIsInIiLCJwIiwiX2RlbGV0ZSIsInByZXYiLCJmb3JFYWNoIiwidiIsImhhcyIsInNldFN0cm9uZyIsIml0ZXJhdGVkIiwiX2siLCJmJDEiLCJfb2JqZWN0UGllIiwiZ09QRCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImYkMiIsIl9vYmplY3RHb3BkIiwiY2hlY2siLCJfc2V0UHJvdG8iLCJzZXQiLCJzZXRQcm90b3R5cGVPZiIsImJ1Z2d5IiwiX19wcm90b19fIiwiX2luaGVyaXRJZlJlcXVpcmVkIiwiX2NvbGxlY3Rpb24iLCJjb21tb24iLCJJU19XRUFLIiwiZml4TWV0aG9kIiwiYWRkIiwiaW5zdGFuY2UiLCJIQVNOVF9DSEFJTklORyIsIlRIUk9XU19PTl9QUklNSVRJVkVTIiwiQUNDRVBUX0lURVJBQkxFUyIsIkJVR0dZX1pFUk8iLCIkaW5zdGFuY2UiLCJNQVAiLCJlczZfbWFwIiwiTWFwIiwiZiQzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiX29iamVjdEdvcHMiLCIkYXNzaWduIiwiYXNzaWduIiwiX29iamVjdEFzc2lnbiIsIksiLCJnZXRTeW1ib2xzIiwiaXNFbnVtIiwiaiIsIl9vYmplY3RUb0FycmF5IiwiaXNFbnRyaWVzIiwiaGlkZGVuS2V5cyIsImYkNCIsImdldE93blByb3BlcnR5TmFtZXMiLCJfb2JqZWN0R29wbiIsIlJlZmxlY3QkMSIsIlJlZmxlY3QiLCJfb3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZ2V0RGVzYyIsImRlc2MiLCJ0ZXN0JDEiLCIkdmFsdWVzIiwiU1BFQ0lFUyQyIiwiX3NwZWNpZXNDb25zdHJ1Y3RvciIsIkQiLCJfaW52b2tlIiwiYXJncyIsInVuIiwicHJvY2VzcyQxIiwicHJvY2VzcyIsInNldFRhc2siLCJzZXRJbW1lZGlhdGUiLCJjbGVhclRhc2siLCJjbGVhckltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiRGlzcGF0Y2giLCJjb3VudGVyIiwicXVldWUiLCJPTlJFQURZU1RBVEVDSEFOR0UiLCJkZWZlciIsImNoYW5uZWwiLCJwb3J0IiwicnVuIiwibGlzdGVuZXIiLCJldmVudCIsIm5leHRUaWNrIiwibm93IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImltcG9ydFNjcmlwdHMiLCJyZW1vdmVDaGlsZCIsInNldFRpbWVvdXQiLCJfdGFzayIsIm1hY3JvdGFzayIsIk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJwcm9jZXNzJDIiLCJQcm9taXNlJDEiLCJQcm9taXNlIiwiaXNOb2RlIiwiX21pY3JvdGFzayIsImhlYWQiLCJsYXN0Iiwibm90aWZ5IiwiZmx1c2giLCJwYXJlbnQiLCJkb21haW4iLCJleGl0IiwiZW50ZXIiLCJuYXZpZ2F0b3IiLCJzdGFuZGFsb25lIiwidG9nZ2xlIiwibm9kZSIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJyZXNvbHZlIiwicHJvbWlzZSIsInRoZW4iLCJ0YXNrIiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJyZWplY3QiLCIkJHJlc29sdmUiLCIkJHJlamVjdCIsImYkNSIsIl9uZXdQcm9taXNlQ2FwYWJpbGl0eSIsIl9wZXJmb3JtIiwiX3VzZXJBZ2VudCIsInVzZXJBZ2VudCIsIl9wcm9taXNlUmVzb2x2ZSIsIngiLCJwcm9taXNlQ2FwYWJpbGl0eSIsIm1pY3JvdGFzayIsIlBST01JU0UiLCJUeXBlRXJyb3IkMSIsInByb2Nlc3MkMyIsInZlcnNpb25zIiwidjgiLCIkUHJvbWlzZSIsImlzTm9kZSQxIiwiZW1wdHkiLCJJbnRlcm5hbCIsIm5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiV3JhcHBlciIsIm5ld1Byb21pc2VDYXBhYmlsaXR5IiwiVVNFX05BVElWRSIsIkZha2VQcm9taXNlIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiaW5kZXhPZiIsImlzVGhlbmFibGUiLCJpc1JlamVjdCIsIl9uIiwiY2hhaW4iLCJfYyIsIl92Iiwib2siLCJfcyIsInJlYWN0aW9uIiwiaGFuZGxlciIsImZhaWwiLCJleGl0ZWQiLCJfaCIsIm9uSGFuZGxlVW5oYW5kbGVkIiwib25VbmhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJpc1VuaGFuZGxlZCIsImNvbnNvbGUiLCJlbWl0Iiwib251bmhhbmRsZWRyZWplY3Rpb24iLCJyZWFzb24iLCJlcnJvciIsIl9hIiwib25yZWplY3Rpb25oYW5kbGVkIiwiJHJlamVjdCIsIl9kIiwiX3ciLCIkcmVzb2x2ZSIsImV4ZWN1dG9yIiwiZXJyIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiX2NhdGNoIiwiY2FwYWJpbGl0eSIsImFsbCIsInJlbWFpbmluZyIsIiRpbmRleCIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwiX2ZpbmFsbHkiLCJvbkZpbmFsbHkiLCJyQXBwbHkiLCJmQXBwbHkiLCJ0aGlzQXJndW1lbnQiLCJhcmd1bWVudHNMaXN0IiwiTCIsImFycmF5U2xpY2UiLCJmYWN0b3JpZXMiLCJjb25zdHJ1Y3QiLCJsZW4iLCJfYmluZCIsImJpbmQiLCJwYXJ0QXJncyIsImJvdW5kIiwickNvbnN0cnVjdCIsIk5FV19UQVJHRVRfQlVHIiwiQVJHU19CVUciLCJUYXJnZXQiLCJuZXdUYXJnZXQiLCIkYXJncyIsInByb3BlcnR5S2V5IiwiYXR0cmlidXRlcyIsImdPUEQkMSIsImRlbGV0ZVByb3BlcnR5IiwicmVjZWl2ZXIiLCIkaXNFeHRlbnNpYmxlIiwiJHByZXZlbnRFeHRlbnNpb25zIiwiViIsIm93bkRlc2MiLCJleGlzdGluZ0Rlc2NyaXB0b3IiLCJNQVRDSCIsIl9pc1JlZ2V4cCIsImlzUmVnRXhwIiwiX2ZsYWdzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsInVuaWNvZGUiLCJzdGlja3kiLCJkUCQyIiwiZ09QTiIsIiRSZWdFeHAiLCJSZWdFeHAiLCJwcm90byQxIiwicmUxIiwicmUyIiwiQ09SUkVDVF9ORVciLCJ0aVJFIiwicGlSRSIsImZpVSIsInByb3h5IiwiX3N0cmluZ0F0IiwicG9zIiwicyIsImwiLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwiYXQiLCJfYWR2YW5jZVN0cmluZ0luZGV4IiwiYnVpbHRpbkV4ZWMiLCJfcmVnZXhwRXhlY0Fic3RyYWN0IiwibmF0aXZlRXhlYyIsIm5hdGl2ZVJlcGxhY2UiLCJyZXBsYWNlIiwicGF0Y2hlZEV4ZWMiLCJMQVNUX0lOREVYIiwiVVBEQVRFU19MQVNUX0lOREVYX1dST05HIiwiTlBDR19JTkNMVURFRCIsIlBBVENIIiwic3RyIiwicmUiLCJsYXN0SW5kZXgiLCJyZUNvcHkiLCJtYXRjaCIsIl9yZWdleHBFeGVjIiwiZm9yY2VkIiwiU1BFQ0lFUyQzIiwiUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMiLCJncm91cHMiLCJTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMiLCJvcmlnaW5hbEV4ZWMiLCJfZml4UmVXa3MiLCJTWU1CT0wiLCJERUxFR0FURVNfVE9fU1lNQk9MIiwiREVMRUdBVEVTX1RPX0VYRUMiLCJleGVjQ2FsbGVkIiwibmF0aXZlUmVnRXhwTWV0aG9kIiwiZm5zIiwibWF5YmVDYWxsTmF0aXZlIiwibmF0aXZlTWV0aG9kIiwicmVnZXhwIiwiYXJnMiIsImZvcmNlU3RyaW5nTWV0aG9kIiwic3RyZm4iLCJyeGZuIiwic3RyaW5nIiwiZGVmaW5lZCIsIiRtYXRjaCIsInJlcyIsInJ4IiwiZnVsbFVuaWNvZGUiLCJtYXRjaFN0ciIsIm1heCQxIiwibWluJDIiLCJmbG9vciQxIiwiU1VCU1RJVFVUSU9OX1NZTUJPTFMiLCJTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCIsIm1heWJlVG9TdHJpbmciLCJSRVBMQUNFIiwiJHJlcGxhY2UiLCJzZWFyY2hWYWx1ZSIsInJlcGxhY2VWYWx1ZSIsImZ1bmN0aW9uYWxSZXBsYWNlIiwicmVzdWx0cyIsImFjY3VtdWxhdGVkUmVzdWx0IiwibmV4dFNvdXJjZVBvc2l0aW9uIiwibWF0Y2hlZCIsInBvc2l0aW9uIiwiY2FwdHVyZXMiLCJuYW1lZENhcHR1cmVzIiwicmVwbGFjZXJBcmdzIiwicmVwbGFjZW1lbnQiLCJnZXRTdWJzdGl0dXRpb24iLCJ0YWlsUG9zIiwibSIsInN5bWJvbHMiLCJjaCIsImNhcHR1cmUiLCIkbWluIiwiJHB1c2giLCIkU1BMSVQiLCJMRU5HVEgiLCJMQVNUX0lOREVYJDEiLCJNQVhfVUlOVDMyIiwiU1VQUE9SVFNfWSIsIlNQTElUIiwiJHNwbGl0IiwiaW50ZXJuYWxTcGxpdCIsInNlcGFyYXRvciIsImxpbWl0Iiwib3V0cHV0IiwiZmxhZ3MiLCJsYXN0TGFzdEluZGV4Iiwic3BsaXRMaW1pdCIsInNlcGFyYXRvckNvcHkiLCJsYXN0TGVuZ3RoIiwic3BsaXR0ZXIiLCJ1bmljb2RlTWF0Y2hpbmciLCJsaW0iLCJxIiwieiIsIl9zYW1lVmFsdWUiLCJ5IiwiU0VBUkNIIiwiJHNlYXJjaCIsInNlYXJjaCIsInByZXZpb3VzTGFzdEluZGV4IiwiJHRvU3RyaW5nIiwiZGVmaW5lIiwiU0VUIiwiZXM2X3NldCIsIlNldCIsImYkNiIsIl93a3NFeHQiLCJfd2tzRGVmaW5lIiwiJFN5bWJvbCIsIl9lbnVtS2V5cyIsImdPUE4kMSIsInRvU3RyaW5nJDEiLCJ3aW5kb3dOYW1lcyIsImdldFdpbmRvd05hbWVzIiwiZiQ3IiwiX29iamVjdEdvcG5FeHQiLCJnT1BEJDIiLCJkUCQzIiwiZ09QTiQyIiwiJEpTT04iLCJKU09OIiwiX3N0cmluZ2lmeSIsInN0cmluZ2lmeSIsIlBST1RPVFlQRSQyIiwiSElEREVOIiwiVE9fUFJJTUlUSVZFJDEiLCJpc0VudW0kMSIsIlN5bWJvbFJlZ2lzdHJ5IiwiQWxsU3ltYm9scyIsIk9QU3ltYm9scyIsIk9iamVjdFByb3RvJDEiLCJVU0VfTkFUSVZFJDEiLCJRT2JqZWN0Iiwic2V0dGVyIiwiZmluZENoaWxkIiwic2V0U3ltYm9sRGVzYyIsInByb3RvRGVzYyIsIndyYXAiLCJzeW0iLCJpc1N5bWJvbCIsIiRkZWZpbmVQcm9wZXJ0eSIsIiRkZWZpbmVQcm9wZXJ0aWVzIiwiJGNyZWF0ZSIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkUiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiJGdldE93blByb3BlcnR5TmFtZXMiLCIkZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiSVNfT1AiLCIkc2V0IiwiZXM2U3ltYm9scyIsIndlbGxLbm93blN5bWJvbHMiLCJfZm9yIiwia2V5Rm9yIiwidXNlU2V0dGVyIiwidXNlU2ltcGxlIiwicmVwbGFjZXIiLCIkcmVwbGFjZXIiLCJfc3RyaW5nUmVwZWF0IiwicmVwZWF0IiwiY291bnQiLCJJbmZpbml0eSIsIlJhbmdlRXJyb3IiLCJfc3RyaW5nUGFkIiwibWF4TGVuZ3RoIiwiZmlsbFN0cmluZyIsImxlZnQiLCJzdHJpbmdMZW5ndGgiLCJmaWxsU3RyIiwiaW50TWF4TGVuZ3RoIiwiZmlsbExlbiIsInN0cmluZ0ZpbGxlciIsIldFQktJVF9CVUciLCJwYWRTdGFydCIsIldFQktJVF9CVUckMSIsInBhZEVuZCIsIl9zdHJpbmdXcyIsInNwYWNlIiwibm9uIiwibHRyaW0iLCJydHJpbSIsImV4cG9ydGVyIiwiQUxJQVMiLCJGT1JDRSIsInRyaW0iLCJfc3RyaW5nVHJpbSIsIiR0cmltIiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJUWVBFRCIsIlZJRVciLCJBQlYiLCJBcnJheUJ1ZmZlciIsIkRhdGFWaWV3IiwiQ09OU1RSIiwiaSQxIiwiVHlwZWQiLCJUeXBlZEFycmF5Q29uc3RydWN0b3JzIiwiX3R5cGVkIiwiX3RvSW5kZXgiLCJudW1iZXIiLCJfYXJyYXlGaWxsIiwiZmlsbCIsImVuZCIsImVuZFBvcyIsIl90eXBlZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsIkRBVEFfVklFVyIsIldST05HX0xFTkdUSCIsIldST05HX0lOREVYIiwiJEFycmF5QnVmZmVyIiwiJERhdGFWaWV3IiwiQmFzZUJ1ZmZlciIsImFicyIsInBvdyIsImxvZyIsIkxOMiIsIkJVRkZFUiIsIkJZVEVfTEVOR1RIIiwiQllURV9PRkZTRVQiLCIkQlVGRkVSIiwiJExFTkdUSCIsIiRPRkZTRVQiLCJwYWNrSUVFRTc1NCIsIm1MZW4iLCJuQnl0ZXMiLCJidWZmZXIiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwicnQiLCJ1bnBhY2tJRUVFNzU0IiwibkJpdHMiLCJ1bnBhY2tJMzIiLCJieXRlcyIsInBhY2tJOCIsInBhY2tJMTYiLCJwYWNrSTMyIiwicGFja0Y2NCIsInBhY2tGMzIiLCJhZGRHZXR0ZXIiLCJpbnRlcm5hbCIsInZpZXciLCJpc0xpdHRsZUVuZGlhbiIsIm51bUluZGV4IiwiaW50SW5kZXgiLCJfYiIsInBhY2siLCJyZXZlcnNlIiwiY29udmVyc2lvbiIsImJ5dGVMZW5ndGgiLCJieXRlT2Zmc2V0IiwiYnVmZmVyTGVuZ3RoIiwib2Zmc2V0IiwiZ2V0SW50OCIsImdldFVpbnQ4IiwiZ2V0SW50MTYiLCJnZXRVaW50MTYiLCJnZXRJbnQzMiIsImdldFVpbnQzMiIsImdldEZsb2F0MzIiLCJnZXRGbG9hdDY0Iiwic2V0SW50OCIsInNldFVpbnQ4Iiwic2V0SW50MTYiLCJzZXRVaW50MTYiLCJzZXRJbnQzMiIsInNldFVpbnQzMiIsInNldEZsb2F0MzIiLCJzZXRGbG9hdDY0IiwiQXJyYXlCdWZmZXJQcm90byIsIiRzZXRJbnQ4IiwiJGlzVmlldyIsImlzVmlldyIsIiRzbGljZSIsIlZJRVckMSIsImZpcnN0IiwiZmluIiwidmlld1MiLCJ2aWV3VCIsIl9hcnJheU1ldGhvZHMiLCJJU19GSUxURVIiLCJJU19TT01FIiwiSVNfRVZFUlkiLCJJU19GSU5EX0lOREVYIiwiTk9fSE9MRVMiLCJlczZfYXJyYXlfaXRlcmF0b3IiLCJBcmd1bWVudHMiLCJfYXJyYXlDb3B5V2l0aGluIiwiY29weVdpdGhpbiIsInRvIiwiaW5jIiwiX3R5cGVkQXJyYXkiLCJMSUJSQVJZIiwiZmFpbHMiLCIkdHlwZWQiLCIkYnVmZmVyIiwiY3R4IiwiYW5JbnN0YW5jZSIsInByb3BlcnR5RGVzYyIsImhpZGUiLCJyZWRlZmluZUFsbCIsInRvSW50ZWdlciIsInRvTGVuZ3RoIiwidG9JbmRleCIsInRvQWJzb2x1dGVJbmRleCIsInRvUHJpbWl0aXZlIiwiY2xhc3NvZiIsImlzT2JqZWN0IiwidG9PYmplY3QiLCJpc0FycmF5SXRlciIsImdldEl0ZXJGbiIsInVpZCIsIndrcyIsImNyZWF0ZUFycmF5TWV0aG9kIiwiY3JlYXRlQXJyYXlJbmNsdWRlcyIsInNwZWNpZXNDb25zdHJ1Y3RvciIsIkFycmF5SXRlcmF0b3JzIiwiSXRlcmF0b3JzIiwiJGl0ZXJEZXRlY3QiLCJzZXRTcGVjaWVzIiwiYXJyYXlGaWxsIiwiYXJyYXlDb3B5V2l0aGluIiwiJERQIiwiJEdPUEQiLCJVaW50OEFycmF5IiwiU0hBUkVEX0JVRkZFUiIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiYXJyYXlGb3JFYWNoIiwiYXJyYXlGaWx0ZXIiLCJhcnJheVNvbWUiLCJhcnJheUV2ZXJ5IiwiYXJyYXlGaW5kIiwiYXJyYXlGaW5kSW5kZXgiLCJhcnJheUluY2x1ZGVzIiwiYXJyYXlWYWx1ZXMiLCJhcnJheUtleXMiLCJhcnJheUVudHJpZXMiLCJhcnJheUxhc3RJbmRleE9mIiwibGFzdEluZGV4T2YiLCJhcnJheVJlZHVjZSIsInJlZHVjZSIsImFycmF5UmVkdWNlUmlnaHQiLCJyZWR1Y2VSaWdodCIsImFycmF5Sm9pbiIsImFycmF5U29ydCIsImFycmF5VG9TdHJpbmciLCJhcnJheVRvTG9jYWxlU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJUWVBFRF9DT05TVFJVQ1RPUiIsIkRFRl9DT05TVFJVQ1RPUiIsIkFMTF9DT05TVFJVQ1RPUlMiLCJUWVBFRF9BUlJBWSIsIiRtYXAiLCJhbGxvY2F0ZSIsIkxJVFRMRV9FTkRJQU4iLCJVaW50MTZBcnJheSIsIkZPUkNFRF9TRVQiLCJ0b09mZnNldCIsIkJZVEVTIiwidmFsaWRhdGUiLCJzcGVjaWVzRnJvbUxpc3QiLCJsaXN0IiwiZnJvbUxpc3QiLCIkZnJvbSIsIiRvZiIsIm9mIiwiVE9fTE9DQUxFX0JVRyIsIiR0b0xvY2FsZVN0cmluZyIsImV2ZXJ5IiwiZmlsdGVyIiwiZmluZCIsInByZWRpY2F0ZSIsImZpbmRJbmRleCIsInNlYXJjaEVsZW1lbnQiLCJtYXAiLCJtaWRkbGUiLCJzb21lIiwic3ViYXJyYXkiLCJiZWdpbiIsIiRiZWdpbiIsIiRpdGVyYXRvcnMiLCJpc1RBSW5kZXgiLCIkZ2V0RGVzYyIsIiRzZXREZXNjIiwiJFR5cGVkQXJyYXlQcm90b3R5cGUkIiwiQ0xBTVBFRCIsIkdFVFRFUiIsIlNFVFRFUiIsIlR5cGVkQXJyYXkiLCJUQUMiLCJUeXBlZEFycmF5UHJvdG90eXBlIiwiZ2V0dGVyIiwibyIsInJvdW5kIiwiYWRkRWxlbWVudCIsIiRvZmZzZXQiLCIkbGVuZ3RoIiwia2xhc3MiLCIkbGVuIiwiJG5hdGl2ZUl0ZXJhdG9yIiwiQ09SUkVDVF9JVEVSX05BTUUiLCIkaXRlcmF0b3IiLCJpbml0IiwiSW50OEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwicnVudGltZSIsIk9wIiwiaGFzT3duIiwidW5kZWZpbmVkJDEiLCJpdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInJlZ2VuZXJhdG9yUnVudGltZSIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNvbnRleHQiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwib2JqIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJnZXRQcm90byIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwiR3AiLCJkaXNwbGF5TmFtZSIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwibWFyayIsImF3cmFwIiwiX19hd2FpdCIsIkFzeW5jSXRlcmF0b3IiLCJpbnZva2UiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsInN0YXRlIiwiRXJyb3IiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJldHVybiIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwicG9wIiwiaXRlcmF0b3JNZXRob2QiLCJza2lwVGVtcFJlc2V0Iiwic3RvcCIsInJvb3RFbnRyeSIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIiwicHJvcGVydGllcyIsIlRpIiwiUGxhdGZvcm0iLCJvc25hbWUiLCJjcmVhdGVCdWZmZXIiLCJibG9iIiwidG9CbG9iIiwidGV4dCIsImNvbG9yc2V0Iiwib3NWZXJzaW9uIiwidWlNb2R1bGUiLCJVSSIsIkFuZHJvaWQiLCJrcm9sbCIsImJpbmRpbmciLCJUaXRhbml1bSIsIlNFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQiLCJTRU1BTlRJQ19DT0xPUl9UWVBFX0RBUksiLCJjdXJyZW50Q29sb3JUeXBlIiwiY29sb3JUeXBlIiwiZmV0Y2hTZW1hbnRpY0NvbG9yIiwiY29sb3JOYW1lIiwicGFyc2VJbnQiLCJBcHAiLCJpT1MiLCJyZXF1aXJlIiwic2VtYW50aWNDb2xvclR5cGUiLCJjb2xvciIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsIl9uZXh0IiwiX3Rocm93IiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJfY2xhc3NDYWxsQ2hlY2siLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsImlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIl9jb25zdHJ1Y3QiLCJQYXJlbnQiLCJDbGFzcyIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiX3dyYXBOYXRpdmVTdXBlciIsIl9jYWNoZSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsImFycjIiLCJfYXJyIiwiX2UiLCJfYWRkTGlzdGVuZXIiLCJlbWl0dGVyIiwiZXZlbnROYW1lIiwicHJlcGVuZCIsIl9ldmVudHNUb0xpc3RlbmVycyIsIm5ld0xpc3RlbmVyIiwiZXZlbnRMaXN0ZW5lcnMiLCJ1bnNoaWZ0IiwiZ2V0TWF4TGlzdGVuZXJzIiwiZW1pdFdhcm5pbmciLCJvbmNlV3JhcCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcHBlZEZ1bmMiLCJfbGVuIiwiX2tleSIsIndyYXBwZXJUaGlzIiwiRXZlbnRFbWl0dGVyIiwiX21heExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwib24iLCJwcmVwZW5kTGlzdGVuZXIiLCJvbmNlIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImZvdW5kSW5kZXgiLCJ1bndyYXBwZWRMaXN0ZW5lciIsInNwbGljZSIsIm9mZiIsIl9sZW4yIiwiX2tleTIiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9zdGVwIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJsaXN0ZW5lcnMiLCJyYXciLCJyYXdMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX3RoaXMiLCJhc3NlcnRBcmd1bWVudFR5cGUiLCJ0eXBlbmFtZSIsInRvTG93ZXJDYXNlIiwic3RhcnRUaW1lIiwic3RhbmRhcmRpemVBcmNoIiwicHJvY2VzcyQ0IiwiYWJvcnQiLCJhcmNoIiwiYXJjaGl0ZWN0dXJlIiwiYXJndiIsImNoZGlyIiwiY29uZmlnIiwiY29ubmVjdGVkIiwiY3B1VXNhZ2UiLCJ1c2VyIiwic3lzdGVtIiwiY3dkIiwiX19kaXJuYW1lIiwiYXNzZXRzIiwianNvbiIsInJlYWRBc3NldCIsImRlcGxveURhdGEiLCJwYXJzZSIsImRlYnVnZ2VyUG9ydCIsImRpc2Nvbm5lY3QiLCJkbG9wZW4iLCJ3YXJuaW5nIiwib3B0aW9ucyIsImNvZGUiLCJkZXRhaWwiLCJpc0RlcHJlY2F0aW9uIiwibm9EZXByZWNhdGlvbiIsInRocm93RGVwcmVjYXRpb24iLCJsb2FkRW52SnNvbiIsImpzb25GaWxlIiwiRmlsZXN5c3RlbSIsImdldEZpbGUiLCJyZXNvdXJjZXNEaXJlY3RvcnkiLCJleGlzdHMiLCJyZWFkIiwiQVBJIiwibWVzc2FnZSIsImVudiIsImV4ZWNBcmd2IiwiZXhlY1BhdGgiLCJleGl0Q29kZSIsInBpZCIsInBsYXRmb3JtIiwicHBpZCIsInN0ZGVyciIsImlzVFRZIiwiY2h1bmsiLCJlbmNvZGluZyIsImNhbGxiYWNrIiwic3Rkb3V0IiwidGl0bGUiLCJ0cmFjZURlcHJlY2F0aW9uIiwidW1hc2siLCJ1cHRpbWUiLCJkaWZmTXMiLCJtb2R1bGVzIiwianNjIiwiV0FSTklOR19QUkVGSVgiLCJtc2ciLCJ1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrIiwiaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2siLCJzZXRVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjayIsInN0YWNrIiwiYmFja3RyYWNlIiwiZmlsZU5hbWUiLCJzb3VyY2VOYW1lIiwibGluZU51bWJlciIsImxpbmUiLCJjb2x1bW5OdW1iZXIiLCJsaW5lT2Zmc2V0IiwiQ2FsbGJhY2tXaXRoQXJncyIsImZ1bmMiLCJmdW4iLCJ0aWNrUXVldWUiLCJpbW1lZGlhdGVRdWV1ZSIsImRyYWluaW5nVGlja1F1ZXVlIiwiZHJhaW5RdWV1ZXNUaW1lb3V0IiwiZHJhaW5UaWNrUXVldWUiLCJ0aWNrIiwic2hpZnQiLCJkcmFpblF1ZXVlcyIsImltbWVkaWF0ZXNSZW1haW5pbmciLCJwcm9jZXNzSW1tZWRpYXRlUXVldWUiLCJpbW1lZGlhdGVEZWFkbGluZSIsImltbWVkaWF0ZSIsImlzV2luMzIiLCJGT1JXQVJEX1NMQVNIIiwiQkFDS1dBUkRfU0xBU0giLCJpc1dpbmRvd3NEZXZpY2VOYW1lIiwiY2hhckNvZGUiLCJfaXNBYnNvbHV0ZSIsImlzUG9zaXgiLCJmaWxlcGF0aCIsImZpcnN0Q2hhciIsInRoaXJkQ2hhciIsIl9kaXJuYW1lIiwiaGFkVHJhaWxpbmciLCJlbmRzV2l0aCIsIl9leHRuYW1lIiwiZW5kSW5kZXgiLCJsYXN0SW5kZXhXaW4zMlNlcGFyYXRvciIsImNoYXIiLCJfYmFzZW5hbWUiLCJleHQiLCJsYXN0Q2hhckNvZGUiLCJiYXNlIiwiX25vcm1hbGl6ZSIsImlzV2luZG93cyIsImhhZExlYWRpbmciLCJzdGFydHNXaXRoIiwiaXNVTkMiLCJwYXJ0cyIsInNlZ21lbnQiLCJub3JtYWxpemVkIiwiYXNzZXJ0U2VnbWVudCIsIl9qb2luIiwicGF0aHMiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiIsIl9kaWRJdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJfcmVzb2x2ZSIsInJlc29sdmVkIiwiaGl0Um9vdCIsIl9yZWxhdGl2ZSIsInVwQ291bnQiLCJyZW1haW5pbmdQYXRoIiwiX3BhcnNlIiwicm9vdCIsImRpciIsImJhc2VMZW5ndGgiLCJ0b1N1YnRyYWN0IiwiZmlyc3RDaGFyQ29kZSIsInRoaXJkQ2hhckNvZGUiLCJfZm9ybWF0IiwicGF0aE9iamVjdCIsInRvTmFtZXNwYWNlZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJXaW4zMlBhdGgiLCJzZXAiLCJkZWxpbWl0ZXIiLCJiYXNlbmFtZSIsIm5vcm1hbGl6ZSIsImV4dG5hbWUiLCJkaXJuYW1lIiwiaXNBYnNvbHV0ZSIsInJlbGF0aXZlIiwiZm9ybWF0IiwiUG9zaXhQYXRoIiwiX2xlbjMiLCJfa2V5MyIsIl9sZW40IiwiX2tleTQiLCJwYXRoIiwid2luMzIiLCJwb3NpeCIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNXaW4zMiQxIiwiUG9zaXhDb25zdGFudHMiLCJVVl9VRFBfUkVVU0VBRERSIiwiZXJybm8iLCJFMkJJRyIsIkVBQ0NFUyIsIkVBRERSSU5VU0UiLCJFQUREUk5PVEFWQUlMIiwiRUFGTk9TVVBQT1JUIiwiRUFHQUlOIiwiRUFMUkVBRFkiLCJFQkFERiIsIkVCQURNU0ciLCJFQlVTWSIsIkVDQU5DRUxFRCIsIkVDSElMRCIsIkVDT05OQUJPUlRFRCIsIkVDT05OUkVGVVNFRCIsIkVDT05OUkVTRVQiLCJFREVBRExLIiwiRURFU1RBRERSUkVRIiwiRURPTSIsIkVEUVVPVCIsIkVFWElTVCIsIkVGQVVMVCIsIkVGQklHIiwiRUhPU1RVTlJFQUNIIiwiRUlEUk0iLCJFSUxTRVEiLCJFSU5QUk9HUkVTUyIsIkVJTlRSIiwiRUlOVkFMIiwiRUlPIiwiRUlTQ09OTiIsIkVJU0RJUiIsIkVMT09QIiwiRU1GSUxFIiwiRU1MSU5LIiwiRU1TR1NJWkUiLCJFTVVMVElIT1AiLCJFTkFNRVRPT0xPTkciLCJFTkVURE9XTiIsIkVORVRSRVNFVCIsIkVORVRVTlJFQUNIIiwiRU5GSUxFIiwiRU5PQlVGUyIsIkVOT0RBVEEiLCJFTk9ERVYiLCJFTk9FTlQiLCJFTk9FWEVDIiwiRU5PTENLIiwiRU5PTElOSyIsIkVOT01FTSIsIkVOT01TRyIsIkVOT1BST1RPT1BUIiwiRU5PU1BDIiwiRU5PU1IiLCJFTk9TVFIiLCJFTk9TWVMiLCJFTk9UQ09OTiIsIkVOT1RESVIiLCJFTk9URU1QVFkiLCJFTk9UU09DSyIsIkVOT1RTVVAiLCJFTk9UVFkiLCJFTlhJTyIsIkVPUE5PVFNVUFAiLCJFT1ZFUkZMT1ciLCJFUEVSTSIsIkVQSVBFIiwiRVBST1RPIiwiRVBST1RPTk9TVVBQT1JUIiwiRVBST1RPVFlQRSIsIkVSQU5HRSIsIkVST0ZTIiwiRVNQSVBFIiwiRVNSQ0giLCJFU1RBTEUiLCJFVElNRSIsIkVUSU1FRE9VVCIsIkVUWFRCU1kiLCJFV09VTERCTE9DSyIsIkVYREVWIiwic2lnbmFscyIsIlNJR0hVUCIsIlNJR0lOVCIsIlNJR1FVSVQiLCJTSUdJTEwiLCJTSUdUUkFQIiwiU0lHQUJSVCIsIlNJR0lPVCIsIlNJR0JVUyIsIlNJR0ZQRSIsIlNJR0tJTEwiLCJTSUdVU1IxIiwiU0lHU0VHViIsIlNJR1VTUjIiLCJTSUdQSVBFIiwiU0lHQUxSTSIsIlNJR1RFUk0iLCJTSUdDSExEIiwiU0lHQ09OVCIsIlNJR1NUT1AiLCJTSUdUU1RQIiwiU0lHVFRJTiIsIlNJR1RUT1UiLCJTSUdVUkciLCJTSUdYQ1BVIiwiU0lHWEZTWiIsIlNJR1ZUQUxSTSIsIlNJR1BST0YiLCJTSUdXSU5DSCIsIlNJR0lPIiwiU0lHSU5GTyIsIlNJR1NZUyIsInByaW9yaXR5IiwiUFJJT1JJVFlfTE9XIiwiUFJJT1JJVFlfQkVMT1dfTk9STUFMIiwiUFJJT1JJVFlfTk9STUFMIiwiUFJJT1JJVFlfQUJPVkVfTk9STUFMIiwiUFJJT1JJVFlfSElHSCIsIlBSSU9SSVRZX0hJR0hFU1QiLCJPUyIsIkVPTCIsImNvbnN0YW50cyIsImNwdXMiLCJwcm9jZXNzb3JDb3VudCIsImFycmF5IiwibW9kZWwiLCJzcGVlZCIsInRpbWVzIiwibmljZSIsInN5cyIsImlkbGUiLCJpcnEiLCJlbmRpYW5uZXNzIiwiQ29kZWMiLCJnZXROYXRpdmVCeXRlT3JkZXIiLCJmcmVlbWVtIiwiYXZhaWxhYmxlTWVtb3J5IiwiZ2V0UHJpb3JpdHkiLCJob21lZGlyIiwiYXBwbGljYXRpb25EYXRhRGlyZWN0b3J5IiwiaG9zdG5hbWUiLCJhZGRyZXNzIiwibG9hZGF2ZyIsIm5ldHdvcmtJbnRlcmZhY2VzIiwicmVsZWFzZSIsInNldFByaW9yaXR5IiwidG1wZGlyIiwidGVtcERpcmVjdG9yeSIsInRvdGFsbWVtIiwidG90YWxNZW1vcnkiLCJ1c2VySW5mbyIsImd1aWQiLCJ1c2VybmFtZSIsInNoZWxsIiwiQXBwbGVNYXAiLCJjcHVNb2RlbEFuZFNwZWVkIiwidHJpbW1lZCIsIm1vZGVsQW5kU3BlZWQiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJXU0FFSU5UUiIsIldTQUVCQURGIiwiV1NBRUFDQ0VTIiwiV1NBRUZBVUxUIiwiV1NBRUlOVkFMIiwiV1NBRU1GSUxFIiwiV1NBRVdPVUxEQkxPQ0siLCJXU0FFSU5QUk9HUkVTUyIsIldTQUVBTFJFQURZIiwiV1NBRU5PVFNPQ0siLCJXU0FFREVTVEFERFJSRVEiLCJXU0FFTVNHU0laRSIsIldTQUVQUk9UT1RZUEUiLCJXU0FFTk9QUk9UT09QVCIsIldTQUVQUk9UT05PU1VQUE9SVCIsIldTQUVTT0NLVE5PU1VQUE9SVCIsIldTQUVPUE5PVFNVUFAiLCJXU0FFUEZOT1NVUFBPUlQiLCJXU0FFQUZOT1NVUFBPUlQiLCJXU0FFQUREUklOVVNFIiwiV1NBRUFERFJOT1RBVkFJTCIsIldTQUVORVRET1dOIiwiV1NBRU5FVFVOUkVBQ0giLCJXU0FFTkVUUkVTRVQiLCJXU0FFQ09OTkFCT1JURUQiLCJXU0FFQ09OTlJFU0VUIiwiV1NBRU5PQlVGUyIsIldTQUVJU0NPTk4iLCJXU0FFTk9UQ09OTiIsIldTQUVTSFVURE9XTiIsIldTQUVUT09NQU5ZUkVGUyIsIldTQUVUSU1FRE9VVCIsIldTQUVDT05OUkVGVVNFRCIsIldTQUVMT09QIiwiV1NBRU5BTUVUT09MT05HIiwiV1NBRUhPU1RET1dOIiwiV1NBRUhPU1RVTlJFQUNIIiwiV1NBRU5PVEVNUFRZIiwiV1NBRVBST0NMSU0iLCJXU0FFVVNFUlMiLCJXU0FFRFFVT1QiLCJXU0FFU1RBTEUiLCJXU0FFUkVNT1RFIiwiV1NBU1lTTk9UUkVBRFkiLCJXU0FWRVJOT1RTVVBQT1JURUQiLCJXU0FOT1RJTklUSUFMSVNFRCIsIldTQUVESVNDT04iLCJXU0FFTk9NT1JFIiwiV1NBRUNBTkNFTExFRCIsIldTQUVJTlZBTElEUFJPQ1RBQkxFIiwiV1NBRUlOVkFMSURQUk9WSURFUiIsIldTQUVQUk9WSURFUkZBSUxFRElOSVQiLCJXU0FTWVNDQUxMRkFJTFVSRSIsIldTQVNFUlZJQ0VfTk9UX0ZPVU5EIiwiV1NBVFlQRV9OT1RfRk9VTkQiLCJXU0FfRV9OT19NT1JFIiwiV1NBX0VfQ0FOQ0VMTEVEIiwiV1NBRVJFRlVTRUQiLCJTSUdCUkVBSyIsInR0eSIsImlzYXR0eSIsIlJlYWRTdHJlYW0iLCJXcml0ZVN0cmVhbSIsIk1PTlRIUyIsInV0aWwiLCJ0eXBlcyIsImlzTnVtYmVyT2JqZWN0IiwiaXNTdHJpbmdPYmplY3QiLCJpc0Jvb2xlYW5PYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzQm94ZWRQcmltaXRpdmUiLCJpc05hdGl2ZUVycm9yIiwiaXNQcm9taXNlIiwidmFsdWVUeXBlIiwiaXNTZXQiLCJpc01hcCIsImlzRGF0ZSIsImlzUmVnZXhwIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc051bWJlciIsImlzUHJpbWl0aXZlIiwiaXNTdHJpbmciLCJpc1VuZGVmaW5lZCIsImRhdGUiLCJ0aW1lIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsInByaW50IiwicHV0cyIsImRlYnVnIiwiaXNCdWZmZXIiLCJpc0Vycm9yIiwiZGVmYXVsdEluc3BlY3RPcHRpb25zIiwic2hvd0hpZGRlbiIsImNvbG9ycyIsImN1c3RvbUluc3BlY3QiLCJzaG93UHJveHkiLCJtYXhBcnJheUxlbmd0aCIsImJyZWFrTGVuZ3RoIiwiY29tcGFjdCIsInNvcnRlZCIsImdldHRlcnMiLCJmb3JtYXRBcnJheSIsImFycmF5TGVuZ3RoIiwiY29uc2VjdXRpdmVFbXB0aWVzIiwiaW5zcGVjdCIsIm1lcmdlZE9wdGlvbnMiLCJyZWN1cnNpb25Db3VudCIsImluZGVudExldmVsIiwib2JqVHlwZSIsIm1lbW8iLCJjb25zdHJ1Y3Rvck5hbWUiLCJwcmVmaXgiLCJoZWFkZXIiLCJzaXplIiwib3duUHJvcGVydGllcyIsInByb3BOYW1lIiwicHJvcERlc2MiLCJfdmFsdWUyIiwiX3ZhbHVlcyIsIl92YWx1ZSIsImluZGVudCIsImZpcnN0QXJnIiwiY3VyQXJnIiwibmV4dENoYXIiLCJwYXJzZUZsb2F0IiwiYVR5cGUiLCJpbmhlcml0cyIsInN1cGVyQ29uc3RydWN0b3IiLCJwcm9taXNpZnkiLCJ3cmFwcGVkIiwiX2xlbjUiLCJfa2V5NSIsImNhbGxiYWNraWZ5IiwiX2xlbjYiLCJfa2V5NiIsImNhdGNoIiwid3JhcHBlZEVycm9yIiwiZGVwcmVjYXRlIiwid2FybmVkIiwiX2xlbjciLCJfa2V5NyIsIm5vb3AiLCJkZWJ1Z2xvZyIsIkRFRkFVTFRfTUVTU0FHRVMiLCJkZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3RFcXVhbCIsImRlZXBFcXVhbCIsImVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJub3REZWVwRXF1YWwiLCJub3RFcXVhbCIsIkNPTVBBUkVfVFlQRSIsIlNUUklDVE5FU1MiLCJTdHJpY3QiLCJMb29zZSIsIkFzc2VydGlvbkVycm9yIiwiX0Vycm9yIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcGVyYXRvciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJhc3NlcnQiLCJ0aHJvd0Vycm9yIiwiY29tcGFyZU1hcHMiLCJzdHJpY3RuZXNzIiwicmVmZXJlbmNlcyIsImxvb3NlQ2hlY2tzIiwiX3N0ZXAkdmFsdWUiLCJfc3RlcDIkdmFsdWUiLCJleHBlY3RlZEtleSIsImV4cGVjdGVkVmFsdWUiLCJmb3VuZCIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zIiwiX2RpZEl0ZXJhdG9yRXJyb3IzIiwiX2l0ZXJhdG9yRXJyb3IzIiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsImRlbGV0ZSIsImNvbXBhcmVTZXRzIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQiLCJfZGlkSXRlcmF0b3JFcnJvcjQiLCJfaXRlcmF0b3JFcnJvcjQiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUiLCJfZGlkSXRlcmF0b3JFcnJvcjUiLCJfaXRlcmF0b3JFcnJvcjUiLCJfaXRlcmF0b3I1IiwiX3N0ZXA1IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYiLCJfZGlkSXRlcmF0b3JFcnJvcjYiLCJfaXRlcmF0b3JFcnJvcjYiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiYWN0dWFsVGFnIiwiZXhwZWN0ZWRUYWciLCJhY3R1YWxQcm90b3R5cGUiLCJleHBlY3RlZFByb3RvdHlwZSIsImNvbXBhcmlzb24iLCJnZXRUaW1lIiwiQm9vbGVhbiIsImFjdHVhbEtleXMiLCJleHBlY3RlZEtleXMiLCJhY3R1YWxTeW1ib2xzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjciLCJfZGlkSXRlcmF0b3JFcnJvcjciLCJfaXRlcmF0b3JFcnJvcjciLCJfaXRlcmF0b3I3IiwiX3N0ZXA3IiwiYWN0dWFsSXNFbnVtZXJhYmxlIiwiZXhwZWN0ZWRJc0VudW1lcmFibGUiLCJtZW1vaXplZEFjdHVhbCIsIm1lbW9pemVkRXhwZWN0ZWQiLCJfYWN0dWFsS2V5cyIsIk5PX0VYQ0VQVElPTiIsImV4ZWN1dGUiLCJpc1Byb21pc2VMaWtlIiwiZXhlY3V0ZVByb21pc2UiLCJfeCIsIl9leGVjdXRlUHJvbWlzZSIsIl9jYWxsZWUzIiwiZm5UeXBlIiwiX2NhbGxlZTMkIiwiX2NvbnRleHQzIiwidDAiLCJ0aHJvd3MiLCJjaGVja0Vycm9yIiwicmVqZWN0cyIsIl9yZWYiLCJfY2FsbGVlIiwiYXN5bmNGbiIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJfeDIiLCJfeDMiLCJfeDQiLCJkb2VzTm90VGhyb3ciLCJkb2VzTm90UmVqZWN0IiwiX3JlZjIiLCJfY2FsbGVlMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsIl94NSIsIl94NiIsIl94NyIsIl9pMiIsIl9rZXlzIiwiaXNQcm90b3R5cGVPZiIsImlmRXJyb3IiLCJzdHJpY3QiLCJrTm9kZU1vZHVsZXNSRSIsImdldFN0cnVjdHVyZWRTdGFjayIsIlN0YWNrVHJhY2VFcnJvciIsInByZXBhcmVTdGFja1RyYWNlIiwidHJhY2UiLCJzdGFja1RyYWNlTGltaXQiLCJpc0luc2lkZU5vZGVNb2R1bGVzIiwic3RhY2tGcmFtZXMiLCJsaW5lcyIsImxpbmVJbmZvIiwiZmlsZW5hbWUiLCJnZXRGaWxlTmFtZSIsImZyYW1lIiwiVElfQ09ERUNfTUFQIiwiQ0hBUlNFVF9VVEY4IiwiQ0hBUlNFVF9VVEYxNkxFIiwiQ0hBUlNFVF9JU09fTEFUSU5fMSIsIkNIQVJTRVRfQVNDSUkiLCJWQUxJRF9FTkNPRElOR1MiLCJkb3VibGVBcnJheSIsInVpbnQ4RG91YmxlQXJyYXkiLCJmbG9hdEFycmF5IiwidWludDhGbG9hdEFycmF5IiwiQnVmZmVyIiwiZW5jb2RpbmdPck9mZnNldCIsImFwaU5hbWUiLCJzaG93RmxhZ2dlZERlcHJlY2F0aW9uIiwiYWxsb2MiLCJ0aUJ1ZmZlciIsIl90aUJ1ZmZlciIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJ0YXJnZXRTdGFydCIsInRhcmdldEVuZCIsInNvdXJjZVN0YXJ0Iiwic291cmNlRW5kIiwiYnVmMSIsInNvdXJjZUxlbmd0aCIsImRlc3QiLCJkZXN0TGVuZ3RoIiwidGFyZ2V0VmFsdWUiLCJnZXRBZGp1c3RlZEluZGV4Iiwic291cmNlVmFsdWUiLCJjb3B5IiwibmV4dEluZGV4IiwiZW50cnlJdGVyYXRvciIsImVxdWFscyIsIm90aGVyQnVmZmVyIiwib2Zmc2V0VHlwZSIsImJ1ZlRvRmlsbFdpdGgiLCJmaWxsQnVmTGVuZ3RoIiwiZmlsbENoYXIiLCJfaW5kZXhPZiIsIm1hdGNoTGVuZ3RoIiwiY3VycmVudEluZGV4IiwidGhpc0xlbmd0aCIsImZpcnN0TWF0Y2giLCJmaXJzdEJ5dGVNYXRjaCIsIm15SXRlcmF0b3IiLCJyZWFkRG91YmxlQkUiLCJjaGVja09mZnNldCIsInJlYWREb3VibGVMRSIsInJlYWRGbG9hdEJFIiwicmVhZEZsb2F0TEUiLCJyZWFkSW50OCIsInVuc2lnbmVkVmFsdWUiLCJyZWFkVUludDgiLCJ1bnNpZ25lZFRvU2lnbmVkIiwicmVhZEludDE2QkUiLCJyZWFkVUludDE2QkUiLCJyZWFkSW50MTZMRSIsInJlYWRVSW50MTZMRSIsInJlYWRJbnQzMkJFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludDMyTEUiLCJyZWFkVUludDMyTEUiLCJyZWFkSW50QkUiLCJyZWFkVUludEJFIiwicmVhZEludExFIiwicmVhZFVJbnRMRSIsIm11bHRpcGxpZXIiLCJuZXdCdWZmZXIiLCJzd2FwMTYiLCJzZWNvbmQiLCJzZXRBZGp1c3RlZEluZGV4Iiwic3dhcDMyIiwidGhpcmQiLCJmb3VydGgiLCJzd2FwNjQiLCJmaWZ0aCIsInNpeHRoIiwic2V2ZW50aCIsImVpZ2h0aCIsImlzRW5jb2RpbmciLCJjbG9uZSIsIlV0aWxzIiwiYmFzZTY0ZW5jb2RlIiwiaGV4U3RyIiwiaGV4IiwibGF0aW4xU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXNjaWkiLCJidWZmZXJUb1VURjE2U3RyaW5nIiwiY29weUJ1ZmZlciIsIndyaXRlRG91YmxlQkUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVGbG9hdExFIiwid3JpdGVJbnQ4IiwiY2hlY2tWYWx1ZSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MzJCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50QkUiLCJtaW5NYXhCYXNlIiwiYnl0ZVZhbHVlIiwid3JpdGVJbnRMRSIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnRMRSIsImFsbG9jVW5zYWZlIiwiYWxsb2NVbnNhZmVTbG93IiwiYnVmIiwidXRmOEJ5dGVMZW5ndGgiLCJidWYyIiwidG90YWxMZW5ndGgiLCJfaTMiLCJiYXNlNjRkZWNvZGUiLCJibG9iU3RyZWFtIiwiU3RyZWFtIiwiY3JlYXRlU3RyZWFtIiwiTU9ERV9SRUFEIiwicmVhZEFsbCIsInN0cmluZ1RvSGV4Qnl0ZXMiLCJnZXRUaUNvZGVjQ2hhcnNldCIsIl9idWZmZXIiLCJfbGVuZ3RoIiwicG9vbFNpemUiLCJCdWZmZXJNb2R1bGUiLCJ0cmFuc2NvZGUiLCJfc291cmNlIiwiX2Zyb21FbmNvZGluZyIsIl90b0VuY29kaW5nIiwiSU5TUEVDVF9NQVhfQllURVMiLCJrTWF4TGVuZ3RoIiwia1N0cmluZ01heExlbmd0aCIsIk1BWF9MRU5HVEgiLCJNQVhfU1RSSU5HX0xFTkdUSCIsInNpbmdsZUJ5dGUiLCJiaXRMZW5ndGgiLCJtYXhQb3NpdGl2ZVZhbHVlIiwibWF4VW5zaWduZWRWYWx1ZSIsInNyY0xlbmd0aCIsImRlc3RJbmRleCIsImJ5dGUxIiwiYnl0ZTIiLCJjb2RlX3VuaXQiLCJmcm9tQ29kZVBvaW50IiwiYnl0ZUFycmF5IiwibnVtZXJpY1ZhbHVlIiwic3Vic3RyIiwiYXJyYXlJbmRleEhhbmRsZXIiLCJwcm9wS2V5IiwibnVtIiwiaXNTYWZlSW50ZWdlciIsImVuZE9mZnNldCIsImJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCIsIm5vZGVNb2R1bGVzQ2hlY2tDb3VudGVyIiwiYnVmZmVyV2FybmluZyIsImJpbmRpbmdzIiwicmVkaXJlY3RzIiwiaXNIaWphY2thYmxlTW9kdWxlSWQiLCJvcmlnaW5hbFJlcXVpcmUiLCJtb2R1bGVJZCIsIm9yaWdpbmFsTW9kdWxlUmVxdWlyZSIsIk1vZHVsZSIsInJlZ2lzdGVyIiwid2FybiIsInJlZGlyZWN0IiwiZmV0Y2hTY3JpcHRzRnJvbUpzb24iLCJKU09OX0ZJTEVfTkFNRSIsInNldHRpbmdzIiwic2NyaXB0cyIsImZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkiLCJyZXNvdXJjZURpcmVjdG9yeSIsInJlc291cmNlRGlyZWN0b3J5UGF0aExlbmd0aCIsIm5hdGl2ZVBhdGgiLCJib290c3RyYXBTY3JpcHRzIiwibG9hZEZyb20iLCJmaWxlIiwiaXNEaXJlY3RvcnkiLCJmaWxlTmFtZUFycmF5IiwiZ2V0RGlyZWN0b3J5TGlzdGluZyIsImJvb3RzdHJhcFBhdGgiLCJsb2FkQXN5bmMiLCJmaW5pc2hlZCIsImxvYWRCb290c3RyYXBTY3JpcHRzIiwiYm9vdHN0cmFwSW5kZXgiLCJkb0xvYWQiLCJib290c3RyYXAiLCJvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkIiwiYnVpbGRIYXNoIiwiZmlyZUV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxTQUFTQSxvQkFBVCxDQUE4QkMsRUFBOUIsRUFBa0NDLE1BQWxDLEVBQTBDO0FBQ3pDLFNBQU9BLE1BQU0sR0FBRyxFQUFFQyxPQUFPLEVBQUUsRUFBWCxFQUFULEVBQTBCRixFQUFFLENBQUNDLE1BQUQsRUFBU0EsTUFBTSxDQUFDQyxPQUFoQixDQUE1QixFQUFzREQsTUFBTSxDQUFDQyxPQUFwRTtBQUNBOztBQUVELElBQUlDLE9B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QyxPQUF2RixFQUFnRyxHQUFoRyxFQUFxR2dELE1BQXJHLENBQTRHc2dDLEVBQUUsQ0FBQ3E0QixTQUEvRyxFQUEwSCxHQUExSCxDQUFaLEUsQ0FBNkk7QUFDN0k7O0FBRUEsSUFBSTtBQUNGNzJCLEVBQUFBLE9BQU8sQ0FBQyxzQkFBRCxDQUFQO0FBQ0QsQ0FGRCxDQUVFLE9BQU9ya0MsQ0FBUCxFQUFVLENBQUUsQyxDQUFDO0FBQ2YyNkQsU0FBUyxDQUFDLFlBQVk7QUFDcEI7QUFDQTtBQUNBdDJCLEVBQUFBLE9BQU8sQ0FBQyxPQUFELENBQVAsQ0FIb0IsQ0FHRjtBQUNsQjtBQUNBOzs7QUFHQXhCLEVBQUFBLEVBQUUsQ0FBQ3NCLEdBQUgsQ0FBT2czQixTQUFQLENBQWlCLFNBQWpCO0FBQ0QsQ0FUUSxDQUFUIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIF9nbG9iYWwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG4gIHZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aCA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICBpZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59KTtcblxudmFyIF9jb3JlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHZlcnNpb246ICcyLjYuNSdcbiAgfTtcbiAgaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn0pO1xudmFyIF9jb3JlXzEgPSBfY29yZS52ZXJzaW9uO1xuXG52YXIgX2lzT2JqZWN0ID0gZnVuY3Rpb24gX2lzT2JqZWN0KGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgX2FuT2JqZWN0ID0gZnVuY3Rpb24gX2FuT2JqZWN0KGl0KSB7XG4gIGlmICghX2lzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgX2ZhaWxzID0gZnVuY3Rpb24gX2ZhaWxzKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIF9kZXNjcmlwdG9ycyA9ICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBkb2N1bWVudCQxID0gX2dsb2JhbC5kb2N1bWVudDsgLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cbnZhciBpcyA9IF9pc09iamVjdChkb2N1bWVudCQxKSAmJiBfaXNPYmplY3QoZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KTtcblxudmFyIF9kb21DcmVhdGUgPSBmdW5jdGlvbiBfZG9tQ3JlYXRlKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbnZhciBfaWU4RG9tRGVmaW5lID0gIV9kZXNjcmlwdG9ycyAmJiAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZG9tQ3JlYXRlKCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcblxudmFyIF90b1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpdCwgUykge1xuICBpZiAoIV9pc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhX2lzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZiA9IF9kZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgX2FuT2JqZWN0KE8pO1xuICBQID0gX3RvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBfYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChfaWU4RG9tRGVmaW5lKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbnZhciBfb2JqZWN0RHAgPSB7XG4gIGY6IGZcbn07XG5cbnZhciBfcHJvcGVydHlEZXNjID0gZnVuY3Rpb24gX3Byb3BlcnR5RGVzYyhiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgX2hpZGUgPSBfZGVzY3JpcHRvcnMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBfb2JqZWN0RHAuZihvYmplY3QsIGtleSwgX3Byb3BlcnR5RGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG52YXIgX2hhcyA9IGZ1bmN0aW9uIF9oYXMoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cbnZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xuXG52YXIgX3VpZCA9IGZ1bmN0aW9uIF91aWQoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG52YXIgX2xpYnJhcnkgPSBmYWxzZTtcblxudmFyIF9zaGFyZWQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbiAgdmFyIHN0b3JlID0gX2dsb2JhbFtTSEFSRURdIHx8IChfZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG4gIChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG4gIH0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgICB2ZXJzaW9uOiBfY29yZS52ZXJzaW9uLFxuICAgIG1vZGU6ICAnZ2xvYmFsJyxcbiAgICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xuICB9KTtcbn0pO1xuXG52YXIgX2Z1bmN0aW9uVG9TdHJpbmcgPSBfc2hhcmVkKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuXG52YXIgX3JlZGVmaW5lID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgU1JDID0gX3VpZCgnc3JjJyk7XG4gIHZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xuICB2YXIgVFBMID0gKCcnICsgX2Z1bmN0aW9uVG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbiAgX2NvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBfZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcbiAgfTtcblxuICAobW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoaXNGdW5jdGlvbikgX2hhcyh2YWwsICduYW1lJykgfHwgX2hpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gICAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gICAgaWYgKGlzRnVuY3Rpb24pIF9oYXModmFsLCBTUkMpIHx8IF9oaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG5cbiAgICBpZiAoTyA9PT0gX2dsb2JhbCkge1xuICAgICAgT1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICAgIGRlbGV0ZSBPW2tleV07XG4gICAgICBfaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICAgIE9ba2V5XSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2hpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG5cbiAgfSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCBfZnVuY3Rpb25Ub1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn0pO1xuXG52YXIgX2FGdW5jdGlvbiA9IGZ1bmN0aW9uIF9hRnVuY3Rpb24oaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgX2N0eCA9IGZ1bmN0aW9uIF9jdHgoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBfYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuXG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgICAgfTtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpXG4gIC8qIC4uLmFyZ3MgKi9cbiAge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICRleHBvcnQodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IF9nbG9iYWwgOiBJU19TVEFUSUMgPyBfZ2xvYmFsW25hbWVdIHx8IChfZ2xvYmFsW25hbWVdID0ge30pIDogKF9nbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gX2NvcmUgOiBfY29yZVtuYW1lXSB8fCAoX2NvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7IC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG5cbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldOyAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuXG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBfY3R4KG91dCwgX2dsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBfY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7IC8vIGV4dGVuZCBnbG9iYWxcblxuICAgIGlmICh0YXJnZXQpIF9yZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTsgLy8gZXhwb3J0XG5cbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgX2hpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcblxuX2dsb2JhbC5jb3JlID0gX2NvcmU7IC8vIHR5cGUgYml0bWFwXG5cbiRleHBvcnQuRiA9IDE7IC8vIGZvcmNlZFxuXG4kZXhwb3J0LkcgPSAyOyAvLyBnbG9iYWxcblxuJGV4cG9ydC5TID0gNDsgLy8gc3RhdGljXG5cbiRleHBvcnQuUCA9IDg7IC8vIHByb3RvXG5cbiRleHBvcnQuQiA9IDE2OyAvLyBiaW5kXG5cbiRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXG5cbiRleHBvcnQuVSA9IDY0OyAvLyBzYWZlXG5cbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxuXG52YXIgX2V4cG9ydCA9ICRleHBvcnQ7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgX2NvZiA9IGZ1bmN0aW9uIF9jb2YoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cbnZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIF9jb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBfdG9JbnRlZ2VyID0gZnVuY3Rpb24gX3RvSW50ZWdlcihpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxudmFyIF90b0xlbmd0aCA9IGZ1bmN0aW9uIF90b0xlbmd0aChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKF90b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciBfd2tzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgc3RvcmUgPSBfc2hhcmVkKCd3a3MnKTtcbiAgdmFyIFN5bWJvbCA9IF9nbG9iYWwuU3ltYm9sO1xuICB2YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxuICB2YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9IFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogX3VpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xuICB9O1xuXG4gICRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG59KTtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gX3drcygnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBfY3R4KG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIHNwcmVhZGFibGU7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG4gICAgICBzcHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICAgIGlmIChfaXNPYmplY3QoZWxlbWVudCkpIHtcbiAgICAgICAgc3ByZWFkYWJsZSA9IGVsZW1lbnRbSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICAgICAgICBzcHJlYWRhYmxlID0gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogX2lzQXJyYXkoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcHJlYWRhYmxlICYmIGRlcHRoID4gMCkge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgX3RvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MWZmZmZmZmZmZmZmZmYpIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG5cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufVxuXG52YXIgX2ZsYXR0ZW5JbnRvQXJyYXkgPSBmbGF0dGVuSW50b0FycmF5O1xuXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxudmFyIF9kZWZpbmVkID0gZnVuY3Rpb24gX2RlZmluZWQoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgX3RvT2JqZWN0ID0gZnVuY3Rpb24gX3RvT2JqZWN0KGl0KSB7XG4gIHJldHVybiBPYmplY3QoX2RlZmluZWQoaXQpKTtcbn07XG5cbnZhciBTUEVDSUVTID0gX3drcygnc3BlY2llcycpO1xuXG52YXIgX2FycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gX2FycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuXG4gIGlmIChfaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7IC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG5cbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgX2lzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChfaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cbnZhciBfYXJyYXlTcGVjaWVzQ3JlYXRlID0gZnVuY3Rpb24gX2FycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKF9hcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG52YXIgVU5TQ09QQUJMRVMgPSBfd2tzKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSBfaGlkZShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xuXG52YXIgX2FkZFRvVW5zY29wYWJsZXMgPSBmdW5jdGlvbiBfYWRkVG9VbnNjb3BhYmxlcyhrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5fZXhwb3J0KF9leHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHZhciBPID0gX3RvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4sIEE7XG4gICAgX2FGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICBzb3VyY2VMZW4gPSBfdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIEEgPSBfYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIF9mbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5fYWRkVG9VbnNjb3BhYmxlcygnZmxhdE1hcCcpO1xuXG52YXIgX2l0ZXJDYWxsID0gZnVuY3Rpb24gX2l0ZXJDYWxsKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKF9hbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTsgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBfYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG52YXIgX2l0ZXJhdG9ycyA9IHt9O1xuXG52YXIgSVRFUkFUT1IgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8kMSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIF9pc0FycmF5SXRlciA9IGZ1bmN0aW9uIF9pc0FycmF5SXRlcihpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoX2l0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90byQxW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxudmFyIF9jcmVhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9jcmVhdGVQcm9wZXJ0eShvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSBfb2JqZWN0RHAuZihvYmplY3QsIGluZGV4LCBfcHJvcGVydHlEZXNjKDAsIHZhbHVlKSk7ZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG52YXIgVEFHID0gX3drcygndG9TdHJpbmdUYWcnKTsgLy8gRVMzIHdyb25nIGhlcmVcblxudmFyIEFSRyA9IF9jb2YoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXJndW1lbnRzO1xufSgpKSA9PSAnQXJndW1lbnRzJzsgLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcblxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIHRyeUdldChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG59O1xuXG52YXIgX2NsYXNzb2YgPSBmdW5jdGlvbiBfY2xhc3NvZihpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICA6IEFSRyA/IF9jb2YoTykgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICA6IChCID0gX2NvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG52YXIgSVRFUkFUT1IkMSA9IF93a3MoJ2l0ZXJhdG9yJyk7XG5cbnZhciBjb3JlX2dldEl0ZXJhdG9yTWV0aG9kID0gX2NvcmUuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SJDFdIHx8IGl0WydAQGl0ZXJhdG9yJ10gfHwgX2l0ZXJhdG9yc1tfY2xhc3NvZihpdCldO1xufTtcblxudmFyIElURVJBVE9SJDIgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1IkMl0oKTtcblxuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblxuXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyAyO1xuICB9KTtcbn0gY2F0Y2ggKGUpIHtcbiAgLyogZW1wdHkgKi9cbn1cblxudmFyIF9pdGVyRGV0ZWN0ID0gZnVuY3Rpb24gX2l0ZXJEZXRlY3QoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SJDJdKCk7XG5cbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBzYWZlID0gdHJ1ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXJyW0lURVJBVE9SJDJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfTtcblxuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gc2FmZTtcbn07XG5cbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIV9pdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gIEFycmF5LmZyb20oaXRlcik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlXG4gIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi9cbiAgKSB7XG4gICAgdmFyIE8gPSBfdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBjb3JlX2dldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gX2N0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpOyAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcblxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBfaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIF9jcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gX2l0ZXJDYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gX3RvTGVuZ3RoKE8ubGVuZ3RoKTtcblxuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBfY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cbnZhciBfaW9iamVjdCA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBfY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG52YXIgX3RvSW9iamVjdCA9IGZ1bmN0aW9uIF90b0lvYmplY3QoaXQpIHtcbiAgcmV0dXJuIF9pb2JqZWN0KF9kZWZpbmVkKGl0KSk7XG59O1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluJDEgPSBNYXRoLm1pbjtcblxudmFyIF90b0Fic29sdXRlSW5kZXggPSBmdW5jdGlvbiBfdG9BYnNvbHV0ZUluZGV4KGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSBfdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4kMShpbmRleCwgbGVuZ3RoKTtcbn07XG5cbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG5cbnZhciBfYXJyYXlJbmNsdWRlcyA9IGZ1bmN0aW9uIF9hcnJheUluY2x1ZGVzKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IF90b0lvYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBfdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IF90b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTsgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTsgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyICRpbmNsdWRlcyA9IF9hcnJheUluY2x1ZGVzKHRydWUpO1xuX2V4cG9ydChfZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsXG4gIC8qICwgZnJvbUluZGV4ID0gMCAqL1xuICApIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuX2FkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG5cbnZhciBfc3RyaWN0TWV0aG9kID0gZnVuY3Rpb24gX3N0cmljdE1ldGhvZChtZXRob2QsIGFyZykge1xuICByZXR1cm4gISFtZXRob2QgJiYgX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG5cbnZhciAkc29ydCA9IFtdLnNvcnQ7XG52YXIgdGVzdCA9IFsxLCAyLCAzXTtcbl9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5GICogKF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggYnVnXG4gIHRlc3Quc29ydChudWxsKTsgLy8gT2xkIFdlYktpdFxufSkgfHwgIV9zdHJpY3RNZXRob2QoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/ICRzb3J0LmNhbGwoX3RvT2JqZWN0KHRoaXMpKSA6ICRzb3J0LmNhbGwoX3RvT2JqZWN0KHRoaXMpLCBfYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcblxudmFyIFNQRUNJRVMkMSA9IF93a3MoJ3NwZWNpZXMnKTtcblxudmFyIF9zZXRTcGVjaWVzID0gZnVuY3Rpb24gX3NldFNwZWNpZXMoS0VZKSB7XG4gIHZhciBDID0gX2dsb2JhbFtLRVldO1xuICBpZiAoX2Rlc2NyaXB0b3JzICYmIEMgJiYgIUNbU1BFQ0lFUyQxXSkgX29iamVjdERwLmYoQywgU1BFQ0lFUyQxLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn07XG5cbl9zZXRTcGVjaWVzKCdBcnJheScpO1xuXG5fZXhwb3J0KF9leHBvcnQuUCArIF9leHBvcnQuRiAqIF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHtcbiAgICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pICE9PSAxO1xufSksICdEYXRlJywge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgdmFyIE8gPSBfdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHB2ID0gX3RvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuXG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbnZhciBfZGF0ZVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gX2RhdGVUb1ByaW1pdGl2ZShoaW50KSB7XG4gIGlmIChoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiBfdG9QcmltaXRpdmUoX2FuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuXG52YXIgVE9fUFJJTUlUSVZFID0gX3drcygndG9QcmltaXRpdmUnKTtcbnZhciBwcm90byA9IERhdGUucHJvdG90eXBlO1xuaWYgKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSkgX2hpZGUocHJvdG8sIFRPX1BSSU1JVElWRSwgX2RhdGVUb1ByaW1pdGl2ZSk7XG5cbnZhciBzaGFyZWQgPSBfc2hhcmVkKCdrZXlzJyk7XG5cbnZhciBfc2hhcmVkS2V5ID0gZnVuY3Rpb24gX3NoYXJlZEtleShrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IF91aWQoa2V5KSk7XG59O1xuXG52YXIgSUVfUFJPVE8gPSBfc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxudmFyIF9vYmplY3RHcG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IF90b09iamVjdChPKTtcbiAgaWYgKF9oYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG5cbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH1cblxuICByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cbnZhciBIQVNfSU5TVEFOQ0UgPSBfd2tzKCdoYXNJbnN0YW5jZScpO1xudmFyIEZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuXG5pZiAoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpIF9vYmplY3REcC5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwge1xuICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoTykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFfaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIV9pc09iamVjdCh0aGlzLnByb3RvdHlwZSkpIHJldHVybiBPIGluc3RhbmNlb2YgdGhpczsgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcblxuICAgIHdoaWxlIChPID0gX29iamVjdEdwbyhPKSkge1xuICAgICAgaWYgKHRoaXMucHJvdG90eXBlID09PSBPKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pO1xuXG52YXIgYXJyYXlJbmRleE9mID0gX2FycmF5SW5jbHVkZXMoZmFsc2UpO1xudmFyIElFX1BST1RPJDEgPSBfc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgX29iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIF9vYmplY3RLZXlzSW50ZXJuYWwob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IF90b0lvYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gTykge1xuICAgIGlmIChrZXkgIT0gSUVfUFJPVE8kMSkgX2hhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuXG5cbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoX2hhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xudmFyIF9lbnVtQnVnS2V5cyA9ICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnLnNwbGl0KCcsJyk7XG5cbnZhciBfb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gX29iamVjdEtleXNJbnRlcm5hbChPLCBfZW51bUJ1Z0tleXMpO1xufTtcblxudmFyIF9vYmplY3REcHMgPSBfZGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBfYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gX29iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcblxuICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgIF9vYmplY3REcC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICB9XG5cbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZG9jdW1lbnQkMiA9IF9nbG9iYWwuZG9jdW1lbnQ7XG5cbnZhciBfaHRtbCA9IGRvY3VtZW50JDIgJiYgZG9jdW1lbnQkMi5kb2N1bWVudEVsZW1lbnQ7XG5cbnZhciBJRV9QUk9UTyQyID0gX3NoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7XG4gIC8qIGVtcHR5ICovXG59O1xuXG52YXIgUFJPVE9UWVBFJDEgPSAncHJvdG90eXBlJzsgLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXG52YXIgX2NyZWF0ZURpY3QgPSBmdW5jdGlvbiBjcmVhdGVEaWN0KCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gX2RvbUNyZWF0ZSgnaWZyYW1lJyk7XG4gIHZhciBpID0gX2VudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIF9odG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBfY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGRlbGV0ZSBfY3JlYXRlRGljdFtQUk9UT1RZUEUkMV1bX2VudW1CdWdLZXlzW2ldXTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlRGljdCgpO1xufTtcblxudmFyIF9vYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEUkMV0gPSBfYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFJDFdID0gbnVsbDsgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuXG4gICAgcmVzdWx0W0lFX1BST1RPJDJdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IF9jcmVhdGVEaWN0KCk7XG5cbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IF9vYmplY3REcHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciBfcmVkZWZpbmVBbGwgPSBmdW5jdGlvbiBfcmVkZWZpbmVBbGwodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIF9yZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBfYW5JbnN0YW5jZSA9IGZ1bmN0aW9uIF9hbkluc3RhbmNlKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH1cblxuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgX2Zvck9mID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgQlJFQUsgPSB7fTtcbiAgdmFyIFJFVFVSTiA9IHt9O1xuXG4gIHZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICAgIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICB9IDogY29yZV9nZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgdmFyIGYgPSBfY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTsgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG5cbiAgICBpZiAoX2lzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gX3RvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICByZXN1bHQgPSBlbnRyaWVzID8gZihfYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICAgIHJlc3VsdCA9IF9pdGVyQ2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuICBleHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbn0pO1xuXG52YXIgZGVmID0gX29iamVjdERwLmY7XG52YXIgVEFHJDEgPSBfd2tzKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgX3NldFRvU3RyaW5nVGFnID0gZnVuY3Rpb24gX3NldFRvU3RyaW5nVGFnKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFfaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUckMSkpIGRlZihpdCwgVEFHJDEsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHRhZ1xuICB9KTtcbn07XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyAvLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuXG5faGlkZShJdGVyYXRvclByb3RvdHlwZSwgX3drcygnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pO1xuXG52YXIgX2l0ZXJDcmVhdGUgPSBmdW5jdGlvbiBfaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBfb2JqZWN0Q3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7XG4gICAgbmV4dDogX3Byb3BlcnR5RGVzYygxLCBuZXh0KVxuICB9KTtcbiAgX3NldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxudmFyIElURVJBVE9SJDMgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG5cbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uIHJldHVyblRoaXMoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIF9pdGVyRGVmaW5lID0gZnVuY3Rpb24gX2l0ZXJEZWZpbmUoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIF9pdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gZ2V0TWV0aG9kKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcblxuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpO1xuICAgICAgICB9O1xuXG4gICAgICBjYXNlIFZBTFVFUzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SJDNdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTsgLy8gRml4IG5hdGl2ZVxuXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBfb2JqZWN0R3BvKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG5cbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgX3NldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpOyAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcblxuICAgICAgaWYgKCB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1IkM10gIT0gJ2Z1bmN0aW9uJykgX2hpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDMsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfSAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG5cblxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG5cbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSAvLyBEZWZpbmUgaXRlcmF0b3JcblxuXG4gIGlmICggKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SJDNdKSkge1xuICAgIF9oaWRlKHByb3RvLCBJVEVSQVRPUiQzLCAkZGVmYXVsdCk7XG4gIH0gLy8gUGx1ZyBmb3IgbGlicmFyeVxuXG5cbiAgX2l0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBfaXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSBfcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgX2V4cG9ydChfZXhwb3J0LlAgKyBfZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgX2l0ZXJTdGVwID0gZnVuY3Rpb24gX2l0ZXJTdGVwKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6ICEhZG9uZVxuICB9O1xufTtcblxudmFyIF9tZXRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgTUVUQSA9IF91aWQoJ21ldGEnKTtcbiAgdmFyIHNldERlc2MgPSBfb2JqZWN0RHAuZjtcbiAgdmFyIGlkID0gMDtcblxuICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdmFyIEZSRUVaRSA9ICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG4gIH0pO1xuXG4gIHZhciBzZXRNZXRhID0gZnVuY3Rpb24gc2V0TWV0YShpdCkge1xuICAgIHNldERlc2MoaXQsIE1FVEEsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGk6ICdPJyArICsraWQsXG4gICAgICAgIC8vIG9iamVjdCBJRFxuICAgICAgICB3OiB7fSAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGZhc3RLZXkgPSBmdW5jdGlvbiBmYXN0S2V5KGl0LCBjcmVhdGUpIHtcbiAgICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gICAgaWYgKCFfaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuXG4gICAgaWYgKCFfaGFzKGl0LCBNRVRBKSkge1xuICAgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJzsgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblxuICAgICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7IC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cbiAgICAgIHNldE1ldGEoaXQpOyAvLyByZXR1cm4gb2JqZWN0IElEXG4gICAgfVxuXG4gICAgcmV0dXJuIGl0W01FVEFdLmk7XG4gIH07XG5cbiAgdmFyIGdldFdlYWsgPSBmdW5jdGlvbiBnZXRXZWFrKGl0LCBjcmVhdGUpIHtcbiAgICBpZiAoIV9oYXMoaXQsIE1FVEEpKSB7XG4gICAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTsgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblxuICAgICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTsgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblxuICAgICAgc2V0TWV0YShpdCk7IC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gICAgfVxuXG4gICAgcmV0dXJuIGl0W01FVEFdLnc7XG4gIH07IC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xuXG5cbiAgdmFyIG9uRnJlZXplID0gZnVuY3Rpb24gb25GcmVlemUoaXQpIHtcbiAgICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFfaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gICAgcmV0dXJuIGl0O1xuICB9O1xuXG4gIHZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgS0VZOiBNRVRBLFxuICAgIE5FRUQ6IGZhbHNlLFxuICAgIGZhc3RLZXk6IGZhc3RLZXksXG4gICAgZ2V0V2VhazogZ2V0V2VhayxcbiAgICBvbkZyZWV6ZTogb25GcmVlemVcbiAgfTtcbn0pO1xudmFyIF9tZXRhXzEgPSBfbWV0YS5LRVk7XG52YXIgX21ldGFfMiA9IF9tZXRhLk5FRUQ7XG52YXIgX21ldGFfMyA9IF9tZXRhLmZhc3RLZXk7XG52YXIgX21ldGFfNCA9IF9tZXRhLmdldFdlYWs7XG52YXIgX21ldGFfNSA9IF9tZXRhLm9uRnJlZXplO1xuXG52YXIgX3ZhbGlkYXRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIF92YWxpZGF0ZUNvbGxlY3Rpb24oaXQsIFRZUEUpIHtcbiAgaWYgKCFfaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgZFAkMSA9IF9vYmplY3REcC5mO1xudmFyIGZhc3RLZXkgPSBfbWV0YS5mYXN0S2V5O1xudmFyIFNJWkUgPSBfZGVzY3JpcHRvcnMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiBnZXRFbnRyeSh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdOyAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcblxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG52YXIgX2NvbGxlY3Rpb25TdHJvbmcgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgX2FuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgLy8gY29sbGVjdGlvbiB0eXBlXG5cbiAgICAgIHRoYXQuX2kgPSBfb2JqZWN0Q3JlYXRlKG51bGwpOyAvLyBpbmRleFxuXG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAvLyBmaXJzdCBlbnRyeVxuXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsYXN0IGVudHJ5XG5cbiAgICAgIHRoYXRbU0laRV0gPSAwOyAvLyBzaXplXG5cbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIF9mb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgX3JlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAgICAgLyogLCB0aGF0ID0gdW5kZWZpbmVkICovXG4gICAgICApIHtcbiAgICAgICAgX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBfY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuXG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpOyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkoX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoX2Rlc2NyaXB0b3JzKSBkUCQxKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiBkZWYodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4OyAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlOyAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksXG4gICAgICAgIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSxcbiAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCxcbiAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLFxuICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlIC8vIDwtIHJlbW92ZWRcblxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrOyAvLyBhZGQgdG8gaW5kZXhcblxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiBzZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgIF9pdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IF92YWxpZGF0ZUNvbGxlY3Rpb24oaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcblxuICAgICAgdGhpcy5fayA9IGtpbmQ7IC8vIGtpbmRcblxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sOyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIHtcbiAgICAgICAgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgfSAvLyBnZXQgbmV4dCBlbnRyeVxuXG5cbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfaXRlclN0ZXAoMSk7XG4gICAgICB9IC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcblxuXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBfaXRlclN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIF9pdGVyU3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBfaXRlclN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7IC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG5cbiAgICBfc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxudmFyIGYkMSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9vYmplY3RQaWUgPSB7XG4gIGY6IGYkMVxufTtcblxudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGYkMiA9IF9kZXNjcmlwdG9ycyA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gX3RvSW9iamVjdChPKTtcbiAgUCA9IF90b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKF9pZThEb21EZWZpbmUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG4gIGlmIChfaGFzKE8sIFApKSByZXR1cm4gX3Byb3BlcnR5RGVzYyghX29iamVjdFBpZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbnZhciBfb2JqZWN0R29wZCA9IHtcbiAgZjogZiQyXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhPLCBwcm90bykge1xuICBfYW5PYmplY3QoTyk7XG4gIGlmICghX2lzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcblxudmFyIF9zZXRQcm90byA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgIHRyeSB7XG4gICAgICBzZXQgPSBfY3R4KEZ1bmN0aW9uLmNhbGwsIF9vYmplY3RHb3BkLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYnVnZ3kgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO2Vsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgIHJldHVybiBPO1xuICAgIH07XG4gIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxudmFyIHNldFByb3RvdHlwZU9mID0gX3NldFByb3RvLnNldDtcblxudmFyIF9pbmhlcml0SWZSZXF1aXJlZCA9IGZ1bmN0aW9uIF9pbmhlcml0SWZSZXF1aXJlZCh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuXG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIF9pc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9XG5cbiAgcmV0dXJuIHRoYXQ7XG59O1xuXG52YXIgX2NvbGxlY3Rpb24gPSBmdW5jdGlvbiBfY29sbGVjdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IF9nbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcblxuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gZml4TWV0aG9kKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgX3JlZGVmaW5lKHByb3RvLCBLRVksIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gSVNfV0VBSyAmJiAhX2lzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICByZXR1cm4gSVNfV0VBSyAmJiAhX2lzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICByZXR1cm4gSVNfV0VBSyAmJiAhX2lzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkge1xuICAgICAgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSA6IGZ1bmN0aW9uIHNldChhLCBiKSB7XG4gICAgICBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICBfcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIF9tZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDKCk7IC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcblxuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7IC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGluc3RhbmNlLmhhcygxKTtcbiAgICB9KTsgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuXG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSBfaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IEMoaXRlcik7XG4gICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG5cbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuXG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBfYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IF9pbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBfZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG5cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG5cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTsgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcblxuICAgIGlmIChJU19XRUFLICYmIHByb3RvLmNsZWFyKSBkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBfc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG4gIE9bTkFNRV0gPSBDO1xuICBfZXhwb3J0KF9leHBvcnQuRyArIF9leHBvcnQuVyArIF9leHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG4gIHJldHVybiBDO1xufTtcblxudmFyIE1BUCA9ICdNYXAnOyAvLyAyMy4xIE1hcCBPYmplY3RzXG5cbnZhciBlczZfbWFwID0gX2NvbGxlY3Rpb24oTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gX2NvbGxlY3Rpb25TdHJvbmcuZ2V0RW50cnkoX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9jb2xsZWN0aW9uU3Ryb25nLmRlZihfdmFsaWRhdGVDb2xsZWN0aW9uKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgX2NvbGxlY3Rpb25TdHJvbmcsIHRydWUpO1xuXG52YXIgZiQzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfb2JqZWN0R29wcyA9IHtcbiAgZjogZiQzXG59O1xuXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247IC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuXG52YXIgX29iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBCW2tdID0gaztcbiAgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IF90b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gX29iamVjdEdvcHMuZjtcbiAgdmFyIGlzRW51bSA9IF9vYmplY3RQaWUuZjtcblxuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBfaW9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IF9vYmplY3RLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IF9vYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GLCAnT2JqZWN0Jywge1xuICBhc3NpZ246IF9vYmplY3RBc3NpZ25cbn0pO1xuXG52YXIgaXNFbnVtID0gX29iamVjdFBpZS5mO1xuXG52YXIgX29iamVjdFRvQXJyYXkgPSBmdW5jdGlvbiBfb2JqZWN0VG9BcnJheShpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gX3RvSW9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBfb2JqZWN0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcbiAgICAgIGlmIChpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG52YXIgJGVudHJpZXMgPSBfb2JqZWN0VG9BcnJheSh0cnVlKTtcbl9leHBvcnQoX2V4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7XG5cbnZhciBoaWRkZW5LZXlzID0gX2VudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG52YXIgZiQ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBfb2JqZWN0S2V5c0ludGVybmFsKE8sIGhpZGRlbktleXMpO1xufTtcblxudmFyIF9vYmplY3RHb3BuID0ge1xuICBmOiBmJDRcbn07XG5cbnZhciBSZWZsZWN0JDEgPSBfZ2xvYmFsLlJlZmxlY3Q7XG5cbnZhciBfb3duS2V5cyA9IFJlZmxlY3QkMSAmJiBSZWZsZWN0JDEub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gX29iamVjdEdvcG4uZihfYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBfb2JqZWN0R29wcy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5fZXhwb3J0KF9leHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IF90b0lvYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IF9vYmplY3RHb3BkLmY7XG4gICAgdmFyIGtleXMgPSBfb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG5cbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgX2NyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIHRlc3QkMSA9IHt9O1xudGVzdCQxW193a3MoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuXG5pZiAodGVzdCQxICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIF9yZWRlZmluZShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIF9jbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxudmFyICR2YWx1ZXMgPSBfb2JqZWN0VG9BcnJheShmYWxzZSk7XG5fZXhwb3J0KF9leHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuXG52YXIgU1BFQ0lFUyQyID0gX3drcygnc3BlY2llcycpO1xuXG52YXIgX3NwZWNpZXNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIF9zcGVjaWVzQ29uc3RydWN0b3IoTywgRCkge1xuICB2YXIgQyA9IF9hbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBfYW5PYmplY3QoQylbU1BFQ0lFUyQyXSkgPT0gdW5kZWZpbmVkID8gRCA6IF9hRnVuY3Rpb24oUyk7XG59O1xuXG4vLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbnZhciBfaW52b2tlID0gZnVuY3Rpb24gX2ludm9rZShmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB1biA/IGZuKCkgOiBmbi5jYWxsKHRoYXQpO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9XG5cbiAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxudmFyIHByb2Nlc3MkMSA9IF9nbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gX2dsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gX2dsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IF9nbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBfZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnZhciBydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gIHZhciBpZCA9ICt0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTsgLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuXG5cbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcblxuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICB9XG5cbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBfaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG5cbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcblxuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07IC8vIE5vZGUuanMgMC44LVxuXG5cbiAgaWYgKF9jb2YocHJvY2VzcyQxKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGlkKSB7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2soX2N0eChydW4sIGlkLCAxKSk7XG4gICAgfTsgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG5cbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coX2N0eChydW4sIGlkLCAxKSk7XG4gICAgfTsgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IF9jdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7IC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAgIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoX2dsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFfZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGlkKSB7XG4gICAgICBfZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcblxuICAgIF9nbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7IC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gX2RvbUNyZWF0ZSgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGlkKSB7XG4gICAgICBfaHRtbC5hcHBlbmRDaGlsZChfZG9tQ3JlYXRlKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2h0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTsgLy8gUmVzdCBvbGQgYnJvd3NlcnNcblxuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoX2N0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgX3Rhc2sgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxudmFyIG1hY3JvdGFzayA9IF90YXNrLnNldDtcbnZhciBPYnNlcnZlciA9IF9nbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBfZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyQyID0gX2dsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UkMSA9IF9nbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSBfY29mKHByb2Nlc3MkMikgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgX21pY3JvdGFzayA9IGZ1bmN0aW9uIF9taWNyb3Rhc2soKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2VzcyQyLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG5cbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO2Vsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9OyAvLyBOb2RlLmpzXG5cblxuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9OyAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuXG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShfZ2xvYmFsLm5hdmlnYXRvciAmJiBfZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICBub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07IC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG5cbiAgfSBlbHNlIGlmIChQcm9taXNlJDEgJiYgUHJvbWlzZSQxLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUodW5kZWZpbmVkKTtcblxuICAgIG5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTsgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgICAvLyAtIHNldEltbWVkaWF0ZVxuICAgIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gICAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgICAvLyAtIHNldFRpbWVvdXRcblxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKF9nbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0ge1xuICAgICAgZm46IGZuLFxuICAgICAgbmV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcblxuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9XG5cbiAgICBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IF9hRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gX2FGdW5jdGlvbihyZWplY3QpO1xufVxuXG52YXIgZiQ1ID0gZnVuY3Rpb24gZihDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG52YXIgX25ld1Byb21pc2VDYXBhYmlsaXR5ID0ge1xuICBmOiBmJDVcbn07XG5cbnZhciBfcGVyZm9ybSA9IGZ1bmN0aW9uIF9wZXJmb3JtKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgZTogZmFsc2UsXG4gICAgICB2OiBleGVjKClcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGU6IHRydWUsXG4gICAgICB2OiBlXG4gICAgfTtcbiAgfVxufTtcblxudmFyIG5hdmlnYXRvciA9IF9nbG9iYWwubmF2aWdhdG9yO1xuXG52YXIgX3VzZXJBZ2VudCA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuXG52YXIgX3Byb21pc2VSZXNvbHZlID0gZnVuY3Rpb24gX3Byb21pc2VSZXNvbHZlKEMsIHgpIHtcbiAgX2FuT2JqZWN0KEMpO1xuICBpZiAoX2lzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBfbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cbnZhciB0YXNrID0gX3Rhc2suc2V0O1xudmFyIG1pY3JvdGFzayA9IF9taWNyb3Rhc2soKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciQxID0gX2dsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyQzID0gX2dsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQzICYmIHByb2Nlc3MkMy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyICRQcm9taXNlID0gX2dsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUkMSA9IF9jbGFzc29mKHByb2Nlc3MkMykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgLyogZW1wdHkgKi9cbn07XG5cbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IF9uZXdQcm9taXNlQ2FwYWJpbGl0eS5mO1xudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtfd2tzKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9OyAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG5cblxuICAgIHJldHVybiAoaXNOb2RlJDEgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2UgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDAgJiYgX3VzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG59KCk7IC8vIGhlbHBlcnNcblxudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiBpc1RoZW5hYmxlKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gX2lzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeShwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7ZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IkMSgnUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkge1xuICAgICAgcnVuKGNoYWluW2krK10pO1xuICAgIH0gLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcblxuXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIG9uVW5oYW5kbGVkKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKF9nbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuXG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gX3BlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlJDEpIHtcbiAgICAgICAgICBwcm9jZXNzJDMuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7XG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgcmVhc29uOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gX2dsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcblxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSQxIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfVxuXG4gICAgcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiBpc1VuaGFuZGxlZChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKF9nbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmIChpc05vZGUkMSkge1xuICAgICAgcHJvY2VzcyQzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBfZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7XG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgIHJlYXNvbjogcHJvbWlzZS5fdlxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gJHJlamVjdCh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcblxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG5cbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICRyZXNvbHZlKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcblxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yJDEoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcblxuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge1xuICAgICAgICAgIF93OiBwcm9taXNlLFxuICAgICAgICAgIF9kOiBmYWxzZVxuICAgICAgICB9OyAvLyB3cmFwXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIF9jdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBfY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoe1xuICAgICAgX3c6IHByb21pc2UsXG4gICAgICBfZDogZmFsc2VcbiAgICB9LCBlKTsgLy8gd3JhcFxuICB9XG59OyAvLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuXG5cbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBfYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgX2FGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcblxuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihfY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgX2N0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcblxuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7IC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG5cbiAgICB0aGlzLl9zID0gMDsgLy8gPC0gc3RhdGVcblxuICAgIHRoaXMuX2QgPSBmYWxzZTsgLy8gPC0gZG9uZVxuXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgLy8gPC0gdmFsdWVcblxuICAgIHRoaXMuX2ggPSAwOyAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAvLyA8LSBub3RpZnlcbiAgfTtcblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBfcmVkZWZpbmVBbGwoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShfc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSQxID8gcHJvY2VzcyQzLmRvbWFpbiA6IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcblxuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiBPd25Qcm9taXNlQ2FwYWJpbGl0eSgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gX2N0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBfY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuXG4gIF9uZXdQcm9taXNlQ2FwYWJpbGl0eS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXIgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQykgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbl9leHBvcnQoX2V4cG9ydC5HICsgX2V4cG9ydC5XICsgX2V4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtcbiAgUHJvbWlzZTogJFByb21pc2Vcbn0pO1xuX3NldFRvU3RyaW5nVGFnKCRQcm9taXNlLCBQUk9NSVNFKTtcbl9zZXRTcGVjaWVzKFBST01JU0UpO1xuV3JhcHBlciA9IF9jb3JlW1BST01JU0VdOyAvLyBzdGF0aWNzXG5cbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICggIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gX3Byb21pc2VSZXNvbHZlKCB0aGlzLCB4KTtcbiAgfVxufSk7XG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiBfaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gX3BlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgX2Zvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gX3BlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgX2Zvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5fZXhwb3J0KF9leHBvcnQuUCArIF9leHBvcnQuUiwgJ1Byb21pc2UnLCB7XG4gICdmaW5hbGx5JzogZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgdmFyIEMgPSBfc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIF9jb3JlLlByb21pc2UgfHwgX2dsb2JhbC5Qcm9taXNlKTtcbiAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgICByZXR1cm4gdGhpcy50aGVuKGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIF9wcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSk7XG4gICAgfSA6IG9uRmluYWxseSwgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gX3Byb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0gOiBvbkZpbmFsbHkpO1xuICB9XG59KTtcblxudmFyIHJBcHBseSA9IChfZ2xvYmFsLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5OyAvLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcblxuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KSB7XG4gICAgdmFyIFQgPSBfYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBfYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG5cbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiBjb25zdHJ1Y3QoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcblxuXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9XG5cbiAgcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxudmFyIF9iaW5kID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXRcbi8qICwgLi4uYXJncyAqL1xuKSB7XG4gIHZhciBmbiA9IF9hRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKClcbiAgLyogYXJncy4uLiAqL1xuICB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IF9pbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuXG4gIGlmIChfaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuXG52YXIgckNvbnN0cnVjdCA9IChfZ2xvYmFsLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDsgLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG5cbnZhciBORVdfVEFSR0VUX0JVRyA9IF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSk7XG59KTtcbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJnc1xuICAvKiAsIG5ld1RhcmdldCAqL1xuICApIHtcbiAgICBfYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgX2FuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IF9hRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG5cbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KCk7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfSAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuXG5cbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoX2JpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfSAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcblxuXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBfb2JqZWN0Q3JlYXRlKF9pc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBfaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqIF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KF9vYmplY3REcC5mKHt9LCAxLCB7XG4gICAgdmFsdWU6IDFcbiAgfSksIDEsIHtcbiAgICB2YWx1ZTogMlxuICB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBfYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IF90b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgX2FuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIF9vYmplY3REcC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciBnT1BEJDEgPSBfb2JqZWN0R29wZC5mO1xuX2V4cG9ydChfZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRCQxKF9hbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5XG4vKiAsIHJlY2VpdmVyICovXG4pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKF9hbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gX29iamVjdEdvcGQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIF9oYXMoZGVzYywgJ3ZhbHVlJykgPyBkZXNjLnZhbHVlIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZCA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpIDogdW5kZWZpbmVkO1xuICBpZiAoX2lzT2JqZWN0KHByb3RvID0gX29iamVjdEdwbyh0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuX2V4cG9ydChfZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXQ6IGdldFxufSk7XG5cbl9leHBvcnQoX2V4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBfb2JqZWN0R29wZC5mKF9hbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuXG5fZXhwb3J0KF9leHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICByZXR1cm4gX29iamVjdEdwbyhfYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuXG5fZXhwb3J0KF9leHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcblxudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuX2V4cG9ydChfZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBfYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuXG5fZXhwb3J0KF9leHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIG93bktleXM6IF9vd25LZXlzXG59KTtcblxudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcbl9leHBvcnQoX2V4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIF9hbk9iamVjdCh0YXJnZXQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICgkcHJldmVudEV4dGVuc2lvbnMpICRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWXG4vKiAsIHJlY2VpdmVyICovXG4pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gX29iamVjdEdvcGQuZihfYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB2YXIgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcblxuICBpZiAoIW93bkRlc2MpIHtcbiAgICBpZiAoX2lzT2JqZWN0KHByb3RvID0gX29iamVjdEdwbyh0YXJnZXQpKSkge1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG5cbiAgICBvd25EZXNjID0gX3Byb3BlcnR5RGVzYygwKTtcbiAgfVxuXG4gIGlmIChfaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFfaXNPYmplY3QocmVjZWl2ZXIpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yID0gX29iamVjdEdvcGQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpKSB7XG4gICAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yLmdldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iuc2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgICBfb2JqZWN0RHAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgfSBlbHNlIF9vYmplY3REcC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgX3Byb3BlcnR5RGVzYygwLCBWKSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG5fZXhwb3J0KF9leHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldDogc2V0XG59KTtcblxuaWYgKF9zZXRQcm90bykgX2V4cG9ydChfZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIF9zZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcblxuICAgIHRyeSB7XG4gICAgICBfc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciBNQVRDSCA9IF93a3MoJ21hdGNoJyk7XG5cbnZhciBfaXNSZWdleHAgPSBmdW5jdGlvbiBfaXNSZWdleHAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gX2lzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IF9jb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cbnZhciBfZmxhZ3MgPSBmdW5jdGlvbiBfZmxhZ3MoKSB7XG4gIHZhciB0aGF0ID0gX2FuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZFAkMiA9IF9vYmplY3REcC5mO1xudmFyIGdPUE4gPSBfb2JqZWN0R29wbi5mO1xudmFyICRSZWdFeHAgPSBfZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byQxID0gJFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nOyAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcblxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAoX2Rlc2NyaXB0b3JzICYmICghQ09SUkVDVF9ORVcgfHwgX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmUyW193a3MoJ21hdGNoJyldID0gZmFsc2U7IC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG5cbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpIHtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKSB7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cDtcbiAgICB2YXIgcGlSRSA9IF9pc1JlZ2V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcCA6IF9pbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FVyA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZikgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/IF9mbGFncy5jYWxsKHApIDogZiksIHRpUkUgPyB0aGlzIDogcHJvdG8kMSwgJFJlZ0V4cCk7XG4gIH07XG5cbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24gcHJveHkoa2V5KSB7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAkMigkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQmFzZVtrZXldO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGl0KSB7XG4gICAgICAgIEJhc2Vba2V5XSA9IGl0O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOykge1xuICAgIHByb3h5KGtleXNbaSsrXSk7XG4gIH1cblxuICBwcm90byQxLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90byQxO1xuICBfcmVkZWZpbmUoX2dsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5fc2V0U3BlY2llcygnUmVnRXhwJyk7XG5cbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxuXG52YXIgX3N0cmluZ0F0ID0gZnVuY3Rpb24gX3N0cmluZ0F0KFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKF9kZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IF90b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIGF0ID0gX3N0cmluZ0F0KHRydWUpOyAvLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxuXG52YXIgX2FkdmFuY2VTdHJpbmdJbmRleCA9IGZ1bmN0aW9uIF9hZHZhbmNlU3RyaW5nSW5kZXgoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBhdChTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuXG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7IC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcblxudmFyIF9yZWdleHBFeGVjQWJzdHJhY3QgPSBmdW5jdGlvbiBfcmVnZXhwRXhlY0Fic3RyYWN0KFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG5cbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChfY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cblxuICByZXR1cm4gYnVpbHRpbkV4ZWMuY2FsbChSLCBTKTtcbn07XG5cbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjOyAvLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG52YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvLFxuICAgICAgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTFbTEFTVF9JTkRFWF0gIT09IDAgfHwgcmUyW0xBU1RfSU5ERVhdICE9PSAwO1xufSgpOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG5cblxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHJlLnNvdXJjZSArICckKD8hXFxcXHMpJywgX2ZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZVtMQVNUX0lOREVYXTtcbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbnZhciBfcmVnZXhwRXhlYyA9IHBhdGNoZWRFeGVjO1xuXG5fZXhwb3J0KHtcbiAgdGFyZ2V0OiAnUmVnRXhwJyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogX3JlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IF9yZWdleHBFeGVjXG59KTtcblxudmFyIFNQRUNJRVMkMyA9IF93a3MoJ3NwZWNpZXMnKTtcbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcblxuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0ge1xuICAgICAgYTogJzcnXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG5cbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0oKTtcblxudmFyIF9maXhSZVdrcyA9IGZ1bmN0aW9uIF9maXhSZVdrcyhLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gX3drcyhLRVkpO1xuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuXG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfTtcblxuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIV9mYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBleGVjQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcblxuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFUyQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pIDogdW5kZWZpbmVkO1xuXG4gIGlmICghREVMRUdBVEVTX1RPX1NZTUJPTCB8fCAhREVMRUdBVEVTX1RPX0VYRUMgfHwgS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTIHx8IEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBmbnMgPSBleGVjKF9kZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSBfcmVnZXhwRXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMilcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICAgIHZhciByeGZuID0gZm5zWzFdO1xuICAgIF9yZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBfaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7XG4gICAgICByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTtcbiAgICB9IC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgIHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTtcbiAgICB9KTtcbiAgfVxufTtcblxuX2ZpeFJlV2tzKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFsvLyBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkbWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgIHZhciByeCA9IF9hbk9iamVjdChyZWdleHApO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIGlmICghcnguZ2xvYmFsKSByZXR1cm4gX3JlZ2V4cEV4ZWNBYnN0cmFjdChyeCwgUyk7XG4gICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBBID0gW107XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IF9yZWdleHBFeGVjQWJzdHJhY3QocngsIFMpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBfYWR2YW5jZVN0cmluZ0luZGV4KFMsIF90b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICBuKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG4gPT09IDAgPyBudWxsIDogQTtcbiAgfV07XG59KTtcblxudmFyIG1heCQxID0gTWF0aC5tYXg7XG52YXIgbWluJDIgPSBNYXRoLm1pbjtcbnZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gbWF5YmVUb1N0cmluZyhpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07IC8vIEBAcmVwbGFjZSBsb2dpY1xuXG5cbl9maXhSZVdrcygncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgZnVuY3Rpb24gKHJlZ2V4cCwgcmVwbGFjZVZhbHVlKSB7XG4gICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB2YXIgcnggPSBfYW5PYmplY3QocmVnZXhwKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgIHZhciBnbG9iYWwgPSByeC5nbG9iYWw7XG5cbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfcmVnZXhwRXhlY0Fic3RyYWN0KHJ4LCBTKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IF9hZHZhbmNlU3RyaW5nSW5kZXgoUywgX3RvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgYWNjdW11bGF0ZWRSZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBtYXgkMShtaW4kMihfdG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICB2YXIgY2FwdHVyZXMgPSBbXTsgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuXG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykge1xuICAgICAgICBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcblxuICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgfV07IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuXG4gIGZ1bmN0aW9uIGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgdGFpbFBvcyA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XG4gICAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcblxuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSBfdG9PYmplY3QobmFtZWRDYXB0dXJlcyk7XG4gICAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gICAgfVxuXG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuXG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICByZXR1cm4gJyQnO1xuXG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuXG4gICAgICAgIGNhc2UgJ2AnOlxuICAgICAgICAgIHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgcmV0dXJuIHN0ci5zbGljZSh0YWlsUG9zKTtcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gXFxkXFxkP1xuICAgICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG5cbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IkMShuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTtcblxudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYJDEgPSAnbGFzdEluZGV4JztcbnZhciBNQVhfVUlOVDMyID0gMHhmZmZmZmZmZjsgLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcblxudmFyIFNVUFBPUlRTX1kgPSAhX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgUmVnRXhwKE1BWF9VSU5UMzIsICd5Jyk7XG59KTsgLy8gQEBzcGxpdCBsb2dpY1xuXG5fZml4UmVXa3MoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcblxuICBpZiAoJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHwgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8ICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fCAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHwgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fCAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF0pIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gaW50ZXJuYWxTcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107IC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG5cbiAgICAgIGlmICghX2lzUmVnZXhwKHNlcGFyYXRvcikpIHJldHVybiAkc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgKyAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgKyAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDsgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcblxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobWF0Y2ggPSBfcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYJDFdO1xuXG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWCQxXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWCQxXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG5cbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTsgLy8gQ2hha3JhLCBWOFxuXG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIGludGVybmFsU3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiAkc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludGVybmFsU3BsaXQgPSAkc3BsaXQ7XG4gIH1cblxuICByZXR1cm4gWy8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBzcGxpdHRlciAhPT0gdW5kZWZpbmVkID8gc3BsaXR0ZXIuY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6IGludGVybmFsU3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAvL1xuICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gIC8vIHRoZSAneScgZmxhZy5cbiAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgIHZhciByeCA9IF9hbk9iamVjdChyZWdleHApO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBDID0gX3NwZWNpZXNDb25zdHJ1Y3RvcihyeCwgUmVnRXhwKTtcbiAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgKyAocngudW5pY29kZSA/ICd1JyA6ICcnKSArIChTVVBQT1JUU19ZID8gJ3knIDogJ2cnKTsgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cbiAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG5cbiAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhTVVBQT1JUU19ZID8gcnggOiAnXig/OicgKyByeC5zb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gX3JlZ2V4cEV4ZWNBYnN0cmFjdChzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIHEgPSAwO1xuICAgIHZhciBBID0gW107XG5cbiAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XG4gICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICB2YXIgeiA9IF9yZWdleHBFeGVjQWJzdHJhY3Qoc3BsaXR0ZXIsIFNVUFBPUlRTX1kgPyBTIDogUy5zbGljZShxKSk7XG4gICAgICB2YXIgZTtcblxuICAgICAgaWYgKHogPT09IG51bGwgfHwgKGUgPSAkbWluKF90b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoU1VQUE9SVFNfWSA/IDAgOiBxKSksIFMubGVuZ3RoKSkgPT09IHApIHtcbiAgICAgICAgcSA9IF9hZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEEucHVzaChTLnNsaWNlKHAsIHEpKTtcbiAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgQS5wdXNoKHpbaV0pO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgfVxuXG4gICAgICAgIHEgPSBwID0gZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBLnB1c2goUy5zbGljZShwKSk7XG4gICAgcmV0dXJuIEE7XG4gIH1dO1xufSk7XG5cbi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxudmFyIF9zYW1lVmFsdWUgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcblxuX2ZpeFJlV2tzKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFsvLyBgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNlYXJjaFxuICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHNlYXJjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgdmFyIHJ4ID0gX2FuT2JqZWN0KHJlZ2V4cCk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIHByZXZpb3VzTGFzdEluZGV4ID0gcngubGFzdEluZGV4O1xuICAgIGlmICghX3NhbWVWYWx1ZShwcmV2aW91c0xhc3RJbmRleCwgMCkpIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IF9yZWdleHBFeGVjQWJzdHJhY3QocngsIFMpO1xuICAgIGlmICghX3NhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IC0xIDogcmVzdWx0LmluZGV4O1xuICB9XTtcbn0pO1xuXG5pZiAoX2Rlc2NyaXB0b3JzICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSBfb2JqZWN0RHAuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBfZmxhZ3Ncbn0pO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShmbikge1xuICBfcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59OyAvLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5cblxuaWYgKF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbCh7XG4gICAgc291cmNlOiAnYScsXG4gICAgZmxhZ3M6ICdiJ1xuICB9KSAhPSAnL2EvYic7XG59KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBfYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJywgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFfZGVzY3JpcHRvcnMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/IF9mbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7IC8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cblxudmFyIFNFVCA9ICdTZXQnOyAvLyAyMy4yIFNldCBPYmplY3RzXG5cbnZhciBlczZfc2V0ID0gX2NvbGxlY3Rpb24oU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBfY29sbGVjdGlvblN0cm9uZy5kZWYoX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIF9jb2xsZWN0aW9uU3Ryb25nKTtcblxudmFyIGYkNiA9IF93a3M7XG52YXIgX3drc0V4dCA9IHtcbiAgZjogZiQ2XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfb2JqZWN0RHAuZjtcblxudmFyIF93a3NEZWZpbmUgPSBmdW5jdGlvbiBfd2tzRGVmaW5lKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBfY29yZS5TeW1ib2wgfHwgKF9jb3JlLlN5bWJvbCA9ICBfZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7XG4gICAgdmFsdWU6IF93a3NFeHQuZihuYW1lKVxuICB9KTtcbn07XG5cbnZhciBfZW51bUtleXMgPSBmdW5jdGlvbiBfZW51bUtleXMoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IF9vYmplY3RLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBfb2JqZWN0R29wcy5mO1xuXG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gX29iamVjdFBpZS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkge1xuICAgICAgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ09QTiQxID0gX29iamVjdEdvcG4uZjtcbnZhciB0b1N0cmluZyQxID0ge30udG9TdHJpbmc7XG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gZ2V0V2luZG93TmFtZXMoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTiQxKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG52YXIgZiQ3ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmckMS5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4kMShfdG9Jb2JqZWN0KGl0KSk7XG59O1xuXG52YXIgX29iamVjdEdvcG5FeHQgPSB7XG4gIGY6IGYkN1xufTtcblxudmFyIE1FVEEgPSBfbWV0YS5LRVk7XG52YXIgZ09QRCQyID0gX29iamVjdEdvcGQuZjtcbnZhciBkUCQzID0gX29iamVjdERwLmY7XG52YXIgZ09QTiQyID0gX29iamVjdEdvcG5FeHQuZjtcbnZhciAkU3ltYm9sID0gX2dsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBfZ2xvYmFsLkpTT047XG5cbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xuXG52YXIgUFJPVE9UWVBFJDIgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSBfd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFJDEgPSBfd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSQxID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBfc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gX3NoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IF9zaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byQxID0gT2JqZWN0W1BST1RPVFlQRSQyXTtcbnZhciBVU0VfTkFUSVZFJDEgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBfZ2xvYmFsLlFPYmplY3Q7IC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xuXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFJDJdIHx8ICFRT2JqZWN0W1BST1RPVFlQRSQyXS5maW5kQ2hpbGQ7IC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xuXG52YXIgc2V0U3ltYm9sRGVzYyA9IF9kZXNjcmlwdG9ycyAmJiBfZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX29iamVjdENyZWF0ZShkUCQzKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBkUCQzKHRoaXMsICdhJywge1xuICAgICAgICB2YWx1ZTogN1xuICAgICAgfSkuYTtcbiAgICB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEJDIoT2JqZWN0UHJvdG8kMSwga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvJDFba2V5XTtcbiAgZFAkMyhpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8kMSkgZFAkMyhPYmplY3RQcm90byQxLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFAkMztcblxudmFyIHdyYXAgPSBmdW5jdGlvbiB3cmFwKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX29iamVjdENyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRSQyXSk7XG5cbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSQxICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvJDEpICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIF9hbk9iamVjdChpdCk7XG4gIGtleSA9IF90b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBfYW5PYmplY3QoRCk7XG5cbiAgaWYgKF9oYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIV9oYXMoaXQsIEhJRERFTikpIGRQJDMoaXQsIEhJRERFTiwgX3Byb3BlcnR5RGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9oYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfb2JqZWN0Q3JlYXRlKEQsIHtcbiAgICAgICAgZW51bWVyYWJsZTogX3Byb3BlcnR5RGVzYygwLCBmYWxzZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9XG5cbiAgcmV0dXJuIGRQJDMoaXQsIGtleSwgRCk7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIF9hbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gX2VudW1LZXlzKFAgPSBfdG9Jb2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuXG4gIHdoaWxlIChsID4gaSkge1xuICAgICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIGl0O1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9vYmplY3RDcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX29iamVjdENyZWF0ZShpdCksIFApO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bSQxLmNhbGwodGhpcywga2V5ID0gX3RvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8kMSAmJiBfaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIV9oYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFfaGFzKHRoaXMsIGtleSkgfHwgIV9oYXMoQWxsU3ltYm9scywga2V5KSB8fCBfaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSBfdG9Jb2JqZWN0KGl0KTtcbiAga2V5ID0gX3RvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8kMSAmJiBfaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIV9oYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRCQyKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBfaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShfaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOJDIoX3RvSW9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcblxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghX2hhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90byQxO1xuICB2YXIgbmFtZXMgPSBnT1BOJDIoSVNfT1AgPyBPUFN5bWJvbHMgOiBfdG9Jb2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKF9oYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gX2hhcyhPYmplY3RQcm90byQxLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTsgLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5cblxuaWYgKCFVU0VfTkFUSVZFJDEpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSBfdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcblxuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gJHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvJDEpICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChfaGFzKHRoaXMsIEhJRERFTikgJiYgX2hhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgX3Byb3BlcnR5RGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBpZiAoX2Rlc2NyaXB0b3JzICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90byQxLCB0YWcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogJHNldFxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG5cbiAgX3JlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFJDJdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG4gIF9vYmplY3RHb3BkLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBfb2JqZWN0RHAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgX29iamVjdEdvcG4uZiA9IF9vYmplY3RHb3BuRXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgX29iamVjdFBpZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBfb2JqZWN0R29wcy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoX2Rlc2NyaXB0b3JzICYmICFfbGlicmFyeSkge1xuICAgIF9yZWRlZmluZShPYmplY3RQcm90byQxLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgX3drc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcChfd2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuX2V4cG9ydChfZXhwb3J0LkcgKyBfZXhwb3J0LlcgKyBfZXhwb3J0LkYgKiAhVVNFX05BVElWRSQxLCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJy5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOykge1xuICBfd2tzKGVzNlN5bWJvbHNbaisrXSk7XG59XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSBfb2JqZWN0S2V5cyhfd2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHtcbiAgX3drc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xufVxuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFVU0VfTkFUSVZFJDEsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gX2ZvcihrZXkpIHtcbiAgICByZXR1cm4gX2hhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKSA/IFN5bWJvbFJlZ2lzdHJ5W2tleV0gOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIHtcbiAgICAgIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gICAgfVxuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uIHVzZVNldHRlcigpIHtcbiAgICBzZXR0ZXIgPSB0cnVlO1xuICB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uIHVzZVNpbXBsZSgpIHtcbiAgICBzZXR0ZXIgPSBmYWxzZTtcbiAgfVxufSk7XG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFVU0VfTkFUSVZFJDEsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pOyAvLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcblxuJEpTT04gJiYgX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUkMSB8fCBfZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTsgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG5cbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHtcbiAgICBhOiBTXG4gIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG5cbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgfVxuXG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghX2lzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG5cbiAgICBpZiAoIV9pc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pOyAvLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG5cbiRTeW1ib2xbUFJPVE9UWVBFJDJdW1RPX1BSSU1JVElWRSQxXSB8fCBfaGlkZSgkU3ltYm9sW1BST1RPVFlQRSQyXSwgVE9fUFJJTUlUSVZFJDEsICRTeW1ib2xbUFJPVE9UWVBFJDJdLnZhbHVlT2YpOyAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5cbl9zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7IC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cblxuX3NldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7IC8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5cbl9zZXRUb1N0cmluZ1RhZyhfZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbl93a3NEZWZpbmUoJ2FzeW5jSXRlcmF0b3InKTtcblxudmFyIF9zdHJpbmdSZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhfZGVmaW5lZCh0aGlzKSk7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIG4gPSBfdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcblxuICBmb3IgKDsgbiA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSB7XG4gICAgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBfc3RyaW5nUGFkID0gZnVuY3Rpb24gX3N0cmluZ1BhZCh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoX2RlZmluZWQodGhhdCkpO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gIHZhciBmaWxsU3RyID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpO1xuICB2YXIgaW50TWF4TGVuZ3RoID0gX3RvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgdmFyIHN0cmluZ0ZpbGxlciA9IF9zdHJpbmdSZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxuXG5cbnZhciBXRUJLSVRfQlVHID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KF91c2VyQWdlbnQpO1xuX2V4cG9ydChfZXhwb3J0LlAgKyBfZXhwb3J0LkYgKiBXRUJLSVRfQlVHLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoXG4gIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqL1xuICApIHtcbiAgICByZXR1cm4gX3N0cmluZ1BhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcblxuXG52YXIgV0VCS0lUX0JVRyQxID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KF91c2VyQWdlbnQpO1xuX2V4cG9ydChfZXhwb3J0LlAgKyBfZXhwb3J0LkYgKiBXRUJLSVRfQlVHJDEsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aFxuICAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi9cbiAgKSB7XG4gICAgcmV0dXJuIF9zdHJpbmdQYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxudmFyIF9zdHJpbmdXcyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgKyAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cbnZhciBzcGFjZSA9ICdbJyArIF9zdHJpbmdXcyArICddJztcbnZhciBub24gPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gZXhwb3J0ZXIoS0VZLCBleGVjLCBBTElBUykge1xuICB2YXIgZXhwID0ge307XG4gIHZhciBGT1JDRSA9IF9mYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhX3N0cmluZ1dzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogX3N0cmluZ1dzW0tFWV07XG4gIGlmIChBTElBUykgZXhwW0FMSUFTXSA9IGZuO1xuICBfZXhwb3J0KF9leHBvcnQuUCArIF9leHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07IC8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cblxuXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhfZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG52YXIgX3N0cmluZ1RyaW0gPSBleHBvcnRlcjtcblxuX3N0cmluZ1RyaW0oJ3RyaW1MZWZ0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7XG5cbl9zdHJpbmdUcmltKCd0cmltUmlnaHQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpO1xuXG52YXIgVFlQRUQgPSBfdWlkKCd0eXBlZF9hcnJheScpO1xudmFyIFZJRVcgPSBfdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoX2dsb2JhbC5BcnJheUJ1ZmZlciAmJiBfZ2xvYmFsLkRhdGFWaWV3KTtcbnZhciBDT05TVFIgPSBBQlY7XG52YXIgaSQxID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5Jy5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSQxIDwgbCkge1xuICBpZiAoVHlwZWQgPSBfZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSQxKytdXSkge1xuICAgIF9oaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIF9oaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxudmFyIF90eXBlZCA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07XG5cbnZhciBfdG9JbmRleCA9IGZ1bmN0aW9uIF90b0luZGV4KGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IF90b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gX3RvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcblxudmFyIF9hcnJheUZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbHVlXG4vKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqL1xuKSB7XG4gIHZhciBPID0gX3RvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gX3RvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBfdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IF90b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuXG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkge1xuICAgIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBPO1xufTtcblxudmFyIF90eXBlZEJ1ZmZlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICB2YXIgZ09QTiA9IF9vYmplY3RHb3BuLmY7XG4gIHZhciBkUCA9IF9vYmplY3REcC5mO1xuICB2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiAgdmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbiAgdmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG4gIHZhciAkQXJyYXlCdWZmZXIgPSBfZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG4gIHZhciAkRGF0YVZpZXcgPSBfZ2xvYmFsW0RBVEFfVklFV107XG4gIHZhciBNYXRoID0gX2dsb2JhbC5NYXRoO1xuICB2YXIgUmFuZ2VFcnJvciA9IF9nbG9iYWwuUmFuZ2VFcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG5cbiAgdmFyIEluZmluaXR5ID0gX2dsb2JhbC5JbmZpbml0eTtcbiAgdmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG4gIHZhciBhYnMgPSBNYXRoLmFicztcbiAgdmFyIHBvdyA9IE1hdGgucG93O1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gIHZhciBMTjIgPSBNYXRoLkxOMjtcbiAgdmFyIEJVRkZFUiA9ICdidWZmZXInO1xuICB2YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG4gIHZhciBCWVRFX09GRlNFVCA9ICdieXRlT2Zmc2V0JztcbiAgdmFyICRCVUZGRVIgPSBfZGVzY3JpcHRvcnMgPyAnX2InIDogQlVGRkVSO1xuICB2YXIgJExFTkdUSCA9IF9kZXNjcmlwdG9ycyA/ICdfbCcgOiBCWVRFX0xFTkdUSDtcbiAgdmFyICRPRkZTRVQgPSBfZGVzY3JpcHRvcnMgPyAnX28nIDogQllURV9PRkZTRVQ7IC8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG5cbiAgZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobkJ5dGVzKTtcbiAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gICAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICAgIHZhciBlLCBtLCBjO1xuICAgIHZhbHVlID0gYWJzKHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gICAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuXG4gICAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgICBlLS07XG4gICAgICAgIGMgKj0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgICBlKys7XG4gICAgICAgIGMgLz0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBlID0gZU1heDtcbiAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgICBlID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHtcbiAgICB9XG5cbiAgICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgICBlTGVuICs9IG1MZW47XG5cbiAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge1xuICAgIH1cblxuICAgIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gICAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gICAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICAgIHZhciBzID0gYnVmZmVyW2ktLV07XG4gICAgdmFyIGUgPSBzICYgMTI3O1xuICAgIHZhciBtO1xuICAgIHMgPj49IDc7XG5cbiAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KSB7XG4gICAgfVxuXG4gICAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgICBlID4+PSAtbkJpdHM7XG4gICAgbkJpdHMgKz0gbUxlbjtcblxuICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpIHtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gMCkge1xuICAgICAgZSA9IDEgLSBlQmlhcztcbiAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlIC0gZUJpYXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gIH1cblxuICBmdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgICByZXR1cm4gW2l0ICYgMHhmZl07XG4gIH1cblxuICBmdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gICAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gICAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tpbnRlcm5hbF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICAgIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgICB2YXIgaW50SW5kZXggPSBfdG9JbmRleChudW1JbmRleCk7XG4gICAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICAgIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gICAgdmFyIGludEluZGV4ID0gX3RvSW5kZXgobnVtSW5kZXgpO1xuICAgIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gICAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gICAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHtcbiAgICAgIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghX3R5cGVkLkFCVikge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgX2FuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgICAgdmFyIGJ5dGVMZW5ndGggPSBfdG9JbmRleChsZW5ndGgpO1xuICAgICAgdGhpcy5fYiA9IF9hcnJheUZpbGwuY2FsbChuZXcgQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gICAgfTtcblxuICAgICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgX2FuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgICAgX2FuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgICAgdmFyIG9mZnNldCA9IF90b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiBfdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgICB9O1xuXG4gICAgaWYgKF9kZXNjcmlwdG9ycykge1xuICAgICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgICB9XG5cbiAgICBfcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgICAgfSxcbiAgICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgICB9LFxuICAgICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXRcbiAgICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICAgIH0sXG4gICAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0XG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgICAgfSxcbiAgICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0XG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgfSxcbiAgICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXRcbiAgICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgICB9LFxuICAgICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0XG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgICB9LFxuICAgICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0XG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgICB9LFxuICAgICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgICApIHtcbiAgICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgICAgfSxcbiAgICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIH0sXG4gICAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgICApIHtcbiAgICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgICAgfSxcbiAgICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIH0sXG4gICAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIH0sXG4gICAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICAgKSB7XG4gICAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIV9mYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAkQXJyYXlCdWZmZXIoMSk7XG4gICAgfSkgfHwgIV9mYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9KSB8fCBfZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgIG5ldyAkQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgICB9KSkge1xuICAgICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICAgIF9hbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcihfdG9JbmRleChsZW5ndGgpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG5cbiAgICAgIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIF9oaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgICAgfVxuXG4gICAgICBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICAgIH0gLy8gaU9TIFNhZmFyaSA3LnggYnVnXG5cblxuICAgIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICAgIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gICAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSBfcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgICB9LFxuICAgICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICB9XG5cbiAgX3NldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgX3NldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgX2hpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sIF90eXBlZC5WSUVXLCB0cnVlKTtcbiAgZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuICBleHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG59KTtcblxudmFyIEFycmF5QnVmZmVyID0gX2dsb2JhbC5BcnJheUJ1ZmZlcjtcbnZhciAkQXJyYXlCdWZmZXIgPSBfdHlwZWRCdWZmZXIuQXJyYXlCdWZmZXI7XG52YXIgJERhdGFWaWV3ID0gX3R5cGVkQnVmZmVyLkRhdGFWaWV3O1xudmFyICRpc1ZpZXcgPSBfdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlldztcbnZhciAkc2xpY2UgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlO1xudmFyIFZJRVckMSA9IF90eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5fZXhwb3J0KF9leHBvcnQuRyArIF9leHBvcnQuVyArIF9leHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwge1xuICBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyXG59KTtcbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIV90eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IF9pc09iamVjdChpdCkgJiYgVklFVyQxIGluIGl0O1xuICB9XG59KTtcbl9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5VICsgX2V4cG9ydC5GICogX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoX2FuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuXG4gICAgdmFyIGxlbiA9IF9hbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IF90b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGZpbiA9IF90b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbik7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoX3NwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKShfdG9MZW5ndGgoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1MgPSBuZXcgJERhdGFWaWV3KHRoaXMpO1xuICAgIHZhciB2aWV3VCA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5fc2V0U3BlY2llcyhBUlJBWV9CVUZGRVIpO1xuXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxuXG52YXIgX2FycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIF9hcnJheU1ldGhvZHMoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IF9hcnJheVNwZWNpZXNDcmVhdGU7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IF90b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBfaW9iamVjdChPKTtcbiAgICB2YXIgZiA9IF9jdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IF90b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG5cbiAgICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuXG4gICAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgLy8gbWFwXG4gICAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAvLyBzb21lXG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgIC8vIGZpbmRcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuXG5cbnZhciBlczZfYXJyYXlfaXRlcmF0b3IgPSBfaXRlckRlZmluZShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSBfdG9Jb2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG5cbiAgdGhpcy5faSA9IDA7IC8vIG5leHQgaW5kZXhcblxuICB0aGlzLl9rID0ga2luZDsgLy8ga2luZFxuICAvLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcblxuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBfaXRlclN0ZXAoMSk7XG4gIH1cblxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBfaXRlclN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIF9pdGVyU3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBfaXRlclN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpOyAvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5cbl9pdGVyYXRvcnMuQXJndW1lbnRzID0gX2l0ZXJhdG9ycy5BcnJheTtcbl9hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5fYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5fYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG52YXIgX2FycmF5Q29weVdpdGhpbiA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXRcbi8qID0gMCAqL1xuLCBzdGFydFxuLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovXG4pIHtcbiAgdmFyIE8gPSBfdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW4gPSBfdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgdG8gPSBfdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSBfdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IF90b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgdmFyIGluYyA9IDE7XG5cbiAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xuICAgIGluYyA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICs9IGNvdW50IC0gMTtcbiAgfVxuXG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH1cblxuICByZXR1cm4gTztcbn07XG5cbnZhciBfdHlwZWRBcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICBpZiAoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdmFyIExJQlJBUlkgPSBfbGlicmFyeTtcbiAgICB2YXIgZ2xvYmFsID0gX2dsb2JhbDtcbiAgICB2YXIgZmFpbHMgPSBfZmFpbHM7XG4gICAgdmFyICRleHBvcnQgPSBfZXhwb3J0O1xuICAgIHZhciAkdHlwZWQgPSBfdHlwZWQ7XG4gICAgdmFyICRidWZmZXIgPSBfdHlwZWRCdWZmZXI7XG4gICAgdmFyIGN0eCA9IF9jdHg7XG4gICAgdmFyIGFuSW5zdGFuY2UgPSBfYW5JbnN0YW5jZTtcbiAgICB2YXIgcHJvcGVydHlEZXNjID0gX3Byb3BlcnR5RGVzYztcbiAgICB2YXIgaGlkZSA9IF9oaWRlO1xuICAgIHZhciByZWRlZmluZUFsbCA9IF9yZWRlZmluZUFsbDtcbiAgICB2YXIgdG9JbnRlZ2VyID0gX3RvSW50ZWdlcjtcbiAgICB2YXIgdG9MZW5ndGggPSBfdG9MZW5ndGg7XG4gICAgdmFyIHRvSW5kZXggPSBfdG9JbmRleDtcbiAgICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gX3RvQWJzb2x1dGVJbmRleDtcbiAgICB2YXIgdG9QcmltaXRpdmUgPSBfdG9QcmltaXRpdmU7XG4gICAgdmFyIGhhcyA9IF9oYXM7XG4gICAgdmFyIGNsYXNzb2YgPSBfY2xhc3NvZjtcbiAgICB2YXIgaXNPYmplY3QgPSBfaXNPYmplY3Q7XG4gICAgdmFyIHRvT2JqZWN0ID0gX3RvT2JqZWN0O1xuICAgIHZhciBpc0FycmF5SXRlciA9IF9pc0FycmF5SXRlcjtcbiAgICB2YXIgY3JlYXRlID0gX29iamVjdENyZWF0ZTtcbiAgICB2YXIgZ2V0UHJvdG90eXBlT2YgPSBfb2JqZWN0R3BvO1xuICAgIHZhciBnT1BOID0gX29iamVjdEdvcG4uZjtcbiAgICB2YXIgZ2V0SXRlckZuID0gY29yZV9nZXRJdGVyYXRvck1ldGhvZDtcbiAgICB2YXIgdWlkID0gX3VpZDtcbiAgICB2YXIgd2tzID0gX3drcztcbiAgICB2YXIgY3JlYXRlQXJyYXlNZXRob2QgPSBfYXJyYXlNZXRob2RzO1xuICAgIHZhciBjcmVhdGVBcnJheUluY2x1ZGVzID0gX2FycmF5SW5jbHVkZXM7XG4gICAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IF9zcGVjaWVzQ29uc3RydWN0b3I7XG4gICAgdmFyIEFycmF5SXRlcmF0b3JzID0gZXM2X2FycmF5X2l0ZXJhdG9yO1xuICAgIHZhciBJdGVyYXRvcnMgPSBfaXRlcmF0b3JzO1xuICAgIHZhciAkaXRlckRldGVjdCA9IF9pdGVyRGV0ZWN0O1xuICAgIHZhciBzZXRTcGVjaWVzID0gX3NldFNwZWNpZXM7XG4gICAgdmFyIGFycmF5RmlsbCA9IF9hcnJheUZpbGw7XG4gICAgdmFyIGFycmF5Q29weVdpdGhpbiA9IF9hcnJheUNvcHlXaXRoaW47XG4gICAgdmFyICREUCA9IF9vYmplY3REcDtcbiAgICB2YXIgJEdPUEQgPSBfb2JqZWN0R29wZDtcbiAgICB2YXIgZFAgPSAkRFAuZjtcbiAgICB2YXIgZ09QRCA9ICRHT1BELmY7XG4gICAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgICB2YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuICAgIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICAgIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gICAgdmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbiAgICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gICAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciAkQXJyYXlCdWZmZXIgPSAkYnVmZmVyLkFycmF5QnVmZmVyO1xuICAgIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICAgIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgICB2YXIgYXJyYXlGaWx0ZXIgPSBjcmVhdGVBcnJheU1ldGhvZCgyKTtcbiAgICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gICAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgICB2YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG4gICAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gICAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICAgIHZhciBhcnJheUluZGV4T2YgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gICAgdmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG4gICAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICAgIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICAgIHZhciBhcnJheVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcbiAgICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICAgIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gICAgdmFyIGFycmF5U2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xuICAgIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gICAgdmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xuICAgIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gICAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICAgIHZhciBERUZfQ09OU1RSVUNUT1IgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpO1xuICAgIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gICAgdmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbiAgICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuICAgIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICAgIH0pO1xuICAgIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgICB9KTtcbiAgICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgICB9KTtcblxuICAgIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIHRvT2Zmc2V0KGl0LCBCWVRFUykge1xuICAgICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9O1xuXG4gICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoaXQpIHtcbiAgICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gICAgfTtcblxuICAgIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlKEMsIGxlbmd0aCkge1xuICAgICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gICAgfTtcblxuICAgIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiBzcGVjaWVzRnJvbUxpc3QoTywgbGlzdCkge1xuICAgICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgICB9O1xuXG4gICAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gZnJvbUxpc3QoQywgbGlzdCkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiBhZGRHZXR0ZXIoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICAgIGRQKGl0LCBrZXksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2VcbiAgICAvKiAsIG1hcGZuLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gICAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG5cbiAgICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgTyA9IHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoKVxuICAgIC8qIC4uLml0ZW1zICovXG4gICAge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07IC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcblxuXG4gICAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTtcbiAgICB9KTtcblxuICAgIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IHtcbiAgICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydFxuICAgICAgLyogLCBlbmQgKi9cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICAgIH0sXG4gICAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmblxuICAgICAgLyogLCB0aGlzQXJnICovXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIH0sXG4gICAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlXG4gICAgICAvKiAsIHN0YXJ0LCBlbmQgKi9cbiAgICAgICkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmblxuICAgICAgLyogLCB0aGlzQXJnICovXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICAgIH0sXG4gICAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZVxuICAgICAgLyogLCB0aGlzQXJnICovXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICB9LFxuICAgICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlXG4gICAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAgICAgLyogLCB0aGlzQXJnICovXG4gICAgICApIHtcbiAgICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICB9LFxuICAgICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50XG4gICAgICAvKiAsIGZyb21JbmRleCAqL1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIH0sXG4gICAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudFxuICAgICAgLyogLCBmcm9tSW5kZXggKi9cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgfSxcbiAgICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAgICAgLyogLCBmcm9tSW5kZXggKi9cbiAgICAgICkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuXG4gICAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIH0sXG4gICAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuXG4gICAgICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICAgICAgKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuXG4gICAgICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICAgICAgKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9LFxuICAgICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuXG4gICAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICB9LFxuICAgICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgICAgfSxcbiAgICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICAgIHZhciBPID0gdmFsaWRhdGUodGhpcyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKE8uYnVmZmVyLCBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULCB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbikpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgICB9O1xuXG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlXG4gICAgLyogLCBvZmZzZXQgKi9cbiAgICApIHtcbiAgICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICAgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgICAgICB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgICAgfSxcbiAgICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgICB9LFxuICAgICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uIGlzVEFJbmRleCh0YXJnZXQsIGtleSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldCkgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXSAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnICYmIGtleSBpbiB0YXJnZXQgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICAgIH07XG5cbiAgICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKSA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSkgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgICB9O1xuXG4gICAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgIGlmIChpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKSAmJiBpc09iamVjdChkZXNjKSAmJiBoYXMoZGVzYywgJ3ZhbHVlJykgJiYgIWhhcyhkZXNjLCAnZ2V0JykgJiYgIWhhcyhkZXNjLCAnc2V0JykgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZSAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKSAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIH07XG5cbiAgICBpZiAoIUFMTF9DT05TVFJVQ1RPUlMpIHtcbiAgICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAgICREUC5mID0gJHNldERlc2M7XG4gICAgfVxuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgICBkZWZpbmVQcm9wZXJ0eTogJHNldERlc2NcbiAgICB9KTtcblxuICAgIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBhcnJheVRvU3RyaW5nLmNhbGwoe30pO1xuICAgIH0pKSB7XG4gICAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICAgIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gICAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gICAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgICBzbGljZTogJHNsaWNlLFxuICAgICAgc2V0OiAkc2V0LFxuICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiBub29wICovXG4gICAgICB9LFxuICAgICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gICAgfSk7XG4gICAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gICAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICAgIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTtcbiAgICAgIH1cbiAgICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBLRVk7XG4gICAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICAgIHZhciBUQUMgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpO1xuICAgICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgICAgdmFyIE8gPSB7fTtcbiAgICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG5cbiAgICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiBnZXR0ZXIodGhhdCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgICAgfTtcblxuICAgICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiBhZGRFbGVtZW50KHRoYXQsIGluZGV4KSB7XG4gICAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKEZPUkNFRCkge1xuICAgICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuXG4gICAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgICBUeXBlZEFycmF5KDEpO1xuICAgICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICAgIG5ldyBUeXBlZEFycmF5KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIH0sIHRydWUpKSB7XG4gICAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgICB2YXIga2xhc3M7IC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcblxuICAgICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcblxuICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKSA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZCA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSkgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICAgIH1cblxuICAgICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG4gICAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgICAgaWYgKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkge1xuICAgICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBOQU1FO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuICAgICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG4gICAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVNcbiAgICAgIH0pO1xuICAgICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTtcbiAgICAgIH0pLCBOQU1FLCB7XG4gICAgICAgIGZyb206ICRmcm9tLFxuICAgICAgICBvZjogJG9mXG4gICAgICB9KTtcbiAgICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuICAgICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge1xuICAgICAgICBzZXQ6ICRzZXRcbiAgICAgIH0pO1xuICAgICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuICAgICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG4gICAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICAgIH0pLCBOQU1FLCB7XG4gICAgICAgIHNsaWNlOiAkc2xpY2VcbiAgICAgIH0pO1xuICAgICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgICB9KSksIE5BTUUsIHtcbiAgICAgICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICAgICAgfSk7XG4gICAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gICAgfTtcbiAgfSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH07XG59KTtcblxuX3R5cGVkQXJyYXkoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuX3R5cGVkQXJyYXkoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5fdHlwZWRBcnJheSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuXG5fdHlwZWRBcnJheSgnSW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbl90eXBlZEFycmF5KCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5fdHlwZWRBcnJheSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cbl90eXBlZEFycmF5KCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5fdHlwZWRBcnJheSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5fdHlwZWRBcnJheSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG52YXIgcnVudGltZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLyoqXG4gICAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKi9cbiAgIWZ1bmN0aW9uIChnbG9iYWwpIHtcblxuICAgIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICAgIHZhciB1bmRlZmluZWQkMTsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG5cbiAgICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICAgIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gICAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICAgIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuICAgIGlmIChydW50aW1lKSB7XG4gICAgICB7XG4gICAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgICAgfSAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG5cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuXG5cbiAgICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9ICBtb2R1bGUuZXhwb3J0cyA7XG5cbiAgICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG5cbiAgICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBnZW5lcmF0b3I7XG4gICAgfVxuXG4gICAgcnVudGltZS53cmFwID0gd3JhcDsgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gICAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gICAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gICAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAgIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gICAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gICAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuXG4gICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICAgIGFyZzogZXJyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gICAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gICAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiOyAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuXG4gICAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gICAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gICAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuXG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cblxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAgIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG5cblxuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4gICAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG5cbiAgICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICAgIH1cblxuICAgIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7IC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gICAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cblxuICAgIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xuICAgIH07XG5cbiAgICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcblxuICAgICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgICByZXR1cm4gZ2VuRnVuO1xuICAgIH07IC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gICAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAgIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG5cblxuICAgIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfX2F3YWl0OiBhcmdcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG5cbiAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICAgIH0gLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuXG5cbiAgICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gICAgfVxuXG4gICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAgIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7IC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cblxuICAgIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkpO1xuICAgICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9IC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuXG5cbiAgICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7IC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG5cbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAgIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cblxuXG4gICAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkJDEpIHtcbiAgICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlOyAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG5cbiAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9IC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuXG5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAgIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cblxuXG4gICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcbiAgICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiOyAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAgIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gICAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICAgIH07XG5cbiAgICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICAgIH1dO1xuICAgICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgICB9XG5cbiAgICBydW50aW1lLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXlzLnJldmVyc2UoKTsgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcblxuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuXG5cbiAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gICAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQkMSxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0ID0gMDsgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cblxuICAgICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgfSxcbiAgICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH07XG4gIH0oIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpKTtcbn0pO1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuLy8gQWRkIGEgdG9KU09OKCkgbWV0aG9kIHRvIGFsbCBFcnJvciBvYmplY3RzIG5lZWRlZCB0byBvdXRwdXQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcy5cbi8vIFRoZSBKU09OLnN0cmluZ2lmeSgpIHdpbGwgYXV0b21hdGljYWxseSBjYWxsIHRoaXMgbWV0aG9kIGlmIGl0IGV4aXN0cyB0byBwcm92aWRlIGN1c3RvbSBvdXRwdXQuXG4vLyBOb3Rlczpcbi8vIC0gSW4gVjgsIGFsbCBFcnJvciBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZS4gV2UgbmVlZCB0aGlzIG9yIGVsc2Ugc3RyaW5naWZ5KCkgd2lsbCByZXR1cm4gXCJ7fVwiLlxuLy8gLSBJbiBKYXZhU2NyaXB0Q29yZSwgb25seSB0aGUgXCJzdGFja1wiIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlLiBXZSB3YW50IHRvIHJldmVhbCB0aGlzLlxuaWYgKHR5cGVvZiBFcnJvci5wcm90b3R5cGUudG9KU09OICE9PSAnZnVuY3Rpb24nKSB7XG4gIEVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwcm9wZXJ0aWVzW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbmlmIChUaS5QbGF0Zm9ybS5vc25hbWUgPT09ICdpcGhvbmUnIHx8IFRpLlBsYXRmb3JtLm9zbmFtZSA9PT0gJ2lwYWQnKSB7XG4gIHZhciBidWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgIHZhbHVlOiAnJ1xuICB9KTtcbiAgdmFyIGJsb2IgPSBidWZmZXIudG9CbG9iKCk7XG5cbiAgYmxvYi5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbnZhciBjb2xvcnNldDtcbnZhciBvc1ZlcnNpb247IC8vIEFzIEFuZHJvaWQgcGFzc2VzIGEgbmV3IGluc3RhbmNlIG9mIFRpLlVJIHRvIGV2ZXJ5IEpTIGZpbGUgd2UgY2FuJ3QganVzdFxuLy8gVGkuVUkgd2l0aGluIHRoaXMgZmlsZSwgd2UgbXVzdCBjYWxsIGtyb2xsLmJpbmRpbmcgdG8gZ2V0IHRoZSBUaXRhbml1bVxuLy8gbmFtZXNwYWNlIHRoYXQgaXMgcGFzc2VkIGluIHdpdGggcmVxdWlyZSBhbmQgdGhhdCBkZWFsIHdpdGggdGhlIC5VSVxuLy8gbmFtZXNwYWNlIHRoYXQgaXMgb24gdGhhdCBkaXJlY3RseS5cblxudmFyIHVpTW9kdWxlID0gVGkuVUk7XG5cbmlmIChUaS5BbmRyb2lkKSB7XG4gIHVpTW9kdWxlID0ga3JvbGwuYmluZGluZygnVGl0YW5pdW0nKS5UaXRhbml1bS5VSTtcbn1cblxudWlNb2R1bGUuU0VNQU5USUNfQ09MT1JfVFlQRV9MSUdIVCA9ICdsaWdodCc7XG51aU1vZHVsZS5TRU1BTlRJQ19DT0xPUl9UWVBFX0RBUksgPSAnZGFyayc7IC8vIFdlIG5lZWQgdG8gdHJhY2sgdGhpcyBtYW51YWxseSB3aXRoIGEgZ2V0dGVyL3NldHRlclxuLy8gZHVlIHRvIHRoZSBzYW1lIHJlYXNvbnMgd2UgdXNlIHVpTW9kdWxlIGluc3RlYWQgb2YgVGkuVUlcblxudmFyIGN1cnJlbnRDb2xvclR5cGUgPSB1aU1vZHVsZS5TRU1BTlRJQ19DT0xPUl9UWVBFX0xJR0hUO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHVpTW9kdWxlLCAnc2VtYW50aWNDb2xvclR5cGUnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBjdXJyZW50Q29sb3JUeXBlO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChjb2xvclR5cGUpIHtcbiAgICBjdXJyZW50Q29sb3JUeXBlID0gY29sb3JUeXBlO1xuICB9XG59KTtcblxudWlNb2R1bGUuZmV0Y2hTZW1hbnRpY0NvbG9yID0gZnVuY3Rpb24gZmV0Y2hTZW1hbnRpY0NvbG9yKGNvbG9yTmFtZSkge1xuICBpZiAoIW9zVmVyc2lvbikge1xuICAgIG9zVmVyc2lvbiA9IHBhcnNlSW50KFRpLlBsYXRmb3JtLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG4gIH1cblxuICBpZiAoVGkuQXBwLmlPUyAmJiBvc1ZlcnNpb24gPj0gMTMpIHtcbiAgICByZXR1cm4gVGkuVUkuaU9TLmZldGNoU2VtYW50aWNDb2xvcihjb2xvck5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY29sb3JzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbG9yc2V0ID0gcmVxdWlyZSgnL3NlbWFudGljLmNvbG9ycy5qc29uJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWFic29sdXRlLXBhdGhcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZXF1aXJlIGNvbG9ycyBmaWxlIGF0IC9zZW1hbnRpYy5jb2xvcnMuanNvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb2xvcnNldFtjb2xvck5hbWVdW3VpTW9kdWxlLnNlbWFudGljQ29sb3JUeXBlXS5jb2xvciB8fCBjb2xvcnNldFtjb2xvck5hbWVdW3VpTW9kdWxlLnNlbWFudGljQ29sb3JUeXBlXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gbG9va3VwIGNvbG9yIGZvciBcIi5jb25jYXQoY29sb3JOYW1lKSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgdGhlIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB0byB1c2UgdG8gcmVnaXN0ZXIgZm9yIGl0J3MgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciBmb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIHRoZSBsaXN0ZW5lciBjYWxsYmFjay9mdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICogQHBhcmFtIHtib29sZWFufSBwcmVwZW5kIHdoZXRoZXIgdG8gcHJlcGVuZCBvciBhcHBlbmQgdGhlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICovXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnROYW1lLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTsgLy8gaW5pdGlhbGl6ZSBpdFxuICB9IC8vIGlmIHRoZXJlJ3Mgc29tZW9uZSBsaXN0ZW5pbmcgdG8gJ25ld0xpc3RlbmVyJyBldmVudHMsIGVtaXQgdGhhdCAqKmJlZm9yZSoqIHdlIGFkZCB0aGUgbGlzdGVuZXIgKHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvbilcblxuXG4gIGlmIChlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVycy5uZXdMaXN0ZW5lcikge1xuICAgIGVtaXR0ZXIuZW1pdCgnbmV3TGlzdGVuZXInLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHZhciBldmVudExpc3RlbmVycyA9IGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG5cbiAgaWYgKHByZXBlbmQpIHtcbiAgICBldmVudExpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBldmVudExpc3RlbmVyczsgLy8gQ2hlY2sgbWF4IGxpc3RlbmVycyBhbmQgc3BpdCBvdXQgd2FybmluZyBpZiA+XG5cbiAgdmFyIG1heCA9IGVtaXR0ZXIuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gIHZhciBsZW5ndGggPSBldmVudExpc3RlbmVycy5sZW5ndGg7XG5cbiAgaWYgKG1heCA+IDAgJiYgbGVuZ3RoID4gbWF4KSB7XG4gICAgdmFyIHcgPSBuZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiLmNvbmNhdChsZW5ndGgsIFwiIFwiKS5jb25jYXQoZXZlbnROYW1lLCBcIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0XCIpKTtcbiAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICB3LmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHcudHlwZSA9IGV2ZW50TmFtZTtcbiAgICB3LmNvdW50ID0gbGVuZ3RoO1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcodyk7XG4gIH1cblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuZnVuY3Rpb24gb25jZVdyYXAoZW1pdHRlciwgZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy53cmFwcGVkRnVuYyk7IC8vIHJlbW92ZSBvdXJzZWx2ZXNcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMuZW1pdHRlciwgYXJncyk7IC8vIHRoZW4gZm9yd2FyZCB0aGUgZXZlbnQgY2FsbGJhY2tcbiAgfSAvLyB3ZSBoYXZlIHRvIHVzZSBiaW5kIHdpdGggYSBjdXN0b20gJ3RoaXMnLCBiZWNhdXNlIGV2ZW50cyBmaXJlIHdpdGggJ3RoaXMnIHBvaW50aW5nIGF0IHRoZSBlbWl0dGVyXG5cblxuICB2YXIgd3JhcHBlclRoaXMgPSB7XG4gICAgZW1pdHRlcixcbiAgICBldmVudE5hbWUsXG4gICAgbGlzdGVuZXJcbiAgfTtcbiAgdmFyIGJvdW5kID0gd3JhcHBlci5iaW5kKHdyYXBwZXJUaGlzKTsgLy8gYmluZCB0byBmb3JjZSBcInRoaXNcIiB0byByZWZlciB0byBvdXIgY3VzdG9tIG9iamVjdCB0cmFja2luZyB0aGUgd3JhcHBlci9lbWl0dGVyL2xpc3RlbmVyXG5cbiAgYm91bmQubGlzdGVuZXIgPSBsaXN0ZW5lcjsgLy8gaGF2ZSB0byBhZGQgbGlzdGVuZXIgcHJvcGVydHkgZm9yIFwidW53cmFwcGluZ1wiXG5cbiAgd3JhcHBlclRoaXMud3JhcHBlZEZ1bmMgPSBib3VuZDtcbiAgcmV0dXJuIGJvdW5kO1xufSAvLyBtYW55IGNvbnN1bWVycyBtYWtlIHVzZSBvZiB0aGlzIHZpYSB1dGlsLmluaGVyaXRzLCB3aGljaCBkb2VzIG5vdCBjaGFpbiBjb25zdHJ1Y3RvciBjYWxscyFcbi8vIHNvIHdlIG5lZWQgdG8gYmUgYXdhcmUgdGhhdCBfZXZlbnRzVG9MaXN0ZW5lcnMgbWF5ZSBiZSBudWxsL3VuZGVmaW5lZCBvbiBpbnN0YW5jZXMsIGFuZCBjaGVjayBpbiBtZXRob2RzIGJlZm9yZSBhY2Nlc3NpbmcgaXRcblxuXG52YXIgRXZlbnRFbWl0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuXG4gICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRFbWl0dGVyLCBbe1xuICAgIGtleTogXCJhZGRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXBlbmRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMub24oZXZlbnROYW1lLCBvbmNlV3JhcCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXBlbmRPbmNlTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIG9uY2VXcmFwKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBldmVudExpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgICB2YXIgbGVuZ3RoID0gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIHZhciB1bndyYXBwZWRMaXN0ZW5lcjsgLy8gTmVlZCB0byBzZWFyY2ggTElGTywgYW5kIG5lZWQgdG8gaGFuZGxlIHdyYXBwZWQgZnVuY3Rpb25zIChvbmNlIHdyYXBwZXJzKVxuXG4gICAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGV2ZW50TGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICB1bndyYXBwZWRMaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXJzW2ldLmxpc3RlbmVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gbGVuZ3RoIHdhcyAxIGFuZCB3ZSB3YW50IHRvIHJlbW92ZSBsYXN0IGVudHJ5LCBzbyBkZWxldGUgdGhlIGV2ZW50IHR5cGUgZnJvbSBvdXIgbGlzdGVuZXIgbWFwcGluZyBub3chXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2UgaGFkIDIrIGxpc3RlbmVycywgc28gc3RvcmUgYXJyYXkgd2l0aG91dCB0aGlzIGdpdmVuIGxpc3RlbmVyXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGZvdW5kSW5kZXgsIDEpOyAvLyBtb2RpZmllcyBpbiBwbGFjZSwgbm8gbmVlZCB0byBhc3NpZ24gdG8gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXVxuICAgICAgICB9IC8vIERvbid0IGVtaXQgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgZm9yICdyZW1vdmVMaXN0ZW5lcicgdHlwZSFcblxuXG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNUb0xpc3RlbmVycy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCBldmVudE5hbWUsIHVud3JhcHBlZExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50TmFtZSkge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZXZlbnRMaXN0ZW5lcnMuc2xpY2UoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAvLyBtdXN0IG9wZXJhdGUgb24gY29weSBiZWNhdXNlIGxpc3RlbmVycyAsYXkgZ2V0IHJlbW92ZSBhcyBzaWRlLWVmZmVjdCBvZiBjYWxsaW5nXG4gICAgICAgICAgbGlzdGVuZXIuY2FsbC5hcHBseShsaXN0ZW5lciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudExpc3RlbmVycy5sZW5ndGggIT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpc3RlbmVyQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnROYW1lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzIHx8IHt9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gLy8gTmVlZCB0byBcInVud3JhcFwiIG9uY2Ugd3JhcHBlcnMhXG5cblxuICAgICAgdmFyIHJhdyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgICByZXR1cm4gcmF3Lm1hcChmdW5jdGlvbiAobCkge1xuICAgICAgICByZXR1cm4gbC5saXN0ZW5lciB8fCBsO1xuICAgICAgfSk7IC8vIGhlcmUgd2UgdW53cmFwIHRoZSBvbmNlIHdyYXBwZXIgaWYgdGhlcmUgaXMgb25lIG9yIGZhbGwgYmFjayB0byBsaXN0ZW5lciBmdW5jdGlvblxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYXdMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmF3TGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW10pLnNsaWNlKDApOyAvLyByZXR1cm4gYSBjb3B5XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNYXhMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47IC8vIFRPRE86IFR5cGUgY2hlY2sgbiwgbWFrZSBzdXJlID49IDAgKG8gZXF1YWxzIG5vIGxpbWl0KVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQWxsTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307IC8vIGluaXRpYWxpemUgaXRcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAvLyBubyBuZWVkIHRvIGVtaXQhIHdlIGNhbiBqdXN0IHdpcGUhXG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBldmVyeSB0eXBlIVxuICAgICAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHNwZWNpZmljIHR5cGVcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSAvLyB5dWNrLCB3ZSdsbCBoYXZlIHRvIGVtaXQgJ3JlbW92ZUxpc3RlbmVyJyBldmVudHMgYXMgd2UgZ29cblxuXG4gICAgICBpZiAoZXZlbnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0eXBlcyAoYnV0IGRvICdyZW1vdmVMaXN0ZW5lcicgbGFzdCEpXG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZSAhPT0gJ3JlbW92ZUxpc3RlbmVyJztcbiAgICAgICAgfSk7XG4gICAgICAgIG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXJzIGZvciBvbmUgdHlwZSwgYmFjayB0byBmcm9udCAoTGFzdC1pbiwgZmlyc3Qtb3V0LCBleGNlcHQgd2hlcmUgcHJlcGVuZCBmLWVkIGl0IHVwKVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKTtcbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIGV2ZW50TmFtZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vKipcbiAqIEBwYXJhbSAgeyp9IGFyZyBwYXNzZWQgaW4gYXJndW1lbnQgdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBhcmd1bWVudFxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlbmFtZSBpLmUuICdzdHJpbmcnLCAnRnVuY3Rpb24nICh2YWx1ZSBpcyBjb21wYXJlZCB0byB0eXBlb2YgYWZ0ZXIgbG93ZXJjYXNpbmcpXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICovXG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudFR5cGUoYXJnLCBuYW1lLCB0eXBlbmFtZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG5cbiAgaWYgKHR5cGUgIT09IHR5cGVuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBcIikuY29uY2F0KHR5cGVuYW1lLCBcIi4gUmVjZWl2ZWQgdHlwZSBcIikuY29uY2F0KHR5cGUpKTtcbiAgfVxufVxuXG52YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiAnc3RhbmRhcmRpemVzJyB0aGUgcmVwb3J0ZWQgYXJjaGl0ZWN0dXJlcyB0byB0aGUgZXF1aXZhbGVudHMgcmVwb3J0ZWQgYnkgTm9kZS5qc1xuICogbm9kZSB2YWx1ZXM6ICdhcm0nLCAnYXJtNjQnLCAnaWEzMicsICdtaXBzJywgJ21pcHNlbCcsICdwcGMnLCAncHBjNjQnLCAnczM5MCcsICdzMzkweCcsICd4MzInLCBhbmQgJ3g2NCcuXG4gKiBpT1MgdmFsdWVzOiBcImFybTY0XCIsIFwiYXJtdjdcIiwgXCJ4ODZfNjRcIiwgXCJpMzg2XCIsIFwiVW5rbm93blwiXG4gKiBBbmRyb2lkIHZhbHVlczogXCJhcm1lYWJpXCIsIFwiYXJtZWFiaS12N2FcIiwgXCJhcm02NC12OGFcIiwgXCJ4ODZcIiwgXCJ4ODZfNjRcIiwgXCJtaXBzXCIsIFwibWlwczY0XCIsIFwidW5rbm93blwiXG4gKiBXaW5kb3dzIHZhbHVlczogXCJ4NjRcIiwgXCJpYTY0XCIsIFwiQVJNXCIsIFwieDg2XCIsIFwidW5rbm93blwiXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWwgb3JpZ2luYWwgYXJjaGl0ZWN0dXJlIHJlcG9ydGVkIGJ5IFRpLlBsYXRmb3JtXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHN0YW5kYXJkaXplQXJjaChvcmlnaW5hbCkge1xuICBzd2l0Y2ggKG9yaWdpbmFsKSB7XG4gICAgLy8gY29lcmNlICdhcm12NycsICdhcm1lYWJpJywgJ2FybWVhYmktdjdhJywgJ0FSTScgLT4gJ2FybSdcbiAgICAvLyAnYXJtZWFiaScgaXMgYSBkZWFkIEFCSSBmb3IgQW5kcm9pZCwgcmVtb3ZlZCBpbiBOREsgcjE3XG4gICAgY2FzZSAnYXJtdjcnOlxuICAgIGNhc2UgJ2FybWVhYmknOlxuICAgIGNhc2UgJ2FybWVhYmktdjdhJzpcbiAgICBjYXNlICdBUk0nOlxuICAgICAgcmV0dXJuICdhcm0nO1xuICAgIC8vIGNvZXJjZSAnYXJtNjQtdjhhJyAtPiAnYXJtNjQnXG5cbiAgICBjYXNlICdhcm02NC12OGEnOlxuICAgICAgcmV0dXJuICdhcm02NCc7XG4gICAgLy8gY29lcmNlICdpMzg2JywgJ3g4NicgLT4gJ2lhMzInXG5cbiAgICBjYXNlICdpMzg2JzpcbiAgICBjYXNlICd4ODYnOlxuICAgICAgcmV0dXJuICdpYTMyJztcbiAgICAvLyBjb2VyY2UgJ3g4Nl82NCcsICdpYTY0JywgJ3g2NCcgLT4gJ3g2NCdcblxuICAgIGNhc2UgJ3g4Nl82NCc6XG4gICAgY2FzZSAnaWE2NCc6XG4gICAgICByZXR1cm4gJ3g2NCc7XG4gICAgLy8gY29lcmNlICdtaXBzNjQnIC0+ICdtaXBzJyAvLyAnbWlwcycgYW5kICdtaXBzNjQnIGFyZSBkZWFkIEFCSXMgZm9yIEFuZHJvaWQsIHJlbW92ZWQgaW4gTkRLIHIxN1xuXG4gICAgY2FzZSAnbWlwczY0JzpcbiAgICAgIHJldHVybiAnbWlwcyc7XG4gICAgLy8gY29lcmNlICdVbmtub3duJyAtPiAndW5rbm93bidcblxuICAgIGNhc2UgJ1Vua25vd24nOlxuICAgICAgcmV0dXJuICd1bmtub3duJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbn1cblxudmFyIHByb2Nlc3MkNCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxucHJvY2VzcyQ0LmFib3J0ID0gZnVuY3Rpb24gKCkge307IC8vIFRPRE86IERvIHdlIGhhdmUgZXF1aXZhbGVudCBvZiBmb3JjaWJseSBraWxsaW5nIHRoZSBwcm9jZXNzPyBXZSBoYXZlIHJlc3RhcnQsIGJ1dCBJIHRoaW5rIHdlIGp1c3Qgd2FudCBhIG5vLW9wIHN0dWIgaGVyZVxuXG5cbnByb2Nlc3MkNC5hcmNoID0gc3RhbmRhcmRpemVBcmNoKFRpLlBsYXRmb3JtLmFyY2hpdGVjdHVyZSk7XG5wcm9jZXNzJDQuYXJndiA9IFtdOyAvLyBUT0RPOiBXaGF0IG1ha2VzIHNlbnNlIGhlcmU/IHBhdGggdG8gdGl0YW5pdW0gY2xpIGZvciBmaXJzdCBhcmc/IHBhdGggdG8gdGkubWFpbi9hcHAuanMgZm9yIHNlY29uZD9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb2Nlc3MkNCwgJ2FyZ3YwJywge1xuICB2YWx1ZTogJycsXG4gIC8vIFRPRE86IFBhdGggdG8gLmFwcCBvbiBpT1M/XG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5cbnByb2Nlc3MkNC5iaW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyB1bnN1cHBvcnRlZCBhbmQgbm90IHVzZXItZmFjaW5nIEFQSScpO1xufTtcblxucHJvY2VzcyQ0LmNoYW5uZWwgPSB1bmRlZmluZWQ7XG5cbnByb2Nlc3MkNC5jaGRpciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIHVuc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzJDQuY29uZmlnID0ge307XG5wcm9jZXNzJDQuY29ubmVjdGVkID0gZmFsc2U7XG5cbnByb2Nlc3MkNC5jcHVVc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRklYTUU6IENhbiB3ZSBsb29rIGF0IE9TLmNwdXMgdG8gZ2V0IHRoaXMgZGF0YT9cbiAgcmV0dXJuIHtcbiAgICB1c2VyOiAwLFxuICAgIHN5c3RlbTogMFxuICB9O1xufTtcblxucHJvY2VzcyQ0LmN3ZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9fZGlybmFtZTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9jZXNzJDQsICdkZWJ1Z1BvcnQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciB2YWx1ZSA9IDA7IC8vIGRlZmF1bHQgdG8gMFxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChUaS5QbGF0Zm9ybS5vc25hbWUgPT09ICdhbmRyb2lkJykge1xuICAgICAgICB2YXIgYXNzZXRzID0ga3JvbGwuYmluZGluZygnYXNzZXRzJyk7XG4gICAgICAgIHZhciBqc29uID0gYXNzZXRzLnJlYWRBc3NldCgnZGVwbG95Lmpzb24nKTtcblxuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgIHZhciBkZXBsb3lEYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblxuICAgICAgICAgIGlmIChkZXBsb3lEYXRhLmRlYnVnZ2VyUG9ydCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIC0xIG1lYW5zIG5vdCBzZXQgKG5vdCBpbiBkZWJ1ZyBtb2RlKVxuICAgICAgICAgICAgdmFsdWUgPSBkZXBsb3lEYXRhLmRlYnVnZ2VyUG9ydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoVGkuUGxhdGZvcm0ub3NuYW1lID09PSAnaXBob25lJyB8fCBUaS5QbGF0Zm9ybS5vc25hbWUgPT09ICdpcGFkJykge1xuICAgICAgICAvLyBpT1MgaXMgMjc3NTMgYXMgb2YgaW9zIDwgMTEuMyBmb3Igc2ltdWxhdG9yc1xuICAgICAgICAvLyBmb3IgMTEuMysgaXQgdXNlcyBhIHVuaXggc29ja2V0XG4gICAgICAgIC8vIGZvciBkZXZpY2VzLCBpdCB1c2VzIHVzYm11eGRcbiAgICAgICAgdmFsdWUgPSAyNzc1MzsgLy8gVE9ETzogQ2FuIHdlIG9ubHkgcmV0dXJuIHRoaXMgZm9yIHNpbXVsYXRvciA8IDExLjM/XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIGlnbm9yZVxuICAgIC8vIG92ZXJ3cml0ZSB0aGlzIGdldHRlciB3aXRoIHN0YXRpYyB2YWx1ZVxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlYnVnUG9ydCcsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxucHJvY2VzcyQ0LmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7fTsgLy8gbm8tb3BcblxuXG5wcm9jZXNzJDQuZGxvcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuZGxvcGVuIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MkNC5lbWl0V2FybmluZyA9IGZ1bmN0aW9uICh3YXJuaW5nLCBvcHRpb25zLCBjb2RlLCBjdG9yKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIHR5cGU7XG4gIHZhciBkZXRhaWw7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIHR5cGUgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgY29kZSA9IG9wdGlvbnMuY29kZTtcbiAgICBkZXRhaWwgPSBvcHRpb25zLmRldGFpbDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2FybmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUT0RPOiBtYWtlIHVzZSBvZiBgY3RvcmAgYXJnIGZvciBsaW1pdGluZyBzdGFjayB0cmFjZXM/IENhbiBvbmx5IHJlYWxseSBiZSB1c2VkIG9uIFY4XG4gICAgLy8gc2V0IHN0YWNrIHRyYWNlIGxpbWl0IHRvIDAsIHRoZW4gY2FsbCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh3YXJuaW5nLCBjdG9yKTtcbiAgICB3YXJuaW5nID0gbmV3IEVycm9yKHdhcm5pbmcpO1xuICAgIHdhcm5pbmcubmFtZSA9IHR5cGUgfHwgJ1dhcm5pbmcnO1xuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybmluZy5jb2RlID0gY29kZTtcbiAgICB9XG5cbiAgICBpZiAoZGV0YWlsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdhcm5pbmcuZGV0YWlsID0gZGV0YWlsO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBUaHJvdyBUeXBlRXJyb3IgaWYgbm90IGFuIGluc3RhbmNlb2YgRXJyb3IgYXQgdGhpcyBwb2ludCFcblxuXG4gIHZhciBpc0RlcHJlY2F0aW9uID0gd2FybmluZy5uYW1lID09PSAnRGVwcmVjYXRpb25XYXJuaW5nJztcblxuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDQubm9EZXByZWNhdGlvbikge1xuICAgIHJldHVybjsgLy8gaWdub3JlXG4gIH1cblxuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDQudGhyb3dEZXByZWNhdGlvbikge1xuICAgIHRocm93IHdhcm5pbmc7XG4gIH1cblxuICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCB3YXJuaW5nKTtcbn07XG5cbmZ1bmN0aW9uIGxvYWRFbnZKc29uKCkge1xuICB0cnkge1xuICAgIHZhciBqc29uRmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeSwgJ19lbnZfLmpzb24nKTtcblxuICAgIGlmIChqc29uRmlsZS5leGlzdHMoKSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbkZpbGUucmVhZCgpLnRleHQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUaS5BUEkuZXJyb3IoXCJGYWlsZWQgdG8gcmVhZCBcXFwiX2Vudl8uanNvblxcXCIuIFJlYXNvbjogXCIuY29uY2F0KGVycm9yLm1lc3NhZ2UpKTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb2Nlc3MkNCwgJ2VudicsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgZGVsZXRlIHRoaXMuZW52O1xuICAgIHJldHVybiB0aGlzLmVudiA9IGxvYWRFbnZKc29uKCk7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5wcm9jZXNzJDQuZXhlY0FyZ3YgPSBbXTtcbnByb2Nlc3MkNC5leGVjUGF0aCA9ICcnOyAvLyBGSVhNRTogV2hhdCBtYWtlcyBzZW5zZSBoZXJlPyBQYXRoIHRvIHRpdGFuaXVtIENMSSBoZXJlP1xuXG5wcm9jZXNzJDQuZXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmV4aXQgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2VzcyQ0LmV4aXRDb2RlID0gdW5kZWZpbmVkO1xucHJvY2VzcyQ0Lm5vRGVwcmVjYXRpb24gPSBmYWxzZTtcbnByb2Nlc3MkNC5waWQgPSAwOyAvLyBGSVhNRTogU2hvdWxkIHdlIHRyeSBhbmQgYWRvcHQgJ3dpbmRvd3NwaG9uZScvJ3dpbmRvd3NzdG9yZScgdG8gJ3dpbjMyJz9cbi8vIEZJWE1FOiBTaG91bGQgd2UgdHJ5IGFuZCBhZG9wdCAnaXBhZCcvJ2lwaG9uZScgdG8gJ2Rhcndpbic/IG9yICdpb3MnP1xuXG5wcm9jZXNzJDQucGxhdGZvcm0gPSBUaS5QbGF0Zm9ybS5vc25hbWU7XG5wcm9jZXNzJDQucHBpZCA9IDA7IC8vIFRPRE86IEFkZCByZWxlYXNlIHByb3BlcnR5IChPYmplY3QpXG4vLyBUT0RPOiBDYW4gd2UgZXhwb3NlIHN0ZG91dC9zdGRlcnIvc3RkaW4gbmF0aXZlbHk/XG5cbnByb2Nlc3MkNC5zdGRlcnIgPSB7XG4gIGlzVFRZOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgY29uc29sZS5lcnJvcihjaHVuayk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5wcm9jZXNzJDQuc3Rkb3V0ID0ge1xuICBpc1RUWTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGNvbnNvbGUubG9nKGNodW5rKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnByb2Nlc3MkNC50aXRsZSA9IFRpLkFwcC5uYW1lO1xucHJvY2VzcyQ0LnRocm93RGVwcmVjYXRpb24gPSBmYWxzZTtcbnByb2Nlc3MkNC50cmFjZURlcHJlY2F0aW9uID0gZmFsc2U7XG5cbnByb2Nlc3MkNC51bWFzayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59OyAvLyBqdXN0IGFsd2F5cyByZXR1cm4gMFxuXG5cbnByb2Nlc3MkNC51cHRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkaWZmTXMgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmZk1zIC8gMTAwMC4wOyAvLyBjb252ZXJ0IHRvIFwic2Vjb25kc1wiIHdpdGggZnJhY3Rpb25zXG59O1xuXG5wcm9jZXNzJDQudmVyc2lvbiA9IFRpLnZlcnNpb247XG5wcm9jZXNzJDQudmVyc2lvbnMgPSB7XG4gIG1vZHVsZXM6ICcnLFxuICAvLyBUT0RPOiBSZXBvcnQgbW9kdWxlIGFwaSB2ZXJzaW9uIChmb3IgY3VycmVudCBwbGF0Zm9ybSEpXG4gIHY4OiAnJyxcbiAgLy8gVE9ETzogcmVwb3J0IGFuZHJvaWQncyB2OCB2ZXJzaW9uIChpZiBvbiBBbmRyb2lkISlcbiAganNjOiAnJyAvLyBUT0RPOiByZXBvcnQgamF2YXNjcmlwdGNvcmUgdmVyc2lvbiBmb3IgaU9TL1dJbmRvd3M/XG4gIC8vIFRPRE86IFJlcG9ydCBpb3MvQW5kcm9pZC9XaW5kb3dzIHBsYXRmb3JtIHZlcnNpb25zP1xuXG59O1xuZ2xvYmFsLnByb2Nlc3MgPSBwcm9jZXNzJDQ7IC8vIGhhbmRsZSBzcGl0dGluZyBvdXQgd2FybmluZ3NcblxudmFyIFdBUk5JTkdfUFJFRklYID0gXCIodGl0YW5pdW06XCIuY29uY2F0KHByb2Nlc3MkNC5waWQsIFwiKSBcIik7XG5wcm9jZXNzJDQub24oJ3dhcm5pbmcnLCBmdW5jdGlvbiAod2FybmluZykge1xuICB2YXIgaXNEZXByZWNhdGlvbiA9IHdhcm5pbmcubmFtZSA9PT0gJ0RlcHJlY2F0aW9uV2FybmluZyc7IC8vIGlmIHdlJ3JlIG5vdCBkb2luZyBkZXByZWNhdGlvbnMsIGlnbm9yZSFcblxuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDQubm9EZXByZWNhdGlvbikge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBDaGVjayBwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24gYW5kIGlmIHNldCwgaW5jbHVkZSBzdGFjayB0cmFjZSBpbiBtZXNzYWdlIVxuXG5cbiAgdmFyIG1zZyA9IFdBUk5JTkdfUFJFRklYO1xuXG4gIGlmICh3YXJuaW5nLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1zZyArPSBcIltcIi5jb25jYXQod2FybmluZy5jb2RlLCBcIl0gXCIpO1xuICB9XG5cbiAgaWYgKHdhcm5pbmcudG9TdHJpbmcpIHtcbiAgICBtc2cgKz0gd2FybmluZy50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKHdhcm5pbmcuZGV0YWlsKSB7XG4gICAgbXNnICs9IFwiXFxuXCIuY29uY2F0KHdhcm5pbmcuZGV0YWlsKTtcbiAgfVxuXG4gIGNvbnNvbGUuZXJyb3IobXNnKTtcbn0pO1xudmFyIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuXG5wcm9jZXNzJDQuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrICE9PSBudWxsO1xufTtcblxucHJvY2VzcyQ0LnNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmIChmbiA9PT0gbnVsbCkge1xuICAgIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydEFyZ3VtZW50VHlwZShmbiwgJ2ZuJywgJ2Z1bmN0aW9uJyk7XG5cbiAgaWYgKHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9jZXNzLnNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrKClgIHdhcyBjYWxsZWQgd2hpbGUgYSBjYXB0dXJlIGNhbGxiYWNrIHdhcyBhbHJlYWR5IGFjdGl2ZScpO1xuICB9XG5cbiAgdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayA9IGZuO1xufTtcblxuVGkuQXBwLmFkZEV2ZW50TGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIENyZWF0ZSBhbiBFcnJvciBpbnN0YW5jZSB0aGF0IHdyYXBzIHRoZSBkYXRhIGZyb20gdGhlIGV2ZW50XG4gIC8vIGlkZWFsbHkgd2UnZCBqdXN0IGZvcndhcmQgYWxvbmcgdGhlIG9yaWdpbmFsIEVycm9yIVxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXZlbnQubWVzc2FnZSk7XG4gIGVycm9yLnN0YWNrID0gZXZlbnQuYmFja3RyYWNlO1xuICBlcnJvci5maWxlTmFtZSA9IGV2ZW50LnNvdXJjZU5hbWU7XG4gIGVycm9yLmxpbmVOdW1iZXIgPSBldmVudC5saW5lO1xuICBlcnJvci5jb2x1bW5OdW1iZXIgPSBldmVudC5saW5lT2Zmc2V0O1xuXG4gIGlmIChwcm9jZXNzJDQuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2soKSkge1xuICAgIHJldHVybiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrKGVycm9yKTtcbiAgfSAvLyBvdGhlcndpc2UgZm9yd2FyZCB0aGUgZXZlbnQhXG5cblxuICBwcm9jZXNzJDQuZW1pdCgndW5jYXVnaHRFeGNlcHRpb24nLCBlcnJvcik7XG59KTtcbi8vIEpTIGVuZ2luZSBzaG91bGQgYmUgYWJsZSB0byBvcHRpbWl6ZSBlYXNpZXJcblxudmFyIENhbGxiYWNrV2l0aEFyZ3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYWxsYmFja1dpdGhBcmdzKGZ1bmMsIGFyZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsbGJhY2tXaXRoQXJncyk7XG5cbiAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FsbGJhY2tXaXRoQXJncywgW3tcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIGlmICh0aGlzLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5mdW5jLmFwcGx5KG51bGwsIHRoaXMuYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZ1bigpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYWxsYmFja1dpdGhBcmdzO1xufSgpOyAvLyBuZXh0VGljayB2cyBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIGhhbmRsZWQgaW4gYSBzZW1pLXNtYXJ0IHdheVxuLy8gQmFzaWNhbGx5IG5leHRUaWNrIG5lZWRzIHRvIGRyYWluIHRoZSBmdWxsIHF1ZXVlIChhbmQgY2FuIGNhdXNlIGluZmluaXRlIGxvb3BzIGlmIG5leHRUaWNrIGNhbGxiYWNrIGNhbGxzIG5leHRUaWNrISlcbi8vIFRoZW4gd2Ugc2hvdWxkIGdvIHRocm91Z2ggdGhlIFwiaW1tZWRpYXRlXCIgcXVldWVcbi8vIGh0dHA6Ly9wbGFmZXIuZ2l0aHViLmlvLzIwMTUvMDkvMDgvbmV4dFRpY2stdnMtc2V0SW1tZWRpYXRlL1xuXG5cbnZhciB0aWNrUXVldWUgPSBbXTtcbnZhciBpbW1lZGlhdGVRdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nVGlja1F1ZXVlID0gZmFsc2U7XG52YXIgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gbnVsbDtcbi8qKlxuICogSXRlcmF0aXZlbHkgcnVucyBhbGwgXCJ0aWNrc1wiIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlLlxuICogVGhpcyBjYW4gY2F1c2UgaW5maW5pdGUgcmVjdXJzaW9uIGlmIGEgdGljayBzY2hlZHVsZXMgYW5vdGhlciBmb3JldmVyLlxuICovXG5cbmZ1bmN0aW9uIGRyYWluVGlja1F1ZXVlKCkge1xuICBpZiAoZHJhaW5pbmdUaWNrUXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkcmFpbmluZ1RpY2tRdWV1ZSA9IHRydWU7XG5cbiAgd2hpbGUgKHRpY2tRdWV1ZS5sZW5ndGgpIHtcbiAgICB2YXIgdGljayA9IHRpY2tRdWV1ZS5zaGlmdCgpO1xuICAgIHRpY2sucnVuKCk7XG4gIH1cblxuICBkcmFpbmluZ1RpY2tRdWV1ZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlcygpIHtcbiAgLy8gZHJhaW4gdGhlIGZ1bGwgdGljayBxdWV1ZSBmaXJzdC4uLlxuICBkcmFpblRpY2tRdWV1ZSgpOyAvLyB0aWNrIHF1ZXVlIHNob3VsZCBiZSBlbXB0eSFcblxuICB2YXIgaW1tZWRpYXRlc1JlbWFpbmluZyA9IHByb2Nlc3NJbW1lZGlhdGVRdWV1ZSgpO1xuXG4gIGlmIChpbW1lZGlhdGVzUmVtYWluaW5nICE9PSAwKSB7XG4gICAgLy8gcmUtc2NoZWR1bGUgZHJhaW5pbmcgb3VyIHF1ZXVlcywgYXMgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgbW9yZSBcImltbWVkaWF0ZVwiIHRvIGhhbmRsZVxuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9IGVsc2Uge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IG51bGw7XG4gIH1cbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gcHJvY2VzcyBcImltbWVkaWF0ZXNcIiAoaW4gYSBtdWNoIG1vcmUgbGVpc3VyZWx5IHdheSB0aGFuIHRpY2tzKVxuICogV2UgZ2l2ZSBhIDEwMG1zIHdpbmRvdyB0byBydW4gdGhlbSBpbiBiZWZvcmUgcmUtc2NoZWR1bGluZyB0aGUgdGltZW91dCB0byBwcm9jZXNzIHRoZW0gYWdhaW4uXG4gKiBJZiBhbnkgdGlja3MgYXJlIGFkZGVkIGR1cmluZyBpbnZvY2F0aW9uIG9mIGltbWVkaWF0ZSwgd2UgZHJhaW4gdGhlIHRpY2sgcXVldWUgZnVsbHkgYmVmb3JlXG4gKiBwcm9jZWVkaW5nIHRvIG5leHQgaW1tZWRpYXRlIChpZiB3ZSBzdGlsbCBoYXZlIHRpbWUgaW4gb3VyIHdpbmRvdykuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgb2YgcmVtYWluaW5nIGltbWVkaWF0ZXMgdG8gYmUgcHJvY2Vzc2VkXG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzSW1tZWRpYXRlUXVldWUoKSB7XG4gIHZhciBpbW1lZGlhdGVEZWFkbGluZSA9IERhdGUubm93KCkgKyAxMDA7IC8vIGdpdmUgdXMgdXAgdG8gMTAwbXMgdG8gcHJvY2VzcyBpbW1lZGlhdGVzXG5cbiAgd2hpbGUgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCAmJiBEYXRlLm5vdygpIDwgaW1tZWRpYXRlRGVhZGxpbmUpIHtcbiAgICB2YXIgaW1tZWRpYXRlID0gaW1tZWRpYXRlUXVldWUuc2hpZnQoKTtcbiAgICBpbW1lZGlhdGUucnVuKCk7XG5cbiAgICBpZiAodGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHRoZXkgYWRkZWQgYSB0aWNrISBkcmFpbiB0aGUgdGljayBxdWV1ZSBiZWZvcmUgd2UgZG8gYW55dGhpbmcgZWxzZSAodGhpcyAqbWF5KiBlYXQgdXAgb3VyIGRlYWRsaW5lL3dpbmRvdyB0byBwcm9jZXNzIGFueSBtb3JlIGltbWVkaWF0ZXMpXG4gICAgICBkcmFpblRpY2tRdWV1ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbW1lZGlhdGVRdWV1ZS5sZW5ndGg7XG59XG5cbnByb2Nlc3MkNC5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY2FsbGJhY2ssICdjYWxsYmFjaycsICdmdW5jdGlvbicpO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHRpY2tRdWV1ZS5wdXNoKG5ldyBDYWxsYmFja1dpdGhBcmdzKGNhbGxiYWNrLCBhcmdzKSk7XG5cbiAgaWYgKCFkcmFpblF1ZXVlc1RpbWVvdXQpIHtcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRyYWluUXVldWVzLCAwKTtcbiAgfVxufTtcblxuZ2xvYmFsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY2FsbGJhY2ssICdjYWxsYmFjaycsICdmdW5jdGlvbicpO1xuXG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHZhciBpbW1lZGlhdGUgPSBuZXcgQ2FsbGJhY2tXaXRoQXJncyhjYWxsYmFjaywgYXJncyk7XG4gIGltbWVkaWF0ZVF1ZXVlLnB1c2goaW1tZWRpYXRlKTtcblxuICBpZiAoIWRyYWluUXVldWVzVGltZW91dCkge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9XG5cbiAgcmV0dXJuIGltbWVkaWF0ZTtcbn07XG5cbmdsb2JhbC5jbGVhckltbWVkaWF0ZSA9IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgdmFyIGluZGV4ID0gaW1tZWRpYXRlUXVldWUuaW5kZXhPZihpbW1lZGlhdGUpO1xuXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBpbW1lZGlhdGVRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG52YXIgaXNXaW4zMiA9IFRpLlBsYXRmb3JtLm9zbmFtZSA9PT0gJ3dpbmRvd3NwaG9uZScgfHwgVGkuUGxhdGZvcm0ub3NuYW1lID09PSAnd2luZG93c3N0b3JlJztcbnZhciBGT1JXQVJEX1NMQVNIID0gNDc7IC8vICcvJ1xuXG52YXIgQkFDS1dBUkRfU0xBU0ggPSA5MjsgLy8gJ1xcXFwnXG5cbi8qKlxuICogSXMgdGhpcyBbYS16QS1aXT9cbiAqIEBwYXJhbSAge251bWJlcn0gIGNoYXJDb2RlIHZhbHVlIGZyb20gU3RyaW5nLmNoYXJDb2RlQXQoKVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cbmZ1bmN0aW9uIGlzV2luZG93c0RldmljZU5hbWUoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDkwIHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEyMjtcbn1cbi8qKlxuICogW2lzQWJzb2x1dGUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtib29sZWFufSBpc1Bvc2l4IHdoZXRoZXIgdGhpcyBpbXBsIGlzIGZvciBQT1NJWCBvciBub3RcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIF9pc0Fic29sdXRlKGlzUG9zaXgsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIHZhciBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7IC8vIGVtcHR5IHN0cmluZyBzcGVjaWFsIGNhc2VcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0Q2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHdlIGFscmVhZHkgZGlkIG91ciBjaGVja3MgZm9yIHBvc2l4XG5cblxuICBpZiAoaXNQb3NpeCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyB3aW4zMiBmcm9tIGhlcmUgb24gb3V0XG5cblxuICBpZiAoZmlyc3RDaGFyID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDIgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXIpICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgdmFyIHRoaXJkQ2hhciA9IGZpbGVwYXRoLmNoYXJBdCgyKTtcbiAgICByZXR1cm4gdGhpcmRDaGFyID09PSAnLycgfHwgdGhpcmRDaGFyID09PSAnXFxcXCc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFtkaXJuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gX2Rpcm5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICB2YXIgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJy4nO1xuICB9IC8vIGlnbm9yZSB0cmFpbGluZyBzZXBhcmF0b3JcblxuXG4gIHZhciBmcm9tSW5kZXggPSBsZW5ndGggLSAxO1xuICB2YXIgaGFkVHJhaWxpbmcgPSBmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpO1xuXG4gIGlmIChoYWRUcmFpbGluZykge1xuICAgIGZyb21JbmRleC0tO1xuICB9XG5cbiAgdmFyIGZvdW5kSW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZihzZXBhcmF0b3IsIGZyb21JbmRleCk7IC8vIG5vIHNlcGFyYXRvcnNcblxuICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIHtcbiAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIHJvb3Qgd2luZG93cyBwYXRoc1xuICAgIGlmIChsZW5ndGggPj0gMiAmJiBzZXBhcmF0b3IgPT09ICdcXFxcJyAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgICAgdmFyIGZpcnN0Q2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgIGlmIChpc1dpbmRvd3NEZXZpY2VOYW1lKGZpcnN0Q2hhcikpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVwYXRoOyAvLyBpdCdzIGEgcm9vdCB3aW5kb3dzIHBhdGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJy4nO1xuICB9IC8vIG9ubHkgZm91bmQgcm9vdCBzZXBhcmF0b3JcblxuXG4gIGlmIChmb3VuZEluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuIHNlcGFyYXRvcjsgLy8gaWYgaXQgd2FzICcvJywgcmV0dXJuIHRoYXRcbiAgfSAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIG9mICcvL3NvbWV0aGluZydcblxuXG4gIGlmIChmb3VuZEluZGV4ID09PSAxICYmIHNlcGFyYXRvciA9PT0gJy8nICYmIGZpbGVwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuICcvLyc7XG4gIH1cblxuICByZXR1cm4gZmlsZXBhdGguc2xpY2UoMCwgZm91bmRJbmRleCk7XG59XG4vKipcbiAqIFtleHRuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gX2V4dG5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICB2YXIgaW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZignLicpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuXG5cbiAgdmFyIGVuZEluZGV4ID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpKSB7XG4gICAgZW5kSW5kZXgtLTtcbiAgfVxuXG4gIHJldHVybiBmaWxlcGF0aC5zbGljZShpbmRleCwgZW5kSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBsYXN0SW5kZXhXaW4zMlNlcGFyYXRvcihmaWxlcGF0aCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBjaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChjaGFyID09PSBCQUNLV0FSRF9TTEFTSCB8fCBjaGFyID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG4vKipcbiAqIFtiYXNlbmFtZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yICBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHBhcmFtICB7c3RyaW5nfSBbZXh0XSAgICAgIGZpbGUgZXh0ZW5zaW9uIHRvIGRyb3AgaWYgaXQgZXhpc3RzXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gX2Jhc2VuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgsIGV4dCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuXG4gIGlmIChleHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydEFyZ3VtZW50VHlwZShleHQsICdleHQnLCAnc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nO1xuICB2YXIgZW5kSW5kZXggPSBsZW5ndGg7IC8vIGRyb3AgdHJhaWxpbmcgc2VwYXJhdG9yIChpZiB0aGVyZSBpcyBvbmUpXG5cbiAgdmFyIGxhc3RDaGFyQ29kZSA9IGZpbGVwYXRoLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSk7XG5cbiAgaWYgKGxhc3RDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCB8fCAhaXNQb3NpeCAmJiBsYXN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgZW5kSW5kZXgtLTtcbiAgfSAvLyBGaW5kIGxhc3Qgb2NjdXJlbmNlIG9mIHNlcGFyYXRvclxuXG5cbiAgdmFyIGxhc3RJbmRleCA9IC0xO1xuXG4gIGlmIChpc1Bvc2l4KSB7XG4gICAgbGFzdEluZGV4ID0gZmlsZXBhdGgubGFzdEluZGV4T2Yoc2VwYXJhdG9yLCBlbmRJbmRleCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uIHdpbjMyLCBoYW5kbGUgKmVpdGhlciogc2VwYXJhdG9yIVxuICAgIGxhc3RJbmRleCA9IGxhc3RJbmRleFdpbjMyU2VwYXJhdG9yKGZpbGVwYXRoLCBlbmRJbmRleCAtIDEpOyAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIHJvb3QgcGF0aCBsaWtlICdDOicgb3IgJ0M6XFxcXCdcblxuICAgIGlmICgobGFzdEluZGV4ID09PSAyIHx8IGxhc3RJbmRleCA9PT0gLTEpICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonICYmIGlzV2luZG93c0RldmljZU5hbWUoZmlsZXBhdGguY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0gLy8gVGFrZSBmcm9tIGxhc3Qgb2NjdXJyZW5jZSBvZiBzZXBhcmF0b3IgdG8gZW5kIG9mIHN0cmluZyAob3IgYmVnaW5uaW5nIHRvIGVuZCBpZiBub3QgZm91bmQpXG5cblxuICB2YXIgYmFzZSA9IGZpbGVwYXRoLnNsaWNlKGxhc3RJbmRleCArIDEsIGVuZEluZGV4KTsgLy8gZHJvcCB0cmFpbGluZyBleHRlbnNpb24gKGlmIHNwZWNpZmllZClcblxuICBpZiAoZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHJldHVybiBiYXNlLmVuZHNXaXRoKGV4dCkgPyBiYXNlLnNsaWNlKDAsIGJhc2UubGVuZ3RoIC0gZXh0Lmxlbmd0aCkgOiBiYXNlO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgubm9ybWFsaXplKClgIG1ldGhvZCBub3JtYWxpemVzIHRoZSBnaXZlbiBwYXRoLCByZXNvbHZpbmcgJy4uJyBhbmQgJy4nIHNlZ21lbnRzLlxuICpcbiAqIFdoZW4gbXVsdGlwbGUsIHNlcXVlbnRpYWwgcGF0aCBzZWdtZW50IHNlcGFyYXRpb24gY2hhcmFjdGVycyBhcmUgZm91bmQgKGUuZy5cbiAqIC8gb24gUE9TSVggYW5kIGVpdGhlciBcXCBvciAvIG9uIFdpbmRvd3MpLCB0aGV5IGFyZSByZXBsYWNlZCBieSBhIHNpbmdsZVxuICogaW5zdGFuY2Ugb2YgdGhlIHBsYXRmb3JtLXNwZWNpZmljIHBhdGggc2VnbWVudCBzZXBhcmF0b3IgKC8gb24gUE9TSVggYW5kIFxcXG4gKiBvbiBXaW5kb3dzKS4gVHJhaWxpbmcgc2VwYXJhdG9ycyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBwYXRoIGlzIGEgemVyby1sZW5ndGggc3RyaW5nLCAnLicgaXMgcmV0dXJuZWQsIHJlcHJlc2VudGluZyB0aGVcbiAqIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gX25vcm1hbGl6ZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG5cbiAgaWYgKGZpbGVwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnLic7XG4gIH0gLy8gV2luZG93cyBjYW4gaGFuZGxlICcvJyBvciAnXFxcXCcgYW5kIGJvdGggc2hvdWxkIGJlIHR1cm5lZCBpbnRvIHNlcGFyYXRvclxuXG5cbiAgdmFyIGlzV2luZG93cyA9IHNlcGFyYXRvciA9PT0gJ1xcXFwnO1xuXG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICBmaWxlcGF0aCA9IGZpbGVwYXRoLnJlcGxhY2UoL1xcLy9nLCBzZXBhcmF0b3IpO1xuICB9XG5cbiAgdmFyIGhhZExlYWRpbmcgPSBmaWxlcGF0aC5zdGFydHNXaXRoKHNlcGFyYXRvcik7IC8vIE9uIFdpbmRvd3MsIG5lZWQgdG8gaGFuZGxlIFVOQyBwYXRocyAoXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFxkaXIpIHNwZWNpYWwgdG8gcmV0YWluIGxlYWRpbmcgZG91YmxlIGJhY2tzbGFzaFxuXG4gIHZhciBpc1VOQyA9IGhhZExlYWRpbmcgJiYgaXNXaW5kb3dzICYmIGZpbGVwYXRoLmxlbmd0aCA+IDIgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnXFxcXCc7XG4gIHZhciBoYWRUcmFpbGluZyA9IGZpbGVwYXRoLmVuZHNXaXRoKHNlcGFyYXRvcik7XG4gIHZhciBwYXJ0cyA9IGZpbGVwYXRoLnNwbGl0KHNlcGFyYXRvcik7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcGFydHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDAgJiYgc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpOyAvLyBGSVhNRTogV2hhdCBpZiB0aGlzIGdvZXMgYWJvdmUgcm9vdD8gU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZWQgPSBoYWRMZWFkaW5nID8gc2VwYXJhdG9yIDogJyc7XG4gIG5vcm1hbGl6ZWQgKz0gcmVzdWx0LmpvaW4oc2VwYXJhdG9yKTtcblxuICBpZiAoaGFkVHJhaWxpbmcpIHtcbiAgICBub3JtYWxpemVkICs9IHNlcGFyYXRvcjtcbiAgfVxuXG4gIGlmIChpc1VOQykge1xuICAgIG5vcm1hbGl6ZWQgPSAnXFxcXCcgKyBub3JtYWxpemVkO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG4vKipcbiAqIFthc3NlcnRTZWdtZW50IGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Kn0gc2VnbWVudCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHt2b2lkfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydFNlZ21lbnQoc2VnbWVudCkge1xuICBpZiAodHlwZW9mIHNlZ21lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIuY29uY2F0KHNlZ21lbnQpKTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgYHBhdGguam9pbigpYCBtZXRob2Qgam9pbnMgYWxsIGdpdmVuIHBhdGggc2VnbWVudHMgdG9nZXRoZXIgdXNpbmcgdGhlXG4gKiBwbGF0Zm9ybS1zcGVjaWZpYyBzZXBhcmF0b3IgYXMgYSBkZWxpbWl0ZXIsIHRoZW4gbm9ybWFsaXplcyB0aGUgcmVzdWx0aW5nIHBhdGguXG4gKiBaZXJvLWxlbmd0aCBwYXRoIHNlZ21lbnRzIGFyZSBpZ25vcmVkLiBJZiB0aGUgam9pbmVkIHBhdGggc3RyaW5nIGlzIGEgemVyby1cbiAqIGxlbmd0aCBzdHJpbmcgdGhlbiAnLicgd2lsbCBiZSByZXR1cm5lZCwgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSBwYXRocyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgIFRoZSBqb2luZWQgZmlsZXBhdGhcbiAqL1xuXG5cbmZ1bmN0aW9uIF9qb2luKHNlcGFyYXRvciwgcGF0aHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBuYWl2ZSBpbXBsOiBqdXN0IGpvaW4gYWxsIHRoZSBwYXRocyB3aXRoIHNlcGFyYXRvclxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBwYXRoc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSBfc3RlcDIudmFsdWU7XG4gICAgICBhc3NlcnRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfbm9ybWFsaXplKHNlcGFyYXRvciwgcmVzdWx0LmpvaW4oc2VwYXJhdG9yKSk7XG59XG4vKipcbiAqIFRoZSBgcGF0aC5yZXNvbHZlKClgIG1ldGhvZCByZXNvbHZlcyBhIHNlcXVlbmNlIG9mIHBhdGhzIG9yIHBhdGggc2VnbWVudHMgaW50byBhbiBhYnNvbHV0ZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmdbXX0gcGF0aHMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBfcmVzb2x2ZShzZXBhcmF0b3IsIHBhdGhzKSB7XG4gIHZhciByZXNvbHZlZCA9ICcnO1xuICB2YXIgaGl0Um9vdCA9IGZhbHNlO1xuICB2YXIgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nOyAvLyBnbyBmcm9tIHJpZ2h0IHRvIGxlZnQgdW50aWwgd2UgaGl0IGFic29sdXRlIHBhdGgvcm9vdFxuXG4gIGZvciAodmFyIGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBzZWdtZW50ID0gcGF0aHNbaV07XG4gICAgYXNzZXJ0U2VnbWVudChzZWdtZW50KTtcblxuICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7IC8vIHNraXAgZW1wdHlcbiAgICB9XG5cbiAgICByZXNvbHZlZCA9IHNlZ21lbnQgKyBzZXBhcmF0b3IgKyByZXNvbHZlZDsgLy8gcHJlcGVuZCBuZXcgc2VnbWVudFxuXG4gICAgaWYgKF9pc0Fic29sdXRlKGlzUG9zaXgsIHNlZ21lbnQpKSB7XG4gICAgICAvLyBoYXZlIHdlIGJhY2tlZCBpbnRvIGFuIGFic29sdXRlIHBhdGg/XG4gICAgICBoaXRSb290ID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBpZiB3ZSBkaWRuJ3QgaGl0IHJvb3QsIHByZXBlbmQgY3dkXG5cblxuICBpZiAoIWhpdFJvb3QpIHtcbiAgICByZXNvbHZlZCA9IHByb2Nlc3MuY3dkKCkgKyBzZXBhcmF0b3IgKyByZXNvbHZlZDtcbiAgfVxuXG4gIHZhciBub3JtYWxpemVkID0gX25vcm1hbGl6ZShzZXBhcmF0b3IsIHJlc29sdmVkKTtcblxuICBpZiAobm9ybWFsaXplZC5jaGFyQXQobm9ybWFsaXplZC5sZW5ndGggLSAxKSA9PT0gc2VwYXJhdG9yKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgb24gV2luZG93cyBhcyB3ZWxsLCBzbyB3ZSBkb24ndCB0cmltIHRyYWlsaW5nIHNlcGFyYXRvciBvbiBzb21ldGhpbmcgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcJ1xuICAgIC8vIERvbid0IHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3IgaWYgdGhpcyBpcyByb290IHBhdGggb24gd2luZG93cyFcbiAgICBpZiAoIWlzUG9zaXggJiYgbm9ybWFsaXplZC5sZW5ndGggPT09IDMgJiYgbm9ybWFsaXplZC5jaGFyQXQoMSkgPT09ICc6JyAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKG5vcm1hbGl6ZWQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH0gLy8gb3RoZXJ3aXNlIHRyaW0gdHJhaWxpbmcgc2VwYXJhdG9yXG5cblxuICAgIHJldHVybiBub3JtYWxpemVkLnNsaWNlKDAsIG5vcm1hbGl6ZWQubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnJlbGF0aXZlKClgIG1ldGhvZCByZXR1cm5zIHRoZSByZWxhdGl2ZSBwYXRoIGBmcm9tYCBmcm9tIHRvIGB0b2AgYmFzZWRcbiAqIG9uIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBJZiBmcm9tIGFuZCB0byBlYWNoIHJlc29sdmUgdG8gdGhlIHNhbWVcbiAqIHBhdGggKGFmdGVyIGNhbGxpbmcgYHBhdGgucmVzb2x2ZSgpYCBvbiBlYWNoKSwgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKlxuICogSWYgYSB6ZXJvLWxlbmd0aCBzdHJpbmcgaXMgcGFzc2VkIGFzIGBmcm9tYCBvciBgdG9gLCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICogd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIHplcm8tbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZnJvbSBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRvICAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIF9yZWxhdGl2ZShzZXBhcmF0b3IsIGZyb20sIHRvKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmcm9tLCAnZnJvbScsICdzdHJpbmcnKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHRvLCAndG8nLCAnc3RyaW5nJyk7XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnJvbSA9IF9yZXNvbHZlKHNlcGFyYXRvciwgW2Zyb21dKTtcbiAgdG8gPSBfcmVzb2x2ZShzZXBhcmF0b3IsIFt0b10pO1xuXG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyB3ZSBub3cgaGF2ZSB0d28gYWJzb2x1dGUgcGF0aHMsXG4gIC8vIGxldHMgXCJnbyB1cFwiIGZyb20gYGZyb21gIHVudGlsIHdlIHJlYWNoIGNvbW1vbiBiYXNlIGRpciBvZiBgdG9gXG4gIC8vIGNvbnN0IG9yaWdpbmFsRnJvbSA9IGZyb207XG5cblxuICB2YXIgdXBDb3VudCA9IDA7XG4gIHZhciByZW1haW5pbmdQYXRoID0gJyc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodG8uc3RhcnRzV2l0aChmcm9tKSkge1xuICAgICAgLy8gbWF0Y2ghIHJlY29yZCByZXN0Li4uP1xuICAgICAgcmVtYWluaW5nUGF0aCA9IHRvLnNsaWNlKGZyb20ubGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gRklYTUU6IEJyZWFrL3Rocm93IGlmIHdlIGhpdCBiYWQgZWRnZSBjYXNlIG9mIG5vIGNvbW1vbiByb290IVxuXG5cbiAgICBmcm9tID0gX2Rpcm5hbWUoc2VwYXJhdG9yLCBmcm9tKTtcbiAgICB1cENvdW50Kys7XG4gIH0gLy8gcmVtb3ZlIGxlYWRpbmcgc2VwYXJhdG9yIGZyb20gcmVtYWluaW5nUGF0aCBpZiB0aGVyZSBpcyBhbnlcblxuXG4gIGlmIChyZW1haW5pbmdQYXRoLmxlbmd0aCA+IDApIHtcbiAgICByZW1haW5pbmdQYXRoID0gcmVtYWluaW5nUGF0aC5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiAoJy4uJyArIHNlcGFyYXRvcikucmVwZWF0KHVwQ291bnQpICsgcmVtYWluaW5nUGF0aDtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnBhcnNlKClgIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIHJlcHJlc2VudFxuICogc2lnbmlmaWNhbnQgZWxlbWVudHMgb2YgdGhlIHBhdGguIFRyYWlsaW5nIGRpcmVjdG9yeSBzZXBhcmF0b3JzIGFyZSBpZ25vcmVkLFxuICogc2VlIGBwYXRoLnNlcGAuXG4gKlxuICogVGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gZGlyIDxzdHJpbmc+XG4gKiAtIHJvb3QgPHN0cmluZz5cbiAqIC0gYmFzZSA8c3RyaW5nPlxuICogLSBuYW1lIDxzdHJpbmc+XG4gKiAtIGV4dCA8c3RyaW5nPlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5cblxuZnVuY3Rpb24gX3BhcnNlKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICByb290OiAnJyxcbiAgICBkaXI6ICcnLFxuICAgIGJhc2U6ICcnLFxuICAgIGV4dDogJycsXG4gICAgbmFtZTogJydcbiAgfTtcbiAgdmFyIGxlbmd0aCA9IGZpbGVwYXRoLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyBDaGVhdCBhbmQganVzdCBjYWxsIG91ciBvdGhlciBtZXRob2RzIGZvciBkaXJuYW1lL2Jhc2VuYW1lL2V4dG5hbWU/XG5cblxuICByZXN1bHQuYmFzZSA9IF9iYXNlbmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoKTtcbiAgcmVzdWx0LmV4dCA9IF9leHRuYW1lKHNlcGFyYXRvciwgcmVzdWx0LmJhc2UpO1xuICB2YXIgYmFzZUxlbmd0aCA9IHJlc3VsdC5iYXNlLmxlbmd0aDtcbiAgcmVzdWx0Lm5hbWUgPSByZXN1bHQuYmFzZS5zbGljZSgwLCBiYXNlTGVuZ3RoIC0gcmVzdWx0LmV4dC5sZW5ndGgpO1xuICB2YXIgdG9TdWJ0cmFjdCA9IGJhc2VMZW5ndGggPT09IDAgPyAwIDogYmFzZUxlbmd0aCArIDE7XG4gIHJlc3VsdC5kaXIgPSBmaWxlcGF0aC5zbGljZSgwLCBmaWxlcGF0aC5sZW5ndGggLSB0b1N1YnRyYWN0KTsgLy8gZHJvcCB0cmFpbGluZyBzZXBhcmF0b3IhXG5cbiAgdmFyIGZpcnN0Q2hhckNvZGUgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KDApOyAvLyBib3RoIHdpbjMyIGFuZCBQT1NJWCByZXR1cm4gJy8nIHJvb3RcblxuICBpZiAoZmlyc3RDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJlc3VsdC5yb290ID0gJy8nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gd2UncmUgZG9uZSB3aXRoIFBPU0lYLi4uXG5cblxuICBpZiAoc2VwYXJhdG9yID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IC8vIGZvciB3aW4zMi4uLlxuXG5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcZmlsZV9wYXRoJ1xuICAgIC8vIG5lZWQgdG8gcmV0YWluICdcXFxcXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFwnIGFzIHJvb3QgaW4gdGhhdCBjYXNlIVxuICAgIHJlc3VsdC5yb290ID0gJ1xcXFwnO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gY2hlY2sgZm9yIEM6IHN0eWxlIHJvb3RcblxuXG4gIGlmIChsZW5ndGggPiAxICYmIGlzV2luZG93c0RldmljZU5hbWUoZmlyc3RDaGFyQ29kZSkgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgLy8gaXMgaXQgbGlrZSBDOlxcXFw/XG4gICAgICB2YXIgdGhpcmRDaGFyQ29kZSA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMik7XG5cbiAgICAgIGlmICh0aGlyZENoYXJDb2RlID09PSBGT1JXQVJEX1NMQVNIIHx8IHRoaXJkQ2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgIHJlc3VsdC5yb290ID0gZmlsZXBhdGguc2xpY2UoMCwgMyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSAvLyBub3BlLCBqdXN0IEM6LCBubyB0cmFpbGluZyBzZXBhcmF0b3JcblxuXG4gICAgcmVzdWx0LnJvb3QgPSBmaWxlcGF0aC5zbGljZSgwLCAyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFRoZSBgcGF0aC5mb3JtYXQoKWAgbWV0aG9kIHJldHVybnMgYSBwYXRoIHN0cmluZyBmcm9tIGFuIG9iamVjdC4gVGhpcyBpcyB0aGVcbiAqIG9wcG9zaXRlIG9mIGBwYXRoLnBhcnNlKClgLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBhdGhPYmplY3Qgb2JqZWN0IG9mIGZvcm1hdCByZXR1cm5lZCBieSBgcGF0aC5wYXJzZSgpYFxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LmRpciBkaXJlY3RvcnkgbmFtZVxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LnJvb3QgZmlsZSByb290IGRpciwgaWdub3JlZCBpZiBgcGF0aE9iamVjdC5kaXJgIGlzIHByb3ZpZGVkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QuYmFzZSBmaWxlIGJhc2VuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QubmFtZSBiYXNlbmFtZSBtaW51cyBleHRlbnNpb24sIGlnbm9yZWQgaWYgYHBhdGhPYmplY3QuYmFzZWAgZXhpc3RzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QuZXh0IGZpbGUgZXh0ZW5zaW9uLCBpZ25vcmVkIGlmIGBwYXRoT2JqZWN0LmJhc2VgIGV4aXN0c1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gX2Zvcm1hdChzZXBhcmF0b3IsIHBhdGhPYmplY3QpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHBhdGhPYmplY3QsICdwYXRoT2JqZWN0JywgJ29iamVjdCcpO1xuICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCBcIlwiLmNvbmNhdChwYXRoT2JqZWN0Lm5hbWUgfHwgJycpLmNvbmNhdChwYXRoT2JqZWN0LmV4dCB8fCAnJyk7IC8vIGFwcGVuZCBiYXNlIHRvIHJvb3QgaWYgYGRpcmAgd2Fzbid0IHNwZWNpZmllZCwgb3IgaWZcbiAgLy8gZGlyIGlzIHRoZSByb290XG5cbiAgaWYgKCFwYXRoT2JqZWN0LmRpciB8fCBwYXRoT2JqZWN0LmRpciA9PT0gcGF0aE9iamVjdC5yb290KSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHBhdGhPYmplY3Qucm9vdCB8fCAnJykuY29uY2F0KGJhc2UpO1xuICB9IC8vIGNvbWJpbmUgZGlyICsgLyArIGJhc2VcblxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChwYXRoT2JqZWN0LmRpcikuY29uY2F0KHNlcGFyYXRvcikuY29uY2F0KGJhc2UpO1xufVxuLyoqXG4gKiBPbiBXaW5kb3dzIHN5c3RlbXMgb25seSwgcmV0dXJucyBhbiBlcXVpdmFsZW50IG5hbWVzcGFjZS1wcmVmaXhlZCBwYXRoIGZvclxuICogdGhlIGdpdmVuIHBhdGguIElmIHBhdGggaXMgbm90IGEgc3RyaW5nLCBwYXRoIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb25zLlxuICogU2VlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3MvZGVza3RvcC9GaWxlSU8vbmFtaW5nLWEtZmlsZSNuYW1lc3BhY2VzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gdG9OYW1lc3BhY2VkUGF0aChmaWxlcGF0aCkge1xuICBpZiAodHlwZW9mIGZpbGVwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuXG4gIGlmIChmaWxlcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWRQYXRoID0gX3Jlc29sdmUoJ1xcXFwnLCBbZmlsZXBhdGhdKTtcblxuICB2YXIgbGVuZ3RoID0gcmVzb2x2ZWRQYXRoLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgMikge1xuICAgIC8vIG5lZWQgJ1xcXFxcXFxcJyBvciAnQzonIG1pbmltdW1cbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH1cblxuICB2YXIgZmlyc3RDaGFyQ29kZSA9IHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApOyAvLyBpZiBzdGFydCB3aXRoICdcXFxcXFxcXCcsIHByZWZpeCB3aXRoIFVOQyByb290LCBkcm9wIHRoZSBzbGFzaGVzXG5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIICYmIHJlc29sdmVkUGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJykge1xuICAgIC8vIHJldHVybiBhcy1pcyBpZiBpdCdzIGFuIGFyZWFkeSBsb25nIHBhdGggKCdcXFxcXFxcXD9cXFxcJyBvciAnXFxcXFxcXFwuXFxcXCcgcHJlZml4KVxuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgdmFyIHRoaXJkQ2hhciA9IHJlc29sdmVkUGF0aC5jaGFyQXQoMik7XG5cbiAgICAgIGlmICh0aGlyZENoYXIgPT09ICc/JyB8fCB0aGlyZENoYXIgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICdcXFxcXFxcXD9cXFxcVU5DXFxcXCcgKyByZXNvbHZlZFBhdGguc2xpY2UoMik7XG4gIH0gZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXJDb2RlKSAmJiByZXNvbHZlZFBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICByZXR1cm4gJ1xcXFxcXFxcP1xcXFwnICsgcmVzb2x2ZWRQYXRoO1xuICB9XG5cbiAgcmV0dXJuIGZpbGVwYXRoO1xufVxuXG52YXIgV2luMzJQYXRoID0ge1xuICBzZXA6ICdcXFxcJyxcbiAgZGVsaW1pdGVyOiAnOycsXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiBiYXNlbmFtZShmaWxlcGF0aCwgZXh0KSB7XG4gICAgcmV0dXJuIF9iYXNlbmFtZSh0aGlzLnNlcCwgZmlsZXBhdGgsIGV4dCk7XG4gIH0sXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIF9ub3JtYWxpemUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gam9pbigpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGF0aHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwYXRoc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2pvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gZXh0bmFtZShmaWxlcGF0aCkge1xuICAgIHJldHVybiBfZXh0bmFtZSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBkaXJuYW1lOiBmdW5jdGlvbiBkaXJuYW1lKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIF9kaXJuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIGlzQWJzb2x1dGUoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gX2lzQWJzb2x1dGUoZmFsc2UsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIF9yZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcGF0aHMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIHBhdGhzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXNvbHZlKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShmaWxlcGF0aCkge1xuICAgIHJldHVybiBfcGFyc2UodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQocGF0aE9iamVjdCkge1xuICAgIHJldHVybiBfZm9ybWF0KHRoaXMuc2VwLCBwYXRoT2JqZWN0KTtcbiAgfSxcbiAgdG9OYW1lc3BhY2VkUGF0aDogdG9OYW1lc3BhY2VkUGF0aFxufTtcbnZhciBQb3NpeFBhdGggPSB7XG4gIHNlcDogJy8nLFxuICBkZWxpbWl0ZXI6ICc6JyxcbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIGJhc2VuYW1lKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gX2Jhc2VuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCwgZXh0KTtcbiAgfSxcbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gX25vcm1hbGl6ZSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBqb2luOiBmdW5jdGlvbiBqb2luKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgcGF0aHMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIHBhdGhzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgcmV0dXJuIF9qb2luKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIGV4dG5hbWUoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gX2V4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gZGlybmFtZShmaWxlcGF0aCkge1xuICAgIHJldHVybiBfZGlybmFtZSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBpc0Fic29sdXRlOiBmdW5jdGlvbiBpc0Fic29sdXRlKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIF9pc0Fic29sdXRlKHRydWUsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIF9yZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgcGF0aHMgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIHBhdGhzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXNvbHZlKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShmaWxlcGF0aCkge1xuICAgIHJldHVybiBfcGFyc2UodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQocGF0aE9iamVjdCkge1xuICAgIHJldHVybiBfZm9ybWF0KHRoaXMuc2VwLCBwYXRoT2JqZWN0KTtcbiAgfSxcbiAgdG9OYW1lc3BhY2VkUGF0aDogZnVuY3Rpb24gdG9OYW1lc3BhY2VkUGF0aChmaWxlcGF0aCkge1xuICAgIHJldHVybiBmaWxlcGF0aDsgLy8gbm8tb3BcbiAgfVxufTtcbnZhciBwYXRoID0gaXNXaW4zMiA/IFdpbjMyUGF0aCA6IFBvc2l4UGF0aDtcbnBhdGgud2luMzIgPSBXaW4zMlBhdGg7XG5wYXRoLnBvc2l4ID0gUG9zaXhQYXRoO1xuXG52YXIgaXNBbmRyb2lkID0gVGkuUGxhdGZvcm0ub3NuYW1lID09PSAnYW5kcm9pZCc7XG52YXIgaXNJT1MgPSAhaXNBbmRyb2lkICYmIChUaS5QbGF0Zm9ybS5vc25hbWUgPT09ICdpcGhvbmUnIHx8IFRpLlBsYXRmb3JtLm9zbmFtZSA9PT0gJ2lwYWQnKTtcbnZhciBpc1dpbjMyJDEgPSAhaXNBbmRyb2lkICYmICFpc0lPUyAmJiBUaS5QbGF0Zm9ybS5uYW1lID09PSAnd2luZG93cyc7XG52YXIgUG9zaXhDb25zdGFudHMgPSB7XG4gIFVWX1VEUF9SRVVTRUFERFI6IDQsXG4gIGRsb3Blbjoge30sXG4gIGVycm5vOiB7XG4gICAgRTJCSUc6IDcsXG4gICAgRUFDQ0VTOiAxMyxcbiAgICBFQUREUklOVVNFOiA0OCxcbiAgICBFQUREUk5PVEFWQUlMOiA0OSxcbiAgICBFQUZOT1NVUFBPUlQ6IDQ3LFxuICAgIEVBR0FJTjogMzUsXG4gICAgRUFMUkVBRFk6IDM3LFxuICAgIEVCQURGOiA5LFxuICAgIEVCQURNU0c6IDk0LFxuICAgIEVCVVNZOiAxNixcbiAgICBFQ0FOQ0VMRUQ6IDg5LFxuICAgIEVDSElMRDogMTAsXG4gICAgRUNPTk5BQk9SVEVEOiA1MyxcbiAgICBFQ09OTlJFRlVTRUQ6IDYxLFxuICAgIEVDT05OUkVTRVQ6IDU0LFxuICAgIEVERUFETEs6IDExLFxuICAgIEVERVNUQUREUlJFUTogMzksXG4gICAgRURPTTogMzMsXG4gICAgRURRVU9UOiA2OSxcbiAgICBFRVhJU1Q6IDE3LFxuICAgIEVGQVVMVDogMTQsXG4gICAgRUZCSUc6IDI3LFxuICAgIEVIT1NUVU5SRUFDSDogNjUsXG4gICAgRUlEUk06IDkwLFxuICAgIEVJTFNFUTogOTIsXG4gICAgRUlOUFJPR1JFU1M6IDM2LFxuICAgIEVJTlRSOiA0LFxuICAgIEVJTlZBTDogMjIsXG4gICAgRUlPOiA1LFxuICAgIEVJU0NPTk46IDU2LFxuICAgIEVJU0RJUjogMjEsXG4gICAgRUxPT1A6IDYyLFxuICAgIEVNRklMRTogMjQsXG4gICAgRU1MSU5LOiAzMSxcbiAgICBFTVNHU0laRTogNDAsXG4gICAgRU1VTFRJSE9QOiA5NSxcbiAgICBFTkFNRVRPT0xPTkc6IDYzLFxuICAgIEVORVRET1dOOiA1MCxcbiAgICBFTkVUUkVTRVQ6IDUyLFxuICAgIEVORVRVTlJFQUNIOiA1MSxcbiAgICBFTkZJTEU6IDIzLFxuICAgIEVOT0JVRlM6IDU1LFxuICAgIEVOT0RBVEE6IDk2LFxuICAgIEVOT0RFVjogMTksXG4gICAgRU5PRU5UOiAyLFxuICAgIEVOT0VYRUM6IDgsXG4gICAgRU5PTENLOiA3NyxcbiAgICBFTk9MSU5LOiA5NyxcbiAgICBFTk9NRU06IDEyLFxuICAgIEVOT01TRzogOTEsXG4gICAgRU5PUFJPVE9PUFQ6IDQyLFxuICAgIEVOT1NQQzogMjgsXG4gICAgRU5PU1I6IDk4LFxuICAgIEVOT1NUUjogOTksXG4gICAgRU5PU1lTOiA3OCxcbiAgICBFTk9UQ09OTjogNTcsXG4gICAgRU5PVERJUjogMjAsXG4gICAgRU5PVEVNUFRZOiA2NixcbiAgICBFTk9UU09DSzogMzgsXG4gICAgRU5PVFNVUDogNDUsXG4gICAgRU5PVFRZOiAyNSxcbiAgICBFTlhJTzogNixcbiAgICBFT1BOT1RTVVBQOiAxMDIsXG4gICAgRU9WRVJGTE9XOiA4NCxcbiAgICBFUEVSTTogMSxcbiAgICBFUElQRTogMzIsXG4gICAgRVBST1RPOiAxMDAsXG4gICAgRVBST1RPTk9TVVBQT1JUOiA0MyxcbiAgICBFUFJPVE9UWVBFOiA0MSxcbiAgICBFUkFOR0U6IDM0LFxuICAgIEVST0ZTOiAzMCxcbiAgICBFU1BJUEU6IDI5LFxuICAgIEVTUkNIOiAzLFxuICAgIEVTVEFMRTogNzAsXG4gICAgRVRJTUU6IDEwMSxcbiAgICBFVElNRURPVVQ6IDYwLFxuICAgIEVUWFRCU1k6IDI2LFxuICAgIEVXT1VMREJMT0NLOiAzNSxcbiAgICBFWERFVjogMThcbiAgfSxcbiAgc2lnbmFsczoge1xuICAgIFNJR0hVUDogMSxcbiAgICBTSUdJTlQ6IDIsXG4gICAgU0lHUVVJVDogMyxcbiAgICBTSUdJTEw6IDQsXG4gICAgU0lHVFJBUDogNSxcbiAgICBTSUdBQlJUOiA2LFxuICAgIFNJR0lPVDogNixcbiAgICBTSUdCVVM6IDEwLFxuICAgIFNJR0ZQRTogOCxcbiAgICBTSUdLSUxMOiA5LFxuICAgIFNJR1VTUjE6IDMwLFxuICAgIFNJR1NFR1Y6IDExLFxuICAgIFNJR1VTUjI6IDMxLFxuICAgIFNJR1BJUEU6IDEzLFxuICAgIFNJR0FMUk06IDE0LFxuICAgIFNJR1RFUk06IDE1LFxuICAgIFNJR0NITEQ6IDIwLFxuICAgIFNJR0NPTlQ6IDE5LFxuICAgIFNJR1NUT1A6IDE3LFxuICAgIFNJR1RTVFA6IDE4LFxuICAgIFNJR1RUSU46IDIxLFxuICAgIFNJR1RUT1U6IDIyLFxuICAgIFNJR1VSRzogMTYsXG4gICAgU0lHWENQVTogMjQsXG4gICAgU0lHWEZTWjogMjUsXG4gICAgU0lHVlRBTFJNOiAyNixcbiAgICBTSUdQUk9GOiAyNyxcbiAgICBTSUdXSU5DSDogMjgsXG4gICAgU0lHSU86IDIzLFxuICAgIFNJR0lORk86IDI5LFxuICAgIFNJR1NZUzogMTJcbiAgfSxcbiAgcHJpb3JpdHk6IHtcbiAgICBQUklPUklUWV9MT1c6IDE5LFxuICAgIFBSSU9SSVRZX0JFTE9XX05PUk1BTDogMTAsXG4gICAgUFJJT1JJVFlfTk9STUFMOiAwLFxuICAgIFBSSU9SSVRZX0FCT1ZFX05PUk1BTDogLTcsXG4gICAgUFJJT1JJVFlfSElHSDogLTE0LFxuICAgIFBSSU9SSVRZX0hJR0hFU1Q6IC0yMFxuICB9XG59OyAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uc1xuXG52YXIgT1MgPSB7XG4gIEVPTDogJ1xcbicsXG4gIGFyY2g6IGZ1bmN0aW9uIGFyY2goKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuYXJjaDtcbiAgfSxcbiAgY29uc3RhbnRzOiBQb3NpeENvbnN0YW50cyxcbiAgY3B1czogZnVuY3Rpb24gY3B1cygpIHtcbiAgICB2YXIgY291bnQgPSBUaS5QbGF0Zm9ybS5wcm9jZXNzb3JDb3VudDtcbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIG1vZGVsOiAndW5rbm93bicsXG4gICAgICAgIHNwZWVkOiAwLFxuICAgICAgICB0aW1lczoge1xuICAgICAgICAgIHVzZXI6IDAsXG4gICAgICAgICAgbmljZTogMCxcbiAgICAgICAgICBzeXM6IDAsXG4gICAgICAgICAgaWRsZTogMCxcbiAgICAgICAgICBpcnE6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuICBlbmRpYW5uZXNzOiBmdW5jdGlvbiBlbmRpYW5uZXNzKCkge1xuICAgIC8vIFRPRE86IENhY2hlIHRoZSB2YWx1ZSFcbiAgICB2YXIgcmVzdWx0ID0gVGkuQ29kZWMuZ2V0TmF0aXZlQnl0ZU9yZGVyKCk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBUaS5Db2RlYy5MSVRUTEVfRU5ESUFOKSB7XG4gICAgICByZXR1cm4gJ0xFJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ0JFJztcbiAgfSxcbiAgZnJlZW1lbTogZnVuY3Rpb24gZnJlZW1lbSgpIHtcbiAgICByZXR1cm4gVGkuUGxhdGZvcm0uYXZhaWxhYmxlTWVtb3J5O1xuICB9LFxuICBnZXRQcmlvcml0eTogZnVuY3Rpb24gZ2V0UHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIC8vIGZha2UgaXRcbiAgaG9tZWRpcjogZnVuY3Rpb24gaG9tZWRpcigpIHtcbiAgICByZXR1cm4gVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3Rvcnk7XG4gIH0sXG4gIC8vIGZha2UgaXRcbiAgaG9zdG5hbWU6IGZ1bmN0aW9uIGhvc3RuYW1lKCkge1xuICAgIHJldHVybiBUaS5QbGF0Zm9ybS5hZGRyZXNzO1xuICB9LFxuICAvLyBmYWtlIGl0XG4gIGxvYWRhdmc6IGZ1bmN0aW9uIGxvYWRhdmcoKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfSxcbiAgLy8gZmFrZSBpdFxuICBuZXR3b3JrSW50ZXJmYWNlczogZnVuY3Rpb24gbmV0d29ya0ludGVyZmFjZXMoKSB7fSxcbiAgLy8gRklYTUU6IFdoYXQgZG8gd2UgZG8gaGVyZT8gV2UgbWlnaHQgYmUgYWJsZSB0byBwaWVjZSBzb21lIG9mIHRoaXMgdG9nZXRoZXIgdXNpbmcgVGkuUGxhdGZvcm0ubmV0bWFzaywgVGkuUGxhdGZvcm0uYWRkcmVzc1xuICBwbGF0Zm9ybTogZnVuY3Rpb24gcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm07XG4gIH0sXG4gIHJlbGVhc2U6IGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgcmV0dXJuIFRpLlBsYXRmb3JtLnZlcnNpb247XG4gIH0sXG4gIHNldFByaW9yaXR5OiBmdW5jdGlvbiBzZXRQcmlvcml0eSgpIHt9LFxuICAvLyBuby1vcCwgZmFrZSBpdFxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnRtcGRpcigpYCBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBvcGVyYXRpbmcgc3lzdGVtJ3MgZGVmYXVsdCBkaXJlY3RvcnkgZm9yIHRlbXBvcmFyeSBmaWxlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0bXBkaXI6IGZ1bmN0aW9uIHRtcGRpcigpIHtcbiAgICByZXR1cm4gVGkuRmlsZXN5c3RlbS50ZW1wRGlyZWN0b3J5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnRvdGFsbWVtKClgIG1ldGhvZCByZXR1cm5zIHRoZSB0b3RhbCBhbW91bnQgb2Ygc3lzdGVtIG1lbW9yeSBpbiBieXRlcyBhcyBhbiBpbnRlZ2VyLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0b3RhbG1lbTogZnVuY3Rpb24gdG90YWxtZW0oKSB7XG4gICAgcmV0dXJuIFRpLlBsYXRmb3JtLnRvdGFsTWVtb3J5O1xuICB9LFxuICB0eXBlOiBmdW5jdGlvbiB0eXBlKCkge1xuICAgIHJldHVybiAnVW5rbm93bic7XG4gIH0sXG4gIC8vIG92ZXJyaWRkZW4gcGVyLXBsYXRmb3JtIGF0IGJvdHRvbVxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnVwdGltZSgpYCBtZXRob2QgcmV0dXJucyB0aGUgc3lzdGVtIHVwdGltZSBpbiBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdXB0aW1lOiBmdW5jdGlvbiB1cHRpbWUoKSB7XG4gICAgcmV0dXJuIFRpLlBsYXRmb3JtLnVwdGltZTtcbiAgfSxcbiAgdXNlckluZm86IGZ1bmN0aW9uIHVzZXJJbmZvKCkge1xuICAgIC8vIGZha2UgaXQhXG4gICAgcmV0dXJuIHtcbiAgICAgIHVpZDogLTEsXG4gICAgICBndWlkOiAtMSxcbiAgICAgIHVzZXJuYW1lOiBUaS5QbGF0Zm9ybS51c2VybmFtZSxcbiAgICAgIGhvbWVkaXI6IFRpLkZpbGVzeXN0ZW0uYXBwbGljYXRpb25EYXRhRGlyZWN0b3J5LFxuICAgICAgc2hlbGw6IG51bGxcbiAgICB9O1xuICB9XG59OyAvLyBPbiBzcGVjaWZpYyBwbGF0Zm9ybXMsIG92ZXJyaWRlIGltcGxlbWVudGF0aW9ucyBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhlbVxuLy8geWV0IGFuZCBuZWVkIHRvIGZha2UgaXQsIG9yIHRvIGhhY2sgdGhlbVxuLy8gSSdtIGFsc28gZG9pbmcgdGhpcyBpbiBibG9ja3MgdG8gYXNzaWduIGltcGxlbWVudGF0aW9ucyB0aGF0IGRvbid0IG5lZWQgdG8gY29uc3VsdCBwbGF0Zm9ybVxuLy8gdHlwZSBhdCBydW50aW1lIChob3BlZnVsbHkgc3BlZWRpbmcgdXAgZXhlY3V0aW9uIGF0IHJ1bnRpbWUpXG5cbmlmIChpc0lPUykge1xuICBPUy50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnRGFyd2luJztcbiAgfTsgLy8gTm93IGEgZ2lhbnQgaGFjayBmb3IgbG9va2luZyB1cCBDUFUgaW5mbyBmb3IgT1MuY3B1cygpIG9uIGlPU1xuICAvLyBodHRwczovL3d3dy50aGVpcGhvbmV3aWtpLmNvbS93aWtpL0xpc3Rfb2ZfaVBob25lc1xuXG5cbiAgdmFyIEFwcGxlTWFwID0ge1xuICAgIC8vIGlQaG9uZSAxMSBQcm8gTWF4XG4gICAgJ2lQaG9uZTEyLDUnOiBbJ0FwcGxlIEExMyBCaW9uaWMgQCAyLjY2IEdIeicsIDI2NjBdLFxuICAgIC8vIGlQaG9uZSAxMSBQcm9cbiAgICAnaVBob25lMTIsMyc6IFsnQXBwbGUgQTEzIEJpb25pYyBAIDIuNjYgR0h6JywgMjY2MF0sXG4gICAgLy8gaVBob25lIDExXG4gICAgJ2lQaG9uZTEyLDEnOiBbJ0FwcGxlIEExMyBCaW9uaWMgQCAyLjY2IEdIeicsIDI2NjBdLFxuICAgIC8vIGlQaG9uZSBYUlxuICAgICdpUGhvbmUxMSw4JzogWydBcHBsZSBBMTIgQmlvbmljIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAvLyBpUGhvbmUgWFMgTWF4XG4gICAgJ2lQaG9uZTExLDYnOiBbJ0FwcGxlIEExMiBCaW9uaWMgQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGhvbmUxMSw0JzogWydBcHBsZSBBMTIgQmlvbmljIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAvLyBpUGhvbmUgWFNcbiAgICAnaVBob25lMTEsMic6IFsnQXBwbGUgQTEyIEJpb25pYyBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgLy8gaVBob25lIFhcbiAgICAnaVBob25lMTAsNic6IFsnQXBwbGUgQTExIEJpb25pYyBAIDIuMzkgR0h6JywgMjM5MF0sXG4gICAgJ2lQaG9uZTEwLDMnOiBbJ0FwcGxlIEExMSBCaW9uaWMgQCAyLjM5IEdIeicsIDIzOTBdLFxuICAgIC8vIGlQaG9uZSA4IFBsdXNcbiAgICAnaVBob25lMTAsNSc6IFsnQXBwbGUgQTExIEJpb25pYyBAIDIuMzkgR0h6JywgMjM5MF0sXG4gICAgJ2lQaG9uZTEwLDInOiBbJ0FwcGxlIEExMSBCaW9uaWMgQCAyLjM5IEdIeicsIDIzOTBdLFxuICAgIC8vIGlQaG9uZSA4XG4gICAgJ2lQaG9uZTEwLDQnOiBbJ0FwcGxlIEExMSBCaW9uaWMgQCAyLjM5IEdIeicsIDIzOTBdLFxuICAgICdpUGhvbmUxMCwxJzogWydBcHBsZSBBMTEgQmlvbmljIEAgMi4zOSBHSHonLCAyMzkwXSxcbiAgICAvLyBpUGhvbmUgNyBQbHVzXG4gICAgJ2lQaG9uZTksNCc6IFsnQXBwbGUgQTEwIEZ1c2lvbiBAIDIuMzQgR0h6JywgMjM0MF0sXG4gICAgJ2lQaG9uZTksMic6IFsnQXBwbGUgQTEwIEZ1c2lvbiBAIDIuMzQgR0h6JywgMjM0MF0sXG4gICAgLy8gaVBob25lIDdcbiAgICAnaVBob25lOSwzJzogWydBcHBsZSBBMTAgRnVzaW9uIEAgMi4zNCBHSHonLCAyMzQwXSxcbiAgICAnaVBob25lOSwxJzogWydBcHBsZSBBMTAgRnVzaW9uIEAgMi4zNCBHSHonLCAyMzQwXSxcbiAgICAvLyBpUGhvbmUgU0VcbiAgICAnaVBob25lOCw0JzogWydBcHBsZSBBOSBUd2lzdGVyIEAgMS44NSBHSHonLCAxODUwXSxcbiAgICAvLyBpUGhvbmUgNnMgUGx1c1xuICAgICdpUGhvbmU4LDInOiBbJ0FwcGxlIEE5IFR3aXN0ZXIgQCAxLjg1IEdIeicsIDE4NTBdLFxuICAgIC8vIGlQaG9uZSA2c1xuICAgICdpUGhvbmU4LDEnOiBbJ0FwcGxlIEE5IFR3aXN0ZXIgQCAxLjg1IEdIeicsIDE4NTBdLFxuICAgIC8vIGlQaG9uZSA2IFBsdXNcbiAgICAnaVBob25lNywxJzogWydBcHBsZSBBOCBUeXBob29uIEAgMS4zOCBHSHonLCAxMzgwXSxcbiAgICAvLyBpUGhvbmUgNlxuICAgICdpUGhvbmU3LDInOiBbJ0FwcGxlIEE4IFR5cGhvb24gQCAxLjM4IEdIeicsIDEzODBdLFxuICAgIC8vIGlQaG9uZSA1c1xuICAgICdpUGhvbmU2LDInOiBbJ0FwcGxlIEE3IEN5Y2xvbmUgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgJ2lQaG9uZTYsMSc6IFsnQXBwbGUgQTcgQ3ljbG9uZSBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAvLyBpUGhvbmUgNWNcbiAgICAnaVBob25lNSw0JzogWydBcHBsZSBBNiBTd2lmdCBAIDEuMiBHSHonLCAxMjAwXSxcbiAgICAnaVBob25lNSwzJzogWydBcHBsZSBBNiBTd2lmdCBAIDEuMiBHSHonLCAxMjAwXSxcbiAgICAvLyBpUGhvbmUgNVxuICAgICdpUGhvbmU1LDEnOiBbJ0FwcGxlIEE2IFN3aWZ0IEAgMS4yIEdIeicsIDEyMDBdLFxuICAgICdpUGhvbmU1LDInOiBbJ0FwcGxlIEE2IFN3aWZ0IEAgMS4yIEdIeicsIDEyMDBdLFxuICAgIC8vIGlQaG9uZSA0c1xuICAgICdpUGhvbmU0LDEnOiBbJ0FwcGxlIEE1IEAgODAwIE1IeicsIDgwMF0sXG4gICAgLy8gaVBob25lIDRcbiAgICAnaVBob25lMywzJzogWydBcHBsZSBBNCBAIDgwMCBNSHonLCA4MDBdLFxuICAgICdpUGhvbmUzLDInOiBbJ0FwcGxlIEE0IEAgODAwIE1IeicsIDgwMF0sXG4gICAgJ2lQaG9uZTMsMSc6IFsnQXBwbGUgQTQgQCA4MDAgTUh6JywgODAwXSxcbiAgICAvLyBpUGhvbmUgM0dTXG4gICAgJ2lQaG9uZTIsMSc6IFsnU2Ftc3VuZyBTNUw4OTIwIEAgNjIwIE1IeicsIDYyMF0sXG4gICAgLy8gaVBob25lIDNHXG4gICAgJ2lQaG9uZTEsMic6IFsnU2Ftc3VuZyBTNUw4OTAwIEAgNDEyIE1IeicsIDQxMl0sXG4gICAgLy8gaVBob25lXG4gICAgJ2lQaG9uZTEsMSc6IFsnU2Ftc3VuZyBTNUw4OTAwIEAgNDEyIE1IeicsIDQxMl0sXG4gICAgLy8gLy8vLy8vIGlQYWRzXG4gICAgLy8gaHR0cHM6Ly93d3cudGhlaXBob25ld2lraS5jb20vd2lraS9MaXN0X29mX2lQYWRzXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVBhZFxuICAgIC8vIGlQYWQgUHJvICgxMi45XCIgM3JkIGdlbilcbiAgICAnaVBhZDgsOCc6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgJ2lQYWQ4LDcnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGFkOCw2JzogWydBcHBsZSBBMTJYIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDgsNSc6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgLy8gaVBhZCBQcm8gKDExXCIpXG4gICAgJ2lQYWQ4LDQnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgICdpUGFkOCwzJzogWydBcHBsZSBBMTJYIEAgMi40OSBHSHonLCAyNDkwXSxcbiAgICAnaVBhZDgsMic6IFsnQXBwbGUgQTEyWCBAIDIuNDkgR0h6JywgMjQ5MF0sXG4gICAgJ2lQYWQ4LDEnOiBbJ0FwcGxlIEExMlggQCAyLjQ5IEdIeicsIDI0OTBdLFxuICAgIC8vIGlQYWQgKDZ0aCBnZW4pXG4gICAgJ2lQYWQ3LDYnOiBbJ0FwcGxlIEExMCBAIDIuMzEgR0h6JywgMjMxMF0sXG4gICAgLy8gRklYTUU6IFdpa2lwZWRpYSBzYXlzIDIuMzQgR0h6XG4gICAgJ2lQYWQ3LDUnOiBbJ0FwcGxlIEExMCBAIDIuMzEgR0h6JywgMjMxMF0sXG4gICAgLy8gaVBhZCBQcm8gKDEwLjVcIilcbiAgICAnaVBhZDcsNCc6IFsnQXBwbGUgQTEwWCBAIDIuMzggR0h6JywgMjM4MF0sXG4gICAgJ2lQYWQ3LDMnOiBbJ0FwcGxlIEExMFggQCAyLjM4IEdIeicsIDIzODBdLFxuICAgIC8vIGlQYWQgUHJvICgxMi45XCIgMm5kIGdlbilcbiAgICAnaVBhZDcsMic6IFsnQXBwbGUgQTEwWCBAIDIuMzggR0h6JywgMjM4MF0sXG4gICAgJ2lQYWQ3LDEnOiBbJ0FwcGxlIEExMFggQCAyLjM4IEdIeicsIDIzODBdLFxuICAgIC8vIGlQYWQgKDV0aCBnZW4pXG4gICAgJ2lQYWQ2LDEyJzogWydBcHBsZSBBOSBAIDEuODUgR0h6JywgMTg1MF0sXG4gICAgJ2lQYWQ2LDExJzogWydBcHBsZSBBOSBAIDEuODUgR0h6JywgMTg1MF0sXG4gICAgLy8gaVBhZCBQcm8gKDEyLjlcIiAxc3QgZ2VuKVxuICAgICdpUGFkNiw4JzogWydBcHBsZSBBOVggQCAyLjI0IEdIeicsIDIyNDBdLFxuICAgICdpUGFkNiw3JzogWydBcHBsZSBBOVggQCAyLjI0IEdIeicsIDIyNDBdLFxuICAgIC8vIGlQYWQgUHJvICg5LjdcIilcbiAgICAnaVBhZDYsNCc6IFsnQXBwbGUgQTlYIEAgMi4xNiBHSHonLCAyMTYwXSxcbiAgICAnaVBhZDYsMyc6IFsnQXBwbGUgQTlYIEAgMi4xNiBHSHonLCAyMTYwXSxcbiAgICAvLyBpUGFkIEFpciAyXG4gICAgJ2lQYWQ1LDQnOiBbJ0FwcGxlIEE4WCBAIDEuNSBHSHonLCAxNTAwXSxcbiAgICAnaVBhZDUsMyc6IFsnQXBwbGUgQThYIEAgMS41IEdIeicsIDE1MDBdLFxuICAgIC8vIGlQYWQgTWluaSA0XG4gICAgJ2lQYWQ1LDInOiBbJ0FwcGxlIEE4IEAgMS40OSBHSHonLCAxNDkwXSxcbiAgICAnaVBhZDUsMSc6IFsnQXBwbGUgQTggQCAxLjQ5IEdIeicsIDE0OTBdLFxuICAgIC8vIGlQYWQgTWluaSAzXG4gICAgJ2lQYWQ0LDknOiBbJ0FwcGxlIEE3IEAgMS4zIEdIeicsIDEzMDBdLFxuICAgICdpUGFkNCw4JzogWydBcHBsZSBBNyBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAnaVBhZDQsNyc6IFsnQXBwbGUgQTcgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgLy8gaVBhZCBNaW5pIDJcbiAgICAnaVBhZDQsNic6IFsnQXBwbGUgQTcgQCAxLjMgR0h6JywgMTMwMF0sXG4gICAgJ2lQYWQ0LDUnOiBbJ0FwcGxlIEE3IEAgMS4zIEdIeicsIDEzMDBdLFxuICAgICdpUGFkNCw0JzogWydBcHBsZSBBNyBAIDEuMyBHSHonLCAxMzAwXSxcbiAgICAvLyBpUGFkIEFpciAyXG4gICAgJ2lQYWQ0LDMnOiBbJ0FwcGxlIEE3IFJldiBBIEAgMS40IEdIeicsIDE0MDBdLFxuICAgICdpUGFkNCwyJzogWydBcHBsZSBBNyBSZXYgQSBAIDEuNCBHSHonLCAxNDAwXSxcbiAgICAnaVBhZDQsMSc6IFsnQXBwbGUgQTcgUmV2IEEgQCAxLjQgR0h6JywgMTQwMF0sXG4gICAgLy8gaVBhZCAoNHRoIGdlbilcbiAgICAnaVBhZDMsNic6IFsnQXBwbGUgQTZYIEAgMS40IEdIeicsIDE0MDBdLFxuICAgICdpUGFkMyw1JzogWydBcHBsZSBBNlggQCAxLjQgR0h6JywgMTQwMF0sXG4gICAgJ2lQYWQzLDQnOiBbJ0FwcGxlIEE2WCBAIDEuNCBHSHonLCAxNDAwXSxcbiAgICAvLyBpUGFkICgzcmQgZ2VuKVxuICAgICdpUGFkMywzJzogWydBcHBsZSBBNVggQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMywyJzogWydBcHBsZSBBNVggQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMywxJzogWydBcHBsZSBBNVggQCAxIEdIeicsIDEwMDBdLFxuICAgIC8vIGlQYWQgTWluaVxuICAgICdpUGFkMiw3JzogWydBcHBsZSBBNSBSZXYgQSBAIDEgR0h6JywgMTAwMF0sXG4gICAgJ2lQYWQyLDYnOiBbJ0FwcGxlIEE1IFJldiBBIEAgMSBHSHonLCAxMDAwXSxcbiAgICAnaVBhZDIsNSc6IFsnQXBwbGUgQTUgUmV2IEEgQCAxIEdIeicsIDEwMDBdLFxuICAgIC8vIGlQYWQgMlxuICAgICdpUGFkMiw0JzogWydBcHBsZSBBNSBAIDEgR0h6JywgMTAwMF0sXG4gICAgJ2lQYWQyLDMnOiBbJ0FwcGxlIEE1IEAgMSBHSHonLCAxMDAwXSxcbiAgICAnaVBhZDIsMic6IFsnQXBwbGUgQTUgQCAxIEdIeicsIDEwMDBdLFxuICAgICdpUGFkMiwxJzogWydBcHBsZSBBNSBAIDEgR0h6JywgMTAwMF0sXG4gICAgLy8gaVBhZFxuICAgICdpUGFkMSwxJzogWydBcHBsZSBBNCBAIDEgR0h6JywgMTAwMF1cbiAgfTtcbiAgLyoqXG4gICAqIFtjcHVNb2RlbCBkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7c3RyaW5nfSBtb2RlbCBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuXG4gIHZhciBjcHVNb2RlbEFuZFNwZWVkID0gZnVuY3Rpb24gY3B1TW9kZWxBbmRTcGVlZChtb2RlbCkge1xuICAgIHZhciB0cmltbWVkID0gbW9kZWwucmVwbGFjZSgnIChTaW11bGF0b3IpJywgJycpLnRyaW0oKTtcbiAgICByZXR1cm4gQXBwbGVNYXBbdHJpbW1lZF0gfHwgWydVbmtub3duJywgMF07XG4gIH07IC8vIG92ZXJyaWRlIGNwdXMgaW1wbFxuXG5cbiAgT1MuY3B1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBDYWNoZSB0aGUgcmVzdWx0IVxuICAgIHZhciBjb3VudCA9IFRpLlBsYXRmb3JtLnByb2Nlc3NvckNvdW50O1xuICAgIHZhciBtb2RlbEFuZFNwZWVkID0gY3B1TW9kZWxBbmRTcGVlZChUaS5QbGF0Zm9ybS5tb2RlbCk7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICBtb2RlbDogbW9kZWxBbmRTcGVlZFswXSxcbiAgICAgICAgc3BlZWQ6IG1vZGVsQW5kU3BlZWRbMV0sXG4gICAgICAgIHRpbWVzOiB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xufSBlbHNlIGlmIChpc1dpbjMyJDEpIHtcbiAgT1MudXB0aW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9OyAvLyBGSVhNRTogSW1wbGVtZW50IVxuXG5cbiAgT1MudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gIH07IC8vIEZJWE1FOiBJbXBsZW1lbnQhXG5cblxuICBPUy5FT0wgPSAnXFxyXFxuJztcblxuICBPUy50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnV2luZG93c19OVCc7XG4gIH07XG5cbiAgT1MuY29uc3RhbnRzID0ge1xuICAgIFVWX1VEUF9SRVVTRUFERFI6IDQsXG4gICAgZGxvcGVuOiB7fSxcbiAgICBlcnJubzoge1xuICAgICAgRTJCSUc6IDcsXG4gICAgICBFQUNDRVM6IDEzLFxuICAgICAgRUFERFJJTlVTRTogMTAwLFxuICAgICAgRUFERFJOT1RBVkFJTDogMTAxLFxuICAgICAgRUFGTk9TVVBQT1JUOiAxMDIsXG4gICAgICBFQUdBSU46IDExLFxuICAgICAgRUFMUkVBRFk6IDEwMyxcbiAgICAgIEVCQURGOiA5LFxuICAgICAgRUJBRE1TRzogMTA0LFxuICAgICAgRUJVU1k6IDE2LFxuICAgICAgRUNBTkNFTEVEOiAxMDUsXG4gICAgICBFQ0hJTEQ6IDEwLFxuICAgICAgRUNPTk5BQk9SVEVEOiAxMDYsXG4gICAgICBFQ09OTlJFRlVTRUQ6IDEwNyxcbiAgICAgIEVDT05OUkVTRVQ6IDEwOCxcbiAgICAgIEVERUFETEs6IDM2LFxuICAgICAgRURFU1RBRERSUkVROiAxMDksXG4gICAgICBFRE9NOiAzMyxcbiAgICAgIEVFWElTVDogMTcsXG4gICAgICBFRkFVTFQ6IDE0LFxuICAgICAgRUZCSUc6IDI3LFxuICAgICAgRUhPU1RVTlJFQUNIOiAxMTAsXG4gICAgICBFSURSTTogMTExLFxuICAgICAgRUlMU0VROiA0MixcbiAgICAgIEVJTlBST0dSRVNTOiAxMTIsXG4gICAgICBFSU5UUjogNCxcbiAgICAgIEVJTlZBTDogMjIsXG4gICAgICBFSU86IDUsXG4gICAgICBFSVNDT05OOiAxMTMsXG4gICAgICBFSVNESVI6IDIxLFxuICAgICAgRUxPT1A6IDExNCxcbiAgICAgIEVNRklMRTogMjQsXG4gICAgICBFTUxJTks6IDMxLFxuICAgICAgRU1TR1NJWkU6IDExNSxcbiAgICAgIEVOQU1FVE9PTE9ORzogMzgsXG4gICAgICBFTkVURE9XTjogMTE2LFxuICAgICAgRU5FVFJFU0VUOiAxMTcsXG4gICAgICBFTkVUVU5SRUFDSDogMTE4LFxuICAgICAgRU5GSUxFOiAyMyxcbiAgICAgIEVOT0JVRlM6IDExOSxcbiAgICAgIEVOT0RBVEE6IDEyMCxcbiAgICAgIEVOT0RFVjogMTksXG4gICAgICBFTk9FTlQ6IDIsXG4gICAgICBFTk9FWEVDOiA4LFxuICAgICAgRU5PTENLOiAzOSxcbiAgICAgIEVOT0xJTks6IDEyMSxcbiAgICAgIEVOT01FTTogMTIsXG4gICAgICBFTk9NU0c6IDEyMixcbiAgICAgIEVOT1BST1RPT1BUOiAxMjMsXG4gICAgICBFTk9TUEM6IDI4LFxuICAgICAgRU5PU1I6IDEyNCxcbiAgICAgIEVOT1NUUjogMTI1LFxuICAgICAgRU5PU1lTOiA0MCxcbiAgICAgIEVOT1RDT05OOiAxMjYsXG4gICAgICBFTk9URElSOiAyMCxcbiAgICAgIEVOT1RFTVBUWTogNDEsXG4gICAgICBFTk9UU09DSzogMTI4LFxuICAgICAgRU5PVFNVUDogMTI5LFxuICAgICAgRU5PVFRZOiAyNSxcbiAgICAgIEVOWElPOiA2LFxuICAgICAgRU9QTk9UU1VQUDogMTMwLFxuICAgICAgRU9WRVJGTE9XOiAxMzIsXG4gICAgICBFUEVSTTogMSxcbiAgICAgIEVQSVBFOiAzMixcbiAgICAgIEVQUk9UTzogMTM0LFxuICAgICAgRVBST1RPTk9TVVBQT1JUOiAxMzUsXG4gICAgICBFUFJPVE9UWVBFOiAxMzYsXG4gICAgICBFUkFOR0U6IDM0LFxuICAgICAgRVJPRlM6IDMwLFxuICAgICAgRVNQSVBFOiAyOSxcbiAgICAgIEVTUkNIOiAzLFxuICAgICAgRVRJTUU6IDEzNyxcbiAgICAgIEVUSU1FRE9VVDogMTM4LFxuICAgICAgRVRYVEJTWTogMTM5LFxuICAgICAgRVdPVUxEQkxPQ0s6IDE0MCxcbiAgICAgIEVYREVWOiAxOCxcbiAgICAgIFdTQUVJTlRSOiAxMDAwNCxcbiAgICAgIFdTQUVCQURGOiAxMDAwOSxcbiAgICAgIFdTQUVBQ0NFUzogMTAwMTMsXG4gICAgICBXU0FFRkFVTFQ6IDEwMDE0LFxuICAgICAgV1NBRUlOVkFMOiAxMDAyMixcbiAgICAgIFdTQUVNRklMRTogMTAwMjQsXG4gICAgICBXU0FFV09VTERCTE9DSzogMTAwMzUsXG4gICAgICBXU0FFSU5QUk9HUkVTUzogMTAwMzYsXG4gICAgICBXU0FFQUxSRUFEWTogMTAwMzcsXG4gICAgICBXU0FFTk9UU09DSzogMTAwMzgsXG4gICAgICBXU0FFREVTVEFERFJSRVE6IDEwMDM5LFxuICAgICAgV1NBRU1TR1NJWkU6IDEwMDQwLFxuICAgICAgV1NBRVBST1RPVFlQRTogMTAwNDEsXG4gICAgICBXU0FFTk9QUk9UT09QVDogMTAwNDIsXG4gICAgICBXU0FFUFJPVE9OT1NVUFBPUlQ6IDEwMDQzLFxuICAgICAgV1NBRVNPQ0tUTk9TVVBQT1JUOiAxMDA0NCxcbiAgICAgIFdTQUVPUE5PVFNVUFA6IDEwMDQ1LFxuICAgICAgV1NBRVBGTk9TVVBQT1JUOiAxMDA0NixcbiAgICAgIFdTQUVBRk5PU1VQUE9SVDogMTAwNDcsXG4gICAgICBXU0FFQUREUklOVVNFOiAxMDA0OCxcbiAgICAgIFdTQUVBRERSTk9UQVZBSUw6IDEwMDQ5LFxuICAgICAgV1NBRU5FVERPV046IDEwMDUwLFxuICAgICAgV1NBRU5FVFVOUkVBQ0g6IDEwMDUxLFxuICAgICAgV1NBRU5FVFJFU0VUOiAxMDA1MixcbiAgICAgIFdTQUVDT05OQUJPUlRFRDogMTAwNTMsXG4gICAgICBXU0FFQ09OTlJFU0VUOiAxMDA1NCxcbiAgICAgIFdTQUVOT0JVRlM6IDEwMDU1LFxuICAgICAgV1NBRUlTQ09OTjogMTAwNTYsXG4gICAgICBXU0FFTk9UQ09OTjogMTAwNTcsXG4gICAgICBXU0FFU0hVVERPV046IDEwMDU4LFxuICAgICAgV1NBRVRPT01BTllSRUZTOiAxMDA1OSxcbiAgICAgIFdTQUVUSU1FRE9VVDogMTAwNjAsXG4gICAgICBXU0FFQ09OTlJFRlVTRUQ6IDEwMDYxLFxuICAgICAgV1NBRUxPT1A6IDEwMDYyLFxuICAgICAgV1NBRU5BTUVUT09MT05HOiAxMDA2MyxcbiAgICAgIFdTQUVIT1NURE9XTjogMTAwNjQsXG4gICAgICBXU0FFSE9TVFVOUkVBQ0g6IDEwMDY1LFxuICAgICAgV1NBRU5PVEVNUFRZOiAxMDA2NixcbiAgICAgIFdTQUVQUk9DTElNOiAxMDA2NyxcbiAgICAgIFdTQUVVU0VSUzogMTAwNjgsXG4gICAgICBXU0FFRFFVT1Q6IDEwMDY5LFxuICAgICAgV1NBRVNUQUxFOiAxMDA3MCxcbiAgICAgIFdTQUVSRU1PVEU6IDEwMDcxLFxuICAgICAgV1NBU1lTTk9UUkVBRFk6IDEwMDkxLFxuICAgICAgV1NBVkVSTk9UU1VQUE9SVEVEOiAxMDA5MixcbiAgICAgIFdTQU5PVElOSVRJQUxJU0VEOiAxMDA5MyxcbiAgICAgIFdTQUVESVNDT046IDEwMTAxLFxuICAgICAgV1NBRU5PTU9SRTogMTAxMDIsXG4gICAgICBXU0FFQ0FOQ0VMTEVEOiAxMDEwMyxcbiAgICAgIFdTQUVJTlZBTElEUFJPQ1RBQkxFOiAxMDEwNCxcbiAgICAgIFdTQUVJTlZBTElEUFJPVklERVI6IDEwMTA1LFxuICAgICAgV1NBRVBST1ZJREVSRkFJTEVESU5JVDogMTAxMDYsXG4gICAgICBXU0FTWVNDQUxMRkFJTFVSRTogMTAxMDcsXG4gICAgICBXU0FTRVJWSUNFX05PVF9GT1VORDogMTAxMDgsXG4gICAgICBXU0FUWVBFX05PVF9GT1VORDogMTAxMDksXG4gICAgICBXU0FfRV9OT19NT1JFOiAxMDExMCxcbiAgICAgIFdTQV9FX0NBTkNFTExFRDogMTAxMTEsXG4gICAgICBXU0FFUkVGVVNFRDogMTAxMTJcbiAgICB9LFxuICAgIHNpZ25hbHM6IHtcbiAgICAgIFNJR0hVUDogMSxcbiAgICAgIFNJR0lOVDogMixcbiAgICAgIFNJR0lMTDogNCxcbiAgICAgIFNJR0FCUlQ6IDIyLFxuICAgICAgU0lHRlBFOiA4LFxuICAgICAgU0lHS0lMTDogOSxcbiAgICAgIFNJR1NFR1Y6IDExLFxuICAgICAgU0lHVEVSTTogMTUsXG4gICAgICBTSUdCUkVBSzogMjEsXG4gICAgICBTSUdXSU5DSDogMjhcbiAgICB9LFxuICAgIHByaW9yaXR5OiB7XG4gICAgICBQUklPUklUWV9MT1c6IDE5LFxuICAgICAgUFJJT1JJVFlfQkVMT1dfTk9STUFMOiAxMCxcbiAgICAgIFBSSU9SSVRZX05PUk1BTDogMCxcbiAgICAgIFBSSU9SSVRZX0FCT1ZFX05PUk1BTDogLTcsXG4gICAgICBQUklPUklUWV9ISUdIOiAtMTQsXG4gICAgICBQUklPUklUWV9ISUdIRVNUOiAtMjBcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKGlzQW5kcm9pZCkge1xuICBPUy5jcHVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUaS5QbGF0Zm9ybS5jcHVzKCk7XG4gIH07XG5cbiAgT1MudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ0xpbnV4JztcbiAgfTtcbn1cblxudmFyIHR0eSA9IHtcbiAgaXNhdHR5OiBmdW5jdGlvbiBpc2F0dHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBSZWFkU3RyZWFtOiBmdW5jdGlvbiBSZWFkU3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndHR5LlJlYWRTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH0sXG4gIFdyaXRlU3RyZWFtOiBmdW5jdGlvbiBXcml0ZVN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3R0eS5Xcml0ZVN0cmVhbSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufTtcblxudmFyIE1PTlRIUyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbnZhciB1dGlsID0ge1xuICAvLyBTbyBub2RlIGFjdHVhbGx5IGNhbGxzIGludG8gbmF0aXZlIGNvZGUgZm9yIHRoZXNlIGNoZWNrcywgYnV0IEkgdGhpbmsgZm9yIHNoaW0gY29tcGF0YWJpbGl0eSB0aGlzIGlzIGdvb2QgZW5vdWdoXG4gIC8vIFRoZXJlJ3Mgb3ZlcmhlYWQgZm9yIGRvaW5nIHRoZSBuYXRpdmUgY2hlY2tzLCBhbmQgaXQnZCByZXF1aXJlIGEgbmF0aXZlIG1vZHVsZSB0byBhY2hpZXZlLlxuICB0eXBlczoge1xuICAgIC8vIFRPRE86IFdlJ3JlIG1pc3NpbmcgYSBsb3Qgb2YgdGhlIG1ldGhvZHMgaGFuZ2luZyBvZmYgdGhpcyBuYW1lc3BhY2UhXG4gICAgaXNOdW1iZXJPYmplY3Q6IGZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9LFxuICAgIGlzU3RyaW5nT2JqZWN0OiBmdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfSxcbiAgICBpc0Jvb2xlYW5PYmplY3Q6IGZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICAgIH0sXG4gICAgLy8gaXNCaWdJbnRPYmplY3Q6IHZhbHVlID0+IHtcbiAgICAvLyBcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBCaWdJbnRdJztcbiAgICAvLyB9LFxuICAgIGlzU3ltYm9sT2JqZWN0OiBmdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3ltYm9sXSc7XG4gICAgfSxcbiAgICBpc0JveGVkUHJpbWl0aXZlOiBmdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fCB0aGlzLmlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fCB0aGlzLmlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgLy8gfHwgdGhpcy5pc0JpZ0ludE9iamVjdCh2YWx1ZSlcbiAgICAgIHx8IHRoaXMuaXNTeW1ib2xPYmplY3QodmFsdWUpO1xuICAgIH0sXG4gICAgaXNOYXRpdmVFcnJvcjogZnVuY3Rpb24gaXNOYXRpdmVFcnJvcih2YWx1ZSkge1xuICAgICAgLy8gaWYgbm90IGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLCBkZWZpbml0ZWx5IG5vdCBhIG5hdGl2ZSBlcnJvclxuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdSYW5nZUVycm9yJywgJ1JlZmVyZW5jZUVycm9yJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvciddLmluY2x1ZGVzKHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIH0sXG4gICAgaXNQcm9taXNlOiBmdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcgfHwgdmFsdWVUeXBlID09PSAnZnVuY3Rpb24nKSAmJiB2YWx1ZS50aGVuICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgaXNTZXQ6IGZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG4gICAgfSxcbiAgICBpc01hcDogZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbiAgICB9LFxuICAgIGlzRGF0ZTogZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuICAgIH0sXG4gICAgaXNSZWdleHA6IGZ1bmN0aW9uIGlzUmVnZXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG4gICAgfVxuICB9LFxuICBpc0FycmF5OiBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9LFxuICBpc0Jvb2xlYW46IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgfSxcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdW1iZXI6IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICB9LFxuICBpc1ByaW1pdGl2ZTogZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGw7XG4gIH0sXG4gIGlzU3RyaW5nOiBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc1N5bWJvbDogZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJztcbiAgfSxcbiAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gIH0sXG4gIGxvZzogZnVuY3Rpb24gbG9nKHN0cmluZykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICB2YXIgdGltZSA9IFwiXCIuY29uY2F0KGRhdGUuZ2V0SG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyksIFwiOlwiKS5jb25jYXQoZGF0ZS5nZXRNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpLCBcIjpcIikuY29uY2F0KGRhdGUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSk7IC8vIFByb2R1Y2VzIG91dHB1dCBsaWtlOiBcIjIxIEZlYiAxMDowNDoyMyAtIG1lc3NhZ2VcIlxuXG4gICAgY29uc29sZS5sb2coXCJcIi5jb25jYXQoZGF0ZS5nZXREYXRlKCksIFwiIFwiKS5jb25jYXQoTU9OVEhTW2RhdGUuZ2V0TW9udGgoKV0sIFwiIFwiKS5jb25jYXQodGltZSwgXCIgLSBcIikuY29uY2F0KHN0cmluZykpO1xuICB9LFxuICBwcmludDogZnVuY3Rpb24gcHJpbnQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBjb25zb2xlLmxvZyhhcmdzLmpvaW4oJycpKTtcbiAgfSxcbiAgLy8gRklYTUU6IFNob3VsZG4ndCBhZGQgdHJhaWxpbmcgbmV3bGluZSBsaWtlIGNvbnNvbGUubG9nIGRvZXMhXG4gIHB1dHM6IGZ1bmN0aW9uIHB1dHMoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnNvbGUubG9nKGFyZ3Muam9pbignXFxuJykpO1xuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYXJncy5qb2luKCdcXG4nKSk7XG4gIH0sXG4gIGRlYnVnOiBmdW5jdGlvbiBkZWJ1ZyhzdHJpbmcpIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkRFQlVHOiBcIi5jb25jYXQoc3RyaW5nKSk7XG4gIH1cbn07XG5cbnV0aWwuaXNCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07IC8vIEZJWE1FOiBDaGVjayBmb3IgVGkuQnVmZmVyPyBmb3Igbm9kZS9icm93c2VyaWZ5IGJ1ZmZlcj9cblxuXG51dGlsLmlzRGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdXRpbC50eXBlcy5pc0RhdGUodmFsdWUpO1xufTtcblxudXRpbC5pc0Vycm9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB1dGlsLnR5cGVzLmlzTmF0aXZlRXJyb3IodmFsdWUpO1xufTtcblxudXRpbC5pc1JlZ2V4cCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdXRpbC50eXBlcy5pc1JlZ2V4cCh2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3RvcihvYmopIHtcbiAgaWYgKG9iai5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIHJldHVybiAnT2JqZWN0Jztcbn1cblxudmFyIGRlZmF1bHRJbnNwZWN0T3B0aW9ucyA9IHtcbiAgc2hvd0hpZGRlbjogZmFsc2UsXG4gIGRlcHRoOiAyLFxuICBjb2xvcnM6IGZhbHNlLFxuICBjdXN0b21JbnNwZWN0OiB0cnVlLFxuICBzaG93UHJveHk6IGZhbHNlLFxuICBtYXhBcnJheUxlbmd0aDogMTAwLFxuICBicmVha0xlbmd0aDogNjAsXG4gIGNvbXBhY3Q6IHRydWUsXG4gIHNvcnRlZDogZmFsc2UsXG4gIGdldHRlcnM6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgb3B0aW9ucykge1xuICB2YXIgbWF4TGVuZ3RoID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5tYXhBcnJheUxlbmd0aCk7XG4gIHZhciBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgY29uc2VjdXRpdmVFbXB0aWVzID0gMDtcbiAgdmFyIGkgPSAwOyAvLyBmb3Igc3BhcnNlIGFycmF5cywgY29uc2VjdXRpdmUgZW1wdGllcyBjb3VudCBhcyBhIFwic2luZ2xlIGl0ZW1cIiBpbiB0ZXJtcyBvZiBtYXhBcnJheUxlbmd0aFxuXG4gIGZvciAoOyBpIDwgYXJyYXlMZW5ndGg7IGkrKykge1xuICAgIC8vIGRvbid0IGdvIHBhc3QgZW5kIG9mIGFycmF5Li4uXG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gc3BhcnNlIGFycmF5IVxuICAgICAgY29uc2VjdXRpdmVFbXB0aWVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIG5vbi1lbXB0eSBpbmRleCBjdXJyZW50bHkuLi5cblxuXG4gICAgaWYgKGNvbnNlY3V0aXZlRW1wdGllcyA+IDApIHtcbiAgICAgIC8vIHdlcmUgd2UgY29sbGVjdGluZyBjb25zZWN1dGl2ZSBlbXB0eSBpbmRpY2VzIGFzIGEgc2luZ2xlIGdhcD9cbiAgICAgIHZhbHVlcy5wdXNoKFwiPFwiLmNvbmNhdChjb25zZWN1dGl2ZUVtcHRpZXMsIFwiIGVtcHR5IGl0ZW1cIikuY29uY2F0KGNvbnNlY3V0aXZlRW1wdGllcyA+IDEgPyAncycgOiAnJywgXCI+XCIpKTtcbiAgICAgIGNvbnNlY3V0aXZlRW1wdGllcyA9IDA7IC8vIHJlc2V0IG91ciBjb3VudFxuXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgLy8gZG9uJ3Qgc2hvdyBtb3JlIHRoYW4gb3B0aW9ucy5tYXhBcnJheUxlbmd0aCBcInZhbHVlc1wiXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gcHVzaCB0aGUgY3VycmVudCBpbmRleCB2YWx1ZVxuXG5cbiAgICB2YWx1ZXMucHVzaCh1dGlsLmluc3BlY3QodmFsdWUsIG9wdGlvbnMpKTtcblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID49IG1heExlbmd0aCkge1xuICAgICAgLy8gZG9uJ3Qgc2hvdyBtb3JlIHRoYW4gb3B0aW9ucy5tYXhBcnJheUxlbmd0aCBcInZhbHVlc1wiXG4gICAgICBpKys7IC8vIHNvIG91ciBcInJlbWFpbmluZ1wiIGNvdW50IGlzIGNvcnJlY3RcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IGFycmF5TGVuZ3RoIC0gaTtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIC8vIGRpZCB3ZSBzdG9wIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBhcnJheSAoZHVlIHRvIG9wdGlvbnMubWF4QXJyYXlMZW5ndGgpP1xuICAgIHZhbHVlcy5wdXNoKFwiLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgaXRlbVwiKS5jb25jYXQocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKSk7XG4gIH0gZWxzZSBpZiAoY29uc2VjdXRpdmVFbXB0aWVzID4gMCkge1xuICAgIC8vIGRpZCB0aGUgc3BhcnNlIGFycmF5IGdhcHMgcnVuIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5P1xuICAgIHZhbHVlcy5wdXNoKFwiPFwiLmNvbmNhdChjb25zZWN1dGl2ZUVtcHRpZXMsIFwiIGVtcHR5IGl0ZW1cIikuY29uY2F0KGNvbnNlY3V0aXZlRW1wdGllcyA+IDEgPyAncycgOiAnJywgXCI+XCIpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59XG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqIEpTIHZhbHVlIG9yIG9iamVjdCB0byBpbnNwZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIG91dHB1dFxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5icmVha0xlbmd0aD02MF0gbGVuZ3RoIGF0IHdoaWNoIHRvIGJyZWFrIHByb3BlcnRpZXMgaW50byBpbmRpdmlkdWFsIGxpbmVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3dIaWRkZW49ZmFsc2VdIHdoZXRoZXIgdG8gaW5jbHVkZSBoaWRkZW4gcHJvcGVydGllcyAobm9uLWVudW1lcmFibGUpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNvcnRlZD1mYWxzZV0gd2hldGhlciB0byBzb3J0IHRoZSBwcm9wZXJ0eSBsaXN0aW5ncyBwZXItb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbXBhY3Q9dHJ1ZV0gaWYgc2V0IHRvIGBmYWxzZWAsIHVzZXMgbHV4dXJpb3VzIGFtb3VudCBvZiBzcGFjaW5nIGFuZCBuZXdsaW5lc1xuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5kZXB0aD0yXSBkZXB0aCB0byByZWN1cnNlIGludG8gb2JqZWN0c1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbnV0aWwuaW5zcGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRJbnNwZWN0T3B0aW9ucywgb3B0aW9ucyk7IC8vIGluY3JlYXNlIG91ciByZWN1cnNpb24gY291bnRlciB0byBhdm9pZCBnb2luZyBwYXN0IGRlcHRoXG5cbiAgaWYgKG1lcmdlZE9wdGlvbnMucmVjdXJzaW9uQ291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lcmdlZE9wdGlvbnMucmVjdXJzaW9uQ291bnQgPSAtMTtcbiAgfVxuXG4gIG1lcmdlZE9wdGlvbnMucmVjdXJzaW9uQ291bnQrKztcblxuICBpZiAobWVyZ2VkT3B0aW9ucy5pbmRlbnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVyZ2VkT3B0aW9ucy5pbmRlbnRMZXZlbCA9IDA7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBvYmpUeXBlID0gdHlwZW9mIG9iajtcblxuICAgIGlmIChvYmpUeXBlID09PSAnb2JqZWN0JyB8fCBvYmpUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9IC8vIEd1YXJkIGFnYWluc3QgY2lyY3VsYXIgcmVmZXJlbmNlc1xuXG5cbiAgICAgIG1lcmdlZE9wdGlvbnMubWVtbyA9IG1lcmdlZE9wdGlvbnMubWVtbyB8fCBbXTtcblxuICAgICAgaWYgKG1lcmdlZE9wdGlvbnMubWVtby5pbmNsdWRlcyhvYmopKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1lcmdlZE9wdGlvbnMubWVtby5wdXNoKG9iaik7IC8vIHBvcHBlZCBvZmYgaW4gYSBmaW5hbGx5IGJsb2NrLCBzbyB3ZSBvbmx5IHdvcnJ5IGFib3V0IGNpcmN1bGFyIHJlZmVyZW5jZXMsIG5vdCBzaWJsaW5nIHJlZmVyZW5jZXNcblxuICAgICAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gZ2V0Q29uc3RydWN0b3Iob2JqKTsgLy8gaWYgdGhlIGNvbnN0cnVjdG9yIG5hbWUgaXMgbm90ICdPYmplY3QnLCBwcmUtcGVuZCBpdCFcblxuICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yTmFtZSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgICBwcmVmaXggPSBcIlwiLmNvbmNhdChjb25zdHJ1Y3Rvck5hbWUsIFwiIFwiKTtcbiAgICAgICAgfSAvLyBub3cgZ3JhYiB0aGUgdHlwZSB0YWcgaWYgaXQgaGFzIG9uZSFcblxuXG4gICAgICAgIHZhciB0YWcgPSBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXTtcblxuICAgICAgICBpZiAodGFnICYmIHRhZyAhPT0gY29uc3RydWN0b3JOYW1lKSB7XG4gICAgICAgICAgcHJlZml4ID0gXCJcIi5jb25jYXQocHJlZml4LCBcIltcIikuY29uY2F0KHRhZywgXCJdIFwiKTtcbiAgICAgICAgfSAvLyB3aGF0IGJyYWNlcyBkbyB3ZSB1c2UgdG8gZW5jbG9zZSB0aGUgdmFsdWVzL3Byb3BlcnRpZXM/XG5cblxuICAgICAgICB2YXIgb3BlbiA9ICd7JztcbiAgICAgICAgdmFyIGNsb3NlID0gJ30nO1xuICAgICAgICB2YXIgaGVhZGVyID0gJyc7IC8vIGZvciBzcGVjaWFsIGNhc2VzIGxpa2UgRnVuY3Rpb24gd2hlcmUgd2UgcHJlLXBlbmQgaGVhZGVyIGluZm9cblxuICAgICAgICB2YXIgdmFsdWVzID0gW107IC8vIGNvbGxlY3QgdGhlIHZhbHVlcy9wcm9wZXJ0aWVzIHdlIGxpc3QhXG5cbiAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG9iaik7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICBpZiAocHJlZml4ID09PSAnQXJyYXkgJykge1xuICAgICAgICAgICAgcHJlZml4ID0gJyc7IC8vIHdpcGUgXCJub3JtYWxcIiBBcnJheSBwcmVmaXhlc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wZW4gPSAnWyc7XG4gICAgICAgICAgY2xvc2UgPSAnXSc7XG4gICAgICAgICAgLy8gdXNlIGFycmF5IGJyYWNlc1xuICAgICAgICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgX3RvQ29uc3VtYWJsZUFycmF5KGZvcm1hdEFycmF5KG9iaiwgbWVyZ2VkT3B0aW9ucykpKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzTWFwKG9iaikpIHtcbiAgICAgICAgICBpZiAob2JqLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIF90b0NvbnN1bWFibGVBcnJheShBcnJheS5mcm9tKG9iaikubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodXRpbC5pbnNwZWN0KGVudHJ5WzBdLCBtZXJnZWRPcHRpb25zKSwgXCIgPT4gXCIpLmNvbmNhdCh1dGlsLmluc3BlY3QoZW50cnlbMV0sIG1lcmdlZE9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNTZXQob2JqKSkge1xuICAgICAgICAgIGlmIChvYmouc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5LmZyb20ob2JqKS5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuaW5zcGVjdChvLCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNSZWdleHAob2JqKSkge1xuICAgICAgICAgIC8vIGRvbid0IGRvIHByZWZpeCBvciBhbnkgb2YgdGhhdCBjcmFwISBUT0RPOiBDYW4gd2UganVzdCBjYWxsIFJlZ2V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgpP1xuICAgICAgICAgIHJldHVybiBcIi9cIi5jb25jYXQob2JqLnNvdXJjZSwgXCIvXCIpLmNvbmNhdChvYmouZmxhZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNGdW5jdGlvbihvYmopKSB7XG4gICAgICAgICAgaWYgKHByZWZpeCA9PT0gJ0Z1bmN0aW9uICcpIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICcnOyAvLyB3aXBlIFwibm9ybWFsXCIgRnVuY3Rpb24gcHJlZml4ZXNcbiAgICAgICAgICB9IC8vIEZ1bmN0aW9ucyBhcmUgc3BlY2lhbCBhbmQgd2UgbXVzdCB1c2UgYSBcImhlYWRlclwiXG4gICAgICAgICAgLy8gaWYgbm8gdmFsdWVzL3Byb3BlcnRpZXMsIGp1c3QgcHJpbnQgdGhlIFwiaGVhZGVyXCJcbiAgICAgICAgICAvLyBpZiBhbnksIHN0aWNrIFwiaGVhZGVyXCIgaW5zaWRlIGJyYWNlcyBiZWZvcmUgcHJvcGVydHkvdmFsdWUgbGlzdGluZ1xuXG5cbiAgICAgICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgICAgIGhlYWRlciA9IFwiW0Z1bmN0aW9uOiBcIi5jb25jYXQob2JqLm5hbWUsIFwiXVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyID0gJ1tGdW5jdGlvbl0nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB3ZSd2ZSBnb25lIHBhc3Qgb3VyIGRlcHRoLCBqdXN0IGRvIGEgcXVpY2tpZSByZXN1bHQgaGVyZSwgbGlrZSAnW09iamVjdF0nXG5cblxuICAgICAgICBpZiAobWVyZ2VkT3B0aW9ucy5yZWN1cnNpb25Db3VudCA+IG1lcmdlZE9wdGlvbnMuZGVwdGgpIHtcbiAgICAgICAgICByZXR1cm4gaGVhZGVyIHx8IFwiW1wiLmNvbmNhdChjb25zdHJ1Y3Rvck5hbWUgfHwgdGFnIHx8ICdPYmplY3QnLCBcIl1cIik7XG4gICAgICAgIH0gLy8gaGFuZGxlIHByb3BlcnRpZXNcblxuXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107IC8vIGlmIHNob3dpbmcgaGlkZGVuLCBnZXQgYWxsIG93biBwcm9wZXJ0aWVzLCBvdGhlcndpc2UganVzdCBlbnVtZXJhYmxlXG5cbiAgICAgICAgdmFyIG93blByb3BlcnRpZXMgPSBtZXJnZWRPcHRpb25zLnNob3dIaWRkZW4gPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTsgLy8gRklYTUU6IE9uIFY4L0FuZHJvaWQgd2UgYXJlIG5vdCBnZXR0aW5nICdhcmd1bWVudHMnIGFuZCAnY2FsbGVyJyBwcm9wZXJ0aWVzIVxuICAgICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGluIG5ld2VyIHNwZWNzL3N0cmljdCBtb2RlIHRoZXkgc2hvdWxkbid0IGJlIGFjY2Vzc2libGU/XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gb3duUHJvcGVydGllc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheSAmJiBwcm9wTmFtZS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICAgICAgLy8gc2tpcCBBcnJheSdzIGluZGV4IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wTmFtZSkgfHwge1xuICAgICAgICAgICAgICB2YWx1ZTogb2JqW3Byb3BOYW1lXSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTsgLy8gZmFsbCBiYWNrIHRvIGZha2luZyBhIGRlc2NyaXB0b3JcblxuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BEZXNjLmVudW1lcmFibGUgPyBwcm9wTmFtZSA6IFwiW1wiLmNvbmNhdChwcm9wTmFtZSwgXCJdXCIpOyAvLyBJZiBub3QgZW51bWVyYWJsZSwgd3JhcCBuYW1lIGluIFtdIVxuXG4gICAgICAgICAgICBpZiAocHJvcERlc2MudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zLmluZGVudExldmVsICs9IDM7IC8vIE5vZGUgdXNlcyAzIHNwYWNlcyBmb3IgYXJyYXlzL09iamVjdHM/XG5cbiAgICAgICAgICAgICAgdmFyIHNwYWNlID0gJyAnO1xuXG4gICAgICAgICAgICAgIHZhciBfdmFsdWUyID0gdXRpbC5pbnNwZWN0KHByb3BEZXNjLnZhbHVlLCBtZXJnZWRPcHRpb25zKTsgLy8gaWYgdmFsdWUgaXMgYnJlYWtpbmcsIGJyZWFrIGJldHdlZW4ga2V5IGFuZCB0b3AtbGV2ZWwgdmFsdWVcblxuXG4gICAgICAgICAgICAgIGlmIChfdmFsdWUyLmxlbmd0aCA+IG1lcmdlZE9wdGlvbnMuYnJlYWtMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSA9IFwiXFxuXCIuY29uY2F0KCcgJy5yZXBlYXQobWVyZ2VkT3B0aW9ucy5pbmRlbnRMZXZlbCkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5pbmRlbnRMZXZlbCAtPSAzO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goXCJcIi5jb25jYXQoa2V5LCBcIjpcIikuY29uY2F0KHNwYWNlKS5jb25jYXQoX3ZhbHVlMikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wRGVzYy5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgd2hlbiBvcHRpb25zLmdldHRlcnMgPT09IHRydWUsIG5lZWQgdG8gYWN0dWFsbHkgYXR0ZW1wdCB0byBnZXQgYW5kIHNob3cgdmFsdWUhXG4gICAgICAgICAgICAgIGlmIChwcm9wRGVzYy5zZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChcIlwiLmNvbmNhdChrZXksIFwiOiBbR2V0dGVyL1NldHRlcl1cIikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChcIlwiLmNvbmNhdChrZXksIFwiOiBbR2V0dGVyXVwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcERlc2Muc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKFwiXCIuY29uY2F0KGtleSwgXCI6IFtTZXR0ZXJdXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHdlaXJkIGNhc2Ugb2YgYSBwcm9wZXJ0eSBkZWZpbmVkIHdpdGggYW4gZXhwbGljaXQgdW5kZWZpbmVkIHZhbHVlXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChcIlwiLmNvbmNhdChrZXksIFwiOiB1bmRlZmluZWRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSBjdXN0b20gc29ydGluZyBvcHRpb24hXG4gICAgICAgICAgaWYgKG1lcmdlZE9wdGlvbnMuc29ydGVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNvcnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gJyc7XG5cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAoaGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gaGVhZGVyOyAvLyBpLmUuICdbRnVuY3Rpb246IG5hbWVdJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiXCIuY29uY2F0KG9wZW4pLmNvbmNhdChjbG9zZSk7IC8vIG5vIHNwYWNlcywgaS5lLiAne30nIG9yICdbXSdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICAgICAgaWYgKGhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBpLmUuICd7IFtGdW5jdGlvbl0gYTogMSwgYjogMiB9J1xuICAgICAgICAgICAgc3RyID0gXCJcIi5jb25jYXQoaGVhZGVyLCBcIiBcIik7XG4gICAgICAgICAgfSAvLyBIYW5kbGUgYnJlYWtpbmcgdGhlbSBieSBicmVha0xlbmd0aCBoZXJlIVxuXG5cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX3ZhbHVlcyA9IHZhbHVlczsgX2kgPCBfdmFsdWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IF92YWx1ZXNbX2ldO1xuICAgICAgICAgICAgbGVuZ3RoICs9IF92YWx1ZS5sZW5ndGggKyAxOyAvLyBOb2RlIHNlZW1zIHRvIGFkZCBvbmUgZm9yIGNvbW1hLCBidXQgbm90IG1vcmUgZm9yIHNwYWNlcz9cblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IG1lcmdlZE9wdGlvbnMuYnJlYWtMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gYnJlYWsgZWFybHkgaWYgbGVuZ3RoID4gYnJlYWtMZW5ndGghXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGggPiBtZXJnZWRPcHRpb25zLmJyZWFrTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gJyAnLnJlcGVhdChtZXJnZWRPcHRpb25zLmluZGVudExldmVsKTsgLy8gYnJlYWsgdGhlbSB1cCFcblxuICAgICAgICAgICAgc3RyICs9IHZhbHVlcy5qb2luKFwiLFxcblwiLmNvbmNhdChpbmRlbnQsIFwiICBcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gdmFsdWVzLmpvaW4oJywgJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBcIlwiLmNvbmNhdChvcGVuLCBcIiBcIikuY29uY2F0KHN0ciwgXCIgXCIpLmNvbmNhdChjbG9zZSk7IC8vIHNwYWNlcyBiZXR3ZWVuIGJyYWNlcyBhbmQgdmFsdWVzL3Byb3BlcnRpZXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtZXJnZWRPcHRpb25zLm1lbW8ucG9wKG9iaik7XG4gICAgICB9XG4gICAgfSAvLyBvbmx5IHNwZWNpYWwgY2FzZSBpcyAtMFxuXG5cbiAgICBpZiAob2JqVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBcIidcIi5jb25jYXQob2JqLCBcIidcIik7XG4gICAgfSBlbHNlIGlmIChvYmpUeXBlID09PSAnbnVtYmVyJyAmJiBPYmplY3QuaXMob2JqLCAtMCkpIHtcbiAgICAgIC8vIGNhbid0IGNoZWNrIGZvciAtMCB1c2luZyA9PT1cbiAgICAgIHJldHVybiAnLTAnO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc1N5bWJvbChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gICAgfSAvLyBUT0RPOiBIYW5kbGUgQmlnSW50P1xuXG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQob2JqKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBtZXJnZWRPcHRpb25zLnJlY3Vyc2lvbkNvdW50LS07XG4gIH1cbn07XG4vKipcbiAqIFJldHJ1bnMgcmVzdWx0IG9mIGBKU09OLnN0cmluZ2lmeSgpYCBpZiBwb3NzaWJsZSwgZmFsbGluZyBiYWNrIHRvIGAnW0NpcmN1bGFyXSdgIGlmIHRoYXQgdGhyb3dzLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUvb2JqZWN0IHRvIHN0cmluZ2lmeVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZS5tZXNzYWdlLmluY2x1ZGVzKCdjaXJjdWxhcicpIHx8IGUubWVzc2FnZS5pbmNsdWRlcygnY3ljbGljJykpKSB7XG4gICAgICAvLyBcIkNvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT05cIlxuICAgICAgLy8gSlNDIGdpdmVzOiBcIkpTT04uc3RyaW5naWZ5IGNhbm5vdCBzZXJpYWxpemUgY3ljbGljIHN0cnVjdHVyZXMuXCJcbiAgICAgIC8vIFRPRE86IE1heWJlIGZvcmNlIGEgY2lyY3VsYXIgcmVmZXJlbmNlIG9iamVjdCB0aHJvdWdoIGFuZCBzbmlmZiB0aGUgSlMgZW5naW5lJ3MgbWVzc2FnZSBnZW5lcmF0ZWQgdG8gbWF0Y2ggYWdhaW5zdD9cbiAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG51dGlsLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgdmFyIGZpcnN0QXJnID0gYXJnc1swXTtcblxuICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnc3RyaW5nJykge1xuICAgIC8vIG5vcm1hbCB1c2FnZSFcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBmaXJzdEFyZztcbiAgICB9IC8vIFRPRE86IG9rLCB3ZSByZWFsbHkgZG8gaGF2ZSB0byBsb29rIGF0IHRoZSBzdHJpbmcgdG8gZmluZCB0aGUgJSBzcGVjaWZpZXJzXG4gICAgLy8gRG8gd2UgbG9vcCBvdmVyIHRoZSBhcmdzLmxlbmd0aCBhbmQgZmluZCBuZXh0IGluZGV4IG9mICclJywgbWF0Y2ggd2hhdCB0eXBlIGl0IGlzIGFuZCByZXBsYWNlP1xuXG5cbiAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIGkgPSAxOyAvLyBzdGFydCBhdCBzZWNvbmQgYXJndW1lbnRcblxuICAgIGZvciAoaTsgaSA8IGFyZ3MubGVuZ3RoOykge1xuICAgICAgdmFyIGN1ckFyZyA9IGFyZ3NbaV07XG4gICAgICB2YXIgZm91bmRJbmRleCA9IGZpcnN0QXJnLmluZGV4T2YoJyUnLCBsYXN0SW5kZXgpO1xuXG4gICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgLy8gTm8gbW9yZSBwbGFjZWhvbGRlcnMgbGVmdCwgc28gYnJlYWsgYW5kIGF0IGJvdHRvbSB3ZSdsbCBhcHBlbmQgcmVzdCBvZiBzdHJpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGdyYWIgc2VnbWVudCBvZiBzdHJpbmcgYW5kIGFwcGVuZCB0byBzdHJcblxuXG4gICAgICBzdHIgKz0gZmlyc3RBcmcuc2xpY2UobGFzdEluZGV4LCBmb3VuZEluZGV4KTsgLy8gbm93IGxvb2sgYXQgbmV4dCBjaGFyIHRvIHNlZSBob3cgdG8gcmVwbGFjZVxuXG4gICAgICB2YXIgbmV4dENoYXIgPSBmaXJzdEFyZy5jaGFyQXQoZm91bmRJbmRleCArIDEpO1xuXG4gICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcoY3VyQXJnKTtcbiAgICAgICAgICBpKys7IC8vIGNvbnN1bWUgYXJndW1lbnRcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgIC8vIE51bWJlclxuICAgICAgICAgIGlmICh1dGlsLmlzU3ltYm9sKGN1ckFyZykgfHwgdXRpbC50eXBlcy5pc1N5bWJvbE9iamVjdChjdXJBcmcpKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ05hTic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBOdW1iZXIoY3VyQXJnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpKys7IC8vIGNvbnN1bWUgYXJndW1lbnRcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICBpZiAodXRpbC5pc1N5bWJvbChjdXJBcmcpIHx8IHV0aWwudHlwZXMuaXNTeW1ib2xPYmplY3QoY3VyQXJnKSkge1xuICAgICAgICAgICAgc3RyICs9ICdOYU4nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gcGFyc2VJbnQoY3VyQXJnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpKys7IC8vIGNvbnN1bWUgYXJndW1lbnRcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgIC8vIEZsb2F0XG4gICAgICAgICAgaWYgKHV0aWwuaXNTeW1ib2woY3VyQXJnKSB8fCB1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGN1ckFyZykpIHtcbiAgICAgICAgICAgIHN0ciArPSAnTmFOJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IHBhcnNlRmxvYXQoY3VyQXJnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpKys7IC8vIGNvbnN1bWUgYXJndW1lbnRcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgIC8vIEpTT05cbiAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5KGN1ckFyZyk7XG4gICAgICAgICAgaSsrOyAvLyBjb25zdW1lIGFyZ3VtZW50XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAvLyBPYmplY3Qgdy9zaG93SGlkZGVuIGFuZCBzaG93UHJveHlcbiAgICAgICAgICBzdHIgKz0gdXRpbC5pbnNwZWN0KGN1ckFyZywge1xuICAgICAgICAgICAgc2hvd0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dQcm94eTogdHJ1ZSxcbiAgICAgICAgICAgIGRlcHRoOiA0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaSsrOyAvLyBjb25zdW1lIGFyZ3VtZW50XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdPJzpcbiAgICAgICAgICAvLyBPYmplY3Qgdy9vIG9wdGlvbnNcbiAgICAgICAgICBzdHIgKz0gdXRpbC5pbnNwZWN0KGN1ckFyZywge30pO1xuICAgICAgICAgIGkrKzsgLy8gY29uc3VtZSBhcmd1bWVudFxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgLy8gZXNjYXBlZCAlXG4gICAgICAgICAgc3RyICs9ICclJzsgLy8gRG9uJ3QgY29uc3VtZSBhcmd1bWVudCBoZXJlIVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxhc3RJbmRleCA9IGZvdW5kSW5kZXggKyAyO1xuICAgIH0gLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIGVuZCBvZiBzdHJpbmcsIGFwcGVuZCByZXN0IG9mIGl0IHdpdGggbm8gcmVwbGFjZW1lbnRzIVxuXG5cbiAgICBzdHIgKz0gZmlyc3RBcmcuc2xpY2UobGFzdEluZGV4LCBmaXJzdEFyZy5sZW5ndGgpOyAvLyBJZiB3ZSBoYXZlIGFyZ3MgcmVtYWluaW5nLCBuZWVkIHRvLi4uXG4gICAgLy8gbG9vcCBvdmVyIHJlc3Qgb2YgYXJncyBhbmQgY29lcmNlIHRvIFN0cmluZ3MgYW5kIGNvbmNhdCBqb2luZWQgYnkgc3BhY2VzLlxuICAgIC8vIFVubGVzcyB0eXBlb2YgPT09ICdvYmplY3QnIG9yICdzeW1ib2wnLCB0aGVuIGRvIHV0aWwuaW5zcGVjdCgpIG9uIHRoZW1cblxuICAgIGlmIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIHN0ciArPSBcIiBcIi5jb25jYXQoYXJncy5zbGljZShpKS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGFUeXBlID0gdHlwZW9mIGE7XG5cbiAgICAgICAgc3dpdGNoIChhVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiB1dGlsLmluc3BlY3QoYSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgICAgICAgfVxuICAgICAgfSkuam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9IC8vIGZpcnN0IGFyZyB3YXNuJ3Qgc3RyaW5nLCBzbyB3ZSBsb29wIG92ZXIgYXJncyBhbmQgY2FsbCB1dGlsLmluc3BlY3Qgb24gZWFjaFxuXG5cbiAgcmV0dXJuIGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChhKTtcbiAgfSkuam9pbignICcpO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3Igc3ViY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3IgYmFzZSBjbGFzc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuXG51dGlsLmluaGVyaXRzID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShjb25zdHJ1Y3RvciwgJ2NvbnN0cnVjdG9yJywgJ0Z1bmN0aW9uJyk7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShzdXBlckNvbnN0cnVjdG9yLCAnc3VwZXJDb25zdHJ1Y3RvcicsICdGdW5jdGlvbicpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZScsICdPYmplY3QnKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnc3VwZXJfJywge1xuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yXG4gIH0pO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY29uc3RydWN0b3IucHJvdG90eXBlLCBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcmlnaW5hbCBvcmlnaW5hbCBmdW5jdGlvbiB0byB3cmFwIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBmaW5hbCBjYWxsYmFjayBhcmd1bWVudFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlXG4gKi9cblxuXG51dGlsLnByb21pc2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBvcmlnaW5hbC5jYWxsLmFwcGx5KG9yaWdpbmFsLCBbX3RoaXNdLmNvbmNhdChhcmdzLCBbZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfV0pKTtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCB0byB3cmFwcGVkXG4gIC8vIFRPRE86IGhvb2sgcHJvdG90eXBlIGNoYWluIHVwIGZyb20gd3JhcHBlZCB0byBvcmlnaW5hbFxuICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSBwcm9taXNpZnkgaG9va3NcblxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gY29udmVydCBmcm9tIGFzeW5jL1Byb21pc2UgcmV0dXJuIHZhbHVlIHRvIGEgY2FsbGJhY2sgc3R5bGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuICovXG5cblxudXRpbC5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICB2YXIgcHJvbWlzZSA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvYWx3YXlzLXJldHVyblxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICB2YXIgd3JhcHBlZEVycm9yID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGZhbHN5IHZhbHVlJyk7XG4gICAgICAgIHdyYXBwZWRFcnJvci5yZWFzb24gPSBlcnI7XG4gICAgICAgIGVyciA9IHdyYXBwZWRFcnJvcjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiB0byBkZXByZWNhdGUvd3JhcFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBtZXNzYWdlIHRvIGdpdmUgd2hlbiBkZXByZWNhdGlvbiB3YXJuaW5nIGlzIGVtaXR0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIGRlcHJlY2F0aW9uIGNvZGUgdG8gdXNlIHRvIGdyb3VwIHdhcm5pbmdzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuXG5cbnV0aWwuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHN0cmluZywgY29kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4gZnVuYzsgLy8gc2tpcCB0aGUgd3JhcHBpbmchXG4gIH0gLy8gVE9ETzogU3VwcG9ydCBgY29kZWAgYXJndW1lbnQgYnkgdHJhY2tpbmcgYSBtYXAgb2YgY29kZXMgd2UndmUgd2FybmVkIGFib3V0XG5cblxuICBmdW5jdGlvbiB3cmFwcGVkKCkge1xuICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHN0cmluZywgJ0RlcHJlY2F0aW9uV2FybmluZycpO1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVkO1xufTsgLy8gVE9ETzogU3VwcG9ydCBkZWJ1Z2xvZz8gV2hhdCBpcyBvdXIgZXF1aXZhbGVudCBvZiBwcm9jZXNzLmVudignTk9ERV9ERUJVRycpP1xuXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG51dGlsLmRlYnVnbG9nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbm9vcDtcbn07XG5cbnZhciBERUZBVUxUX01FU1NBR0VTID0ge1xuICBkZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbDonLFxuICBzdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLFxuICBkZWVwRXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsOicsXG4gIGVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZXF1YWw6JyxcbiAgbm90RGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgc3RyaWN0bHkgdW5lcXVhbCB0bzonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonXG59OyAvLyBGYWtlIGVudW1zIHRvIHVzZSBpbnRlcm5hbGx5XG5cbnZhciBDT01QQVJFX1RZUEUgPSB7XG4gIE9iamVjdDogMCxcbiAgTWFwOiAxLFxuICBTZXQ6IDJcbn07XG52YXIgU1RSSUNUTkVTUyA9IHtcbiAgU3RyaWN0OiAwLFxuICBMb29zZTogMVxufTtcblxudmFyIEFzc2VydGlvbkVycm9yID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEFzc2VydGlvbkVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNzZXJ0aW9uRXJyb3IpO1xuXG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQsXG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcblxuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gRklYTUU6IEdlbmVyYXRlIHRoZSByZXN0IG9mIHRoZSBtZXNzYWdlIHdpdGggZGlmZiBvZiBhY3R1YWwvZXhwZWN0ZWQhXG4gICAgICBtZXNzYWdlID0gXCJcIi5jb25jYXQoREVGQVVMVF9NRVNTQUdFU1tvcGVyYXRvcl0sIFwiXFxuXFxuXCIpO1xuICAgIH1cblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIG1lc3NhZ2UpKTtcbiAgICBfdGhpcy5hY3R1YWwgPSBhY3R1YWw7XG4gICAgX3RoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBfdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXSc7XG4gICAgX3RoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTsgLy8gVE9ETzogQ2FuIHdlIGRlZmluZSBBc3NlcnRTdHJpY3QgYW5kIEFzc2VydExvb3NlIGFzIHN1YmNsYXNzZXMgb2YgYSBiYXNlIEFzc2VydCBjbGFzc1xuLy8gdGhhdCBjbGFzcyBob2xkcyBpbXBscyBmb3Igc2hhcmVkIG1ldGhvZHMsIHN1YmNsYXNzZXMgb3ZlcnJpZGUgc3BlY2lmaWNcbi8vIGNvbXBhcmlzb25zIHVzZWQgKE9iamVjdC5pcyB2cyA9PT0pP1xuXG5cbnZhciBhc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGFzc2VydC5vayh2YWx1ZSwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuYXNzZXJ0Lm9rID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gIHZhciBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7IC8vIENoZWNrIGlmIHZhbHVlICgxc3QgYXJnKSB3YXMgbm90IHN1cHBsaWVkIVxuICAvLyBIYXZlIHRvIHVzZSB1Z2x5IGhhY2sgb24gYXJncyBkZWZpbml0aW9uIHRvIGRvIHNvXG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICBnZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgLy8gVE9ETzogZ2VuZXJhdGUgcmVzdCBvZiB0aGUgbWVzc2FnZS4gTm9kZSBhY3R1YWxseSByZWFkcyB0aGUgaW5wdXQgZmlsZSEgVGhlIGhhY2tlZCBicm93c2VyaWZ5IGRvZXMgbm90IGRvIHRoaXNcbiAgICAvLyBJdCB0cmVhdGVzIG9rIGZhaWxpbmcgbGlrZSBgdmFsdWUgPT0gdHJ1ZWAgZmFpbGluZ1xuICAgIG1lc3NhZ2UgPSAnVGhlIGV4cHJlc3Npb24gZXZhbHVhdGVkIHRvIGEgZmFsc3kgdmFsdWU6XFxuXFxuJztcbiAgICBnZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0aHJvdyBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgYWN0dWFsOiB2YWx1ZSxcbiAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnPT0nXG4gIH0pO1xuICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gIHRocm93IGVycjtcbn07XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Iob2JqKSB7XG4gIC8vIElmIG1lc3NhZ2UgaXMgYW4gRXJyb3Igb2JqZWN0LCB0aHJvdyB0aGF0IGluc3RlYWQhXG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIH1cblxuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdlcXVhbCdcbiAgfSk7XG59O1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ25vdEVxdWFsJ1xuICB9KTtcbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgLy8gcHJvdmlkZXMgU2FtZVZhbHVlIGNvbXBhcmlzb24gZm9yIHVzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuXG52YXIgaXNQcmltaXRpdmUgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGw7XG59O1xuLyoqXG4gKiBAcGFyYW0ge01hcH0gYWN0dWFsIG1hcCB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge01hcH0gZXhwZWN0ZWQgbWFwIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcGFyYW0ge1NUUklDVE5FU1MuTG9vc2V8c3RyaWN0bmVzcy5TdHJpY3R9IHN0cmljdG5lc3MgaG93IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VzIG1lbW9pemVkIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGUgZGVlcEVxdWFsIGhpZXJhcmNoeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlTWFwcyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIHZhciBsb29zZUNoZWNrcyA9IG5ldyBTZXQoKTsgLy8ga2VlcCB0cmFjayBvZiBvYmplY3RzIHdlIG5lZWQgdG8gdGVzdCBtb3JlIGV4dGVuc2l2ZWx5IHRoYW4gdXNpbmcgI2dldCgpLyNoYXMoKVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFjdHVhbFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vbi1udWxsIG9iamVjdC4gV2UgbmVlZCB0byBkbyBvdXIgb3duIGNoZWNraW5nLCBub3QgdXNlIGdldCgpL2hhcygpXG4gICAgICAgIGxvb3NlQ2hlY2tzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGFuZGxlIFwicHJpbWl0aXZlc1wiXG4gICAgICAgIGlmIChleHBlY3RlZC5oYXMoa2V5KSAmJiBkZWVwRXF1YWwodmFsdWUsIGV4cGVjdGVkLmdldChrZXkpLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICAgIC8vIHlheSEgYSBuaWNlIGVhc3kgbWF0Y2ggLSBib3RoIGtleSBhbmQgdmFsdWUgbWF0Y2hlZCBleGFjdGx5IC0gbW92ZSBvblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgICAgICAgLy8gaWYgd2UgZGlkbid0IG1hdGNoIGtleS92YWx1ZSBwZXJmZWN0bHkgaW4gc3RyaWN0IG1vZGUsIGZhaWwgcmlnaHQgYXdheVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyBvaywgc28gaXQgZGlkbid0IG1hdGNoIGtleS92YWx1ZSBwZXJmZWN0bHkgLSBidXQgd2UncmUgaW4gbG9vc2UgbW9kZSwgc28gZmFsbCBiYWNrIHRvIHRyeSBhZ2FpblxuXG5cbiAgICAgICAgbG9vc2VDaGVja3MuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3NlQ2hlY2tzLnNpemUgPT09IDApIHtcbiAgICAvLyBubyBsb29zZSBlbmRzIHRvIHRpZSB1cCwgZXZlcnl0aGluZyBtYXRjaGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gb25seSBnbyB0aHJvdWdoIHRoZSBzZWNvbmQgTWFwIG9uY2UhXG5cblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZXhwZWN0ZWRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgIGV4cGVjdGVkS2V5ID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgIGV4cGVjdGVkVmFsdWUgPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgIC8vIGlmIGl0J3Mgbm90IGEgbm9uLW51bGwgb2JqZWN0IGluIHN0cmljdCBtb2RlLCBmYWlsIVxuICAgICAgLy8gKGkuZS4gaWYgaXQncyBhIHByaW1pdGl2ZSB0aGF0IGZhaWxlZCBhIG1hdGNoLCBkb24ndCBmYWxsIGJhY2sgdG8gbW9yZSBsb29zZWx5IG1hdGNoIGl0KVxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgc2hvdWxkbid0IGV2ZXIgaGFwcGVuIHNpbmNlIHdlIHNob3VsZCBiZSByZXR1cm5pbmcgZmFsc2UgaW1tZWRpYXRlbHkgYWJvdmVcbiAgICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCAmJiAhKHR5cGVvZiBleHBlY3RlZEtleSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWRLZXkgIT09IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlLCB0ZXN0IGl0IC8vIFRPRE86IFdpc2ggd2UgY291bGQgdXNlICNmaW5kKCkgbGlrZSBvbiBhbiBBcnJheSwgYnV0IFNldCBkb2Vzbid0IGhhdmUgaXQhXG5cblxuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGxvb3NlQ2hlY2tzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIC8vIGlmIGJvdGgga2V5IGFuZCB2YWx1ZSBtYXRjaGVzXG4gICAgICAgICAgaWYgKGRlZXBFcXVhbChrZXksIGV4cGVjdGVkS2V5LCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSAmJiBkZWVwRXF1YWwoYWN0dWFsLmdldChrZXkpLCBleHBlY3RlZFZhbHVlLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKGtleSk7IC8vIHJlbW92ZSBmcm9tIG91ciBsb29zZUNoZWNrcyBTZXQgc2luY2Ugd2UgYWxyZWFkeSBtYXRjaGVkIGl0XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBub3QgZm91bmQsIHdlIGZhaWxlZCB0byBtYXRjaFxuXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBkaWQgd2UgbGVhdmUgdW4tbWF0Y2hlZCBrZXlzPyBpZiBzbywgZmFpbFxuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvb3NlQ2hlY2tzLnNpemUgPT09IDA7XG59XG4vKipcbiAqIEBwYXJhbSB7U2V0fSBhY3R1YWwgbWFwIHdlIGFyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7U2V0fSBleHBlY3RlZCBtYXAgd2UncmUgY29tcGFyaW5nIGFnYWluc3RcbiAqIEBwYXJhbSB7c3RyaWN0bmVzcy5Mb29zZXxzdHJpY3RuZXNzLlN0cmljdH0gc3RyaWN0bmVzcyBob3cgdG8gY29tcGFyZVxuICogQHBhcmFtIHtvYmplY3R9IHJlZmVyZW5jZXMgbWVtb2l6ZWQgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoZSBkZWVwRXF1YWwgaGllcmFyY2h5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmVTZXRzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpIHtcbiAgdmFyIGxvb3NlQ2hlY2tzID0gbmV3IFNldCgpOyAvLyBrZWVwIHRyYWNrIG9mIHZhbHVlcyB3ZSBuZWVkIHRvIHRlc3QgbW9yZSBleHRlbnNpdmVseSB0aGFuIHVzaW5nICNoYXMoKVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBhY3R1YWxbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gbm9uLW51bGwgb2JqZWN0LiBXZSBuZWVkIHRvIGRvIG91ciBvd24gY2hlY2tpbmcsIG5vdCB1c2UgaGFzKClcbiAgICAgICAgbG9vc2VDaGVja3MuYWRkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWV4cGVjdGVkLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgLy8gRklYTUU6IGhhcyBkb2VzIFwic2FtZS12YWx1ZS16ZXJvXCIgY2hlY2ssIHdoaWNoIGlzIGxpa2UgT2JqZWN0LmlzIGV4Y2VwdCBmb3IgLTAvKzAgYmVpbmcgY29uc2lkZXJlZCBlcXVhbFxuICAgICAgICAvLyBzbyBtYXkgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhhdCBoZXJlLCB0aGF0J2QgaGF2ZSB0byBiZSBpbiBhbiBlbHNlIGJlbG93IChzaW5jZSBoYXMgd2lsbCByZXR1cm4gdHJ1ZSBoZXJlKVxuICAgICAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgICAgICAvLyBmYWlsZWQgXCJzYW1lLXZhbHVlXCIgbWF0Y2ggZm9yIHByaW1pdGl2ZSBpbiBzdHJpY3QgbW9kZSwgc28gZmFpbCByaWdodCBhd2F5XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIFdoZW4gZG9pbmcgbG9vc2UgY2hlY2ssIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIGxvb3NlciBjaGVjayB0aGFuICNoYXMoKSwgc28gd2UgY2FuJ3QganVzdCByZXR1cm4gZmFsc2UgaW1tZWRpYXRlbHkgaGVyZVxuICAgICAgICAvLyBhZGQgdG8gc2V0IG9mIHZhbHVlcyB0byBjaGVjayBtb3JlIHRob3JvdWdobHlcblxuXG4gICAgICAgIGxvb3NlQ2hlY2tzLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsb29zZUNoZWNrcy5zaXplID09PSAwKSB7XG4gICAgLy8gbm8gbG9vc2UgZW5kcyB0byB0aWUgdXAsIGV2ZXJ5dGhpbmcgbWF0Y2hlZFxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFRyeSB0byB3aGl0dGxlIGRvd24gdGhlIGxvb3NlIGNoZWNrcyBzZXQgdG8gYmUgZW1wdHkuLi5cbiAgLy8gb25seSBnbyB0aHJvdWdoIHRoZSBzZWNvbmQgU2V0IG9uY2UhXG5cblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvcjUgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gZXhwZWN0ZWRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgIHZhciBleHBlY3RlZFZhbHVlID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAvLyBpZiBpdCdzIG5vdCBhIG5vbi1udWxsIG9iamVjdCBpbiBzdHJpY3QgbW9kZSwgZmFpbCFcbiAgICAgIC8vIChpLmUuIGlmIGl0J3MgYSBwcmltaXRpdmUgdGhhdCBmYWlsZWQgYSBtYXRjaCwgZG9uJ3QgZmFsbCBiYWNrIHRvIG1vcmUgbG9vc2VseSBtYXRjaCBpdClcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHNob3VsZG4ndCBldmVyIGhhcHBlbiBzaW5jZSB3ZSBzaG91bGQgYmUgcmV0dXJuaW5nIGZhbHNlIGltbWVkaWF0ZWx5IGFib3ZlXG4gICAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QgJiYgISh0eXBlb2YgZXhwZWN0ZWRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWRWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gbG9vc2VDaGVja3NbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGRlZXBFcXVhbChvYmplY3QsIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7IC8vIGZvdW5kIGEgbWF0Y2ghXG5cbiAgICAgICAgICAgIGxvb3NlQ2hlY2tzLmRlbGV0ZShvYmplY3QpOyAvLyByZW1vdmUgZnJvbSBvdXIgbG9vc2VDaGVja3MgU2V0IHNpbmNlIHdlIG1hdGNoZWQgaXRcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIG5vdCBmb3VuZCwgd2UgZmFpbGVkIHRvIG1hdGNoXG5cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIGRpZCB3ZSBsZWF2ZSB1bi1tYXRjaGVkIHZhbHVlcz8gaWYgc28sIGZhaWxcblxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb29zZUNoZWNrcy5zaXplID09PSAwO1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IGFjdHVhbCB2YWx1ZSB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0geyp9IGV4cGVjdGVkIHZhbHVlcyB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtTVFJJQ1RORVNTLlN0cmljdHxTVFJJQ1RORVNTLkxvb3NlfSBzdHJpY3RuZXNzIGhvdyBzdHJpY3QgYSBjb21wYXJpc29uIHRvIGRvXG4gKiBAcGFyYW0ge29iamVjdH0gW3JlZmVyZW5jZXNdIG9wdGlvbmFsIG9iamVjdCB0byBrZWVwIHRyYWNrIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gdGhlIGhpZXJhcmNoeVxuICogQHBhcmFtIHtNYXA8b2JqZWN0LG51bWJlcj59IFtyZWZlcmVuY2VzLmFjdHVhbF0gbWFwcGluZyBmcm9tIG9iamVjdHMgdmlzaXRlZCAob24gYGFjdHVhbGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge01hcDxvYmplY3QsbnVtYmVyPn0gW3JlZmVyZW5jZXMuZXhwZWN0ZWRdIG1hcHBpbmcgZnJvbSBvYmplY3RzIHZpc2l0ZWQgKG9uIGBleHBlY3RlZGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge251bWJlcn0gW3JlZmVyZW5jZXMuZGVwdGhdIFRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpIHtcbiAgLy8gaWYgcHJpbWl0aXZlcywgY29tcGFyZSB1c2luZyBPYmplY3QuaXNcbiAgLy8gVGhpcyBoYW5kbGVzOiBudWxsLCB1bmRlZmluZWQsIG51bWJlciwgc3RyaW5nLCBib29sZWFuXG4gIGlmIChpc1ByaW1pdGl2ZShhY3R1YWwpICYmIGlzUHJpbWl0aXZlKGV4cGVjdGVkKSkge1xuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICB9XG4gIH0gLy8gTm93IHdlIGhhdmUgdmFyaW91cyBvYmplY3RzL2Z1bmN0aW9uczpcbiAgLy8gRGF0ZSwgRXJyb3IsIFJlZ0V4cCwgQXJyYXksIE1hcCwgU2V0LCBPYmplY3QsIEZ1bmN0aW9uLCBBcnJvdyBmdW5jdGlvbnMsIFdlYWtNYXAsIERhdGFWaWV3LCBBcnJheUJ1ZmZlciwgV2Vha1NldCwgdHlwZWQgYXJyYXlzXG4gIC8vIG5vdGFibHksIHRoaXMgaW5jbHVkZXMgXCJib3hlZFwiIHByaW1pdGl2ZXMgY3JlYXRlZCBieSBuZXcgQm9vbGVhbihmYWxzZSksIG5ldyBTdHJpbmcoJ3ZhbHVlJyksIFN5bWJvbCgnd2hhdGV2ZXInKSwgZXRjXG4gIC8vIFR5cGUgdGFncyBvZiBvYmplY3RzIHNob3VsZCBiZSB0aGUgc2FtZVxuXG5cbiAgdmFyIGFjdHVhbFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhY3R1YWwpO1xuICB2YXIgZXhwZWN0ZWRUYWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpO1xuXG4gIGlmIChhY3R1YWxUYWcgIT09IGV4cGVjdGVkVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFtbUHJvdG90eXBlXV0gb2Ygb2JqZWN0cyBhcmUgY29tcGFyZWQgdXNpbmcgdGhlIFN0cmljdCBFcXVhbGl0eSBDb21wYXJpc29uLlxuXG5cbiAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgLy8gZG9uJ3QgY2hlY2sgcHJvdG90eXBlIHdoZW4gZG9pbmcgXCJsb29zZVwiXG4gICAgdmFyIGFjdHVhbFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhY3R1YWwpO1xuICAgIHZhciBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihleHBlY3RlZCk7XG5cbiAgICBpZiAoYWN0dWFsUHJvdG90eXBlICE9PSBleHBlY3RlZFByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLk9iamVjdDtcblxuICBpZiAodXRpbC50eXBlcy5pc1JlZ2V4cChhY3R1YWwpKSB7XG4gICAgLy8gUmVnRXhwIHNvdXJjZSBhbmQgZmxhZ3Mgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzUmVnZXhwKGV4cGVjdGVkKSB8fCBhY3R1YWwuZmxhZ3MgIT09IGV4cGVjdGVkLmZsYWdzIHx8IGFjdHVhbC5zb3VyY2UgIT09IGV4cGVjdGVkLnNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0RhdGUoYWN0dWFsKSkge1xuICAgIC8vIERhdGUncyB1bmRlcmx5aW5nIHRpbWUgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzRGF0ZShleHBlY3RlZCkgfHwgYWN0dWFsLmdldFRpbWUoKSAhPT0gZXhwZWN0ZWQuZ2V0VGltZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIEVycm9yJ3MgbmFtZSBhbmQgbWVzc2FnZSBtdXN0IG1hdGNoXG4gICAgaWYgKCEoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikgfHwgYWN0dWFsLm5hbWUgIT09IGV4cGVjdGVkLm5hbWUgfHwgYWN0dWFsLm1lc3NhZ2UgIT09IGV4cGVjdGVkLm1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWN0dWFsKSkge1xuICAgIC8vIGlmIGFycmF5IGxlbmd0aHMgZGlmZmVyLCBxdWljayBmYWlsXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSB8fCBhY3R1YWwubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShhY3R1YWwpKSB7XG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVjayB0aGF0IHRoZXkncmUgdGhlIHNhbWUgdHlwZSBvZiB3cmFwcGVkIHByaW1pdGl2ZSBhbmQgdGhlbiBjYWxsIHRoZSByZWxldmFudCB2YWx1ZU9mKCkgZm9yIHRoYXQgdHlwZSB0byBjb21wYXJlIHRoZW0hXG5cblxuICAgIGlmICh1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzTnVtYmVyT2JqZWN0KGV4cGVjdGVkKSB8fCAhT2JqZWN0LmlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3RyaW5nT2JqZWN0KGV4cGVjdGVkKSB8fCBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzQm9vbGVhbk9iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc0Jvb2xlYW5PYmplY3QoZXhwZWN0ZWQpIHx8IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGSVhNRTogVW5jb21tZW50IHdoZW4gd2Ugc3VwcG9ydCBCaWdJbnQgY3Jvc3MtcGxhdGZvcm0hXG4gICAgICAvLyB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoYWN0dWFsKVxuICAgICAgLy8gXHQmJiAoIXV0aWwudHlwZXMuaXNCaWdJbnRPYmplY3QoZXhwZWN0ZWQpXG4gICAgICAvLyBcdFx0fHwgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSAhPT0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgLy8gXHRyZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzU3ltYm9sT2JqZWN0KGV4cGVjdGVkKSB8fCBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzU2V0KGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNTZXQoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5TZXQ7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzTWFwKGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNNYXAoZXhwZWN0ZWQpIHx8IGFjdHVhbC5zaXplICE9PSBleHBlY3RlZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5NYXA7IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSAvLyBOb3cgaXRlcmF0ZSBvdmVyIHByb3BlcnRpZXMgYW5kIGNvbXBhcmUgdGhlbSFcblxuXG4gIHZhciBhY3R1YWxLZXlzID0gT2JqZWN0LmtleXMoYWN0dWFsKTsgLy8gZm9yIGFuIGFycmF5LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBpbmRpY2VzIHRoYXQgaGF2ZSB2YWx1ZXNcblxuICB2YXIgZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBhbmQgaXQganVzdCBtYWdpY2FsbHkgd29ya3NcbiAgLy8gTXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcblxuICBpZiAoYWN0dWFsS2V5cy5sZW5ndGggIT09IGV4cGVjdGVkS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQXJlIHRoZXkgdGhlIHNhbWUga2V5cz8gSWYgb25lIGlzIG1pc3NpbmcsIHRoZW4gbm8sIGZhaWwgcmlnaHQgYXdheVxuXG5cbiAgaWYgKCFhY3R1YWxLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cGVjdGVkLCBrZXkpO1xuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBEb24ndCBjaGVjayBvd24gc3ltYm9scyB3aGVuIGRvaW5nIFwibG9vc2VcIlxuXG5cbiAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgdmFyIGFjdHVhbFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGFjdHVhbCk7XG4gICAgdmFyIGV4cGVjdGVkU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXhwZWN0ZWQpOyAvLyBNdXN0IGhhdmUgc2FtZSBudW1iZXIgb2Ygc3ltYm9sc1xuXG4gICAgaWYgKGFjdHVhbFN5bWJvbHMubGVuZ3RoICE9PSBleHBlY3RlZFN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbFN5bWJvbHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSGF2ZSB0byBmaWx0ZXIgdGhlbSBkb3duIHRvIGVudW1lcmFibGUgc3ltYm9scyFcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I3ID0gYWN0dWFsU3ltYm9sc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDcudmFsdWU7XG4gICAgICAgICAgdmFyIGFjdHVhbElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChhY3R1YWwsIGtleSk7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGV4cGVjdGVkLCBrZXkpO1xuXG4gICAgICAgICAgaWYgKGFjdHVhbElzRW51bWVyYWJsZSAhPT0gZXhwZWN0ZWRJc0VudW1lcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdGhleSBkaWZmZXIgb24gd2hldGVociBzeW1ib2wgaXMgZW51bWVyYWJsZSwgZmFpbCFcbiAgICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbElzRW51bWVyYWJsZSkge1xuICAgICAgICAgICAgLy8gaXQncyBlbnVtZXJhYmxlLCBhZGQgdG8ga2V5cyB0byBjaGVja1xuICAgICAgICAgICAgYWN0dWFsS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICBleHBlY3RlZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yNyA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yNyA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyAmJiBfaXRlcmF0b3I3LnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMhXG4gIC8vIFJlY29yZCBtYXAgZnJvbSBvYmplY3RzIHRvIGRlcHRoIGluIHRoZSBoaWVyYXJjaHlcblxuXG4gIGlmIChyZWZlcmVuY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICByZWZlcmVuY2VzID0ge1xuICAgICAgYWN0dWFsOiBuZXcgTWFwKCksXG4gICAgICBleHBlY3RlZDogbmV3IE1hcCgpLFxuICAgICAgZGVwdGg6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIHRoZXNlIG9iamVjdHMuXG4gICAgLy8gaWYgc28sIG1ha2Ugc3VyZSB0aGV5IHJlZmVyIHRvIHNhbWUgZGVwdGggaW4gb2JqZWN0IGhpZXJhcmNoeVxuICAgIHZhciBtZW1vaXplZEFjdHVhbCA9IHJlZmVyZW5jZXMuYWN0dWFsLmdldChhY3R1YWwpO1xuXG4gICAgaWYgKG1lbW9pemVkQWN0dWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBtZW1vaXplZEV4cGVjdGVkID0gcmVmZXJlbmNlcy5leHBlY3RlZC5nZXQoZXhwZWN0ZWQpO1xuXG4gICAgICBpZiAobWVtb2l6ZWRFeHBlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtZW1vaXplZEFjdHVhbCA9PT0gbWVtb2l6ZWRFeHBlY3RlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWZlcmVuY2VzLmRlcHRoKys7XG4gIH0gLy8gc3RvcmUgdGhlIG9iamVjdCAtPiBkZXB0aCBtYXBwaW5nXG5cblxuICByZWZlcmVuY2VzLmFjdHVhbC5zZXQoYWN0dWFsLCByZWZlcmVuY2VzLmRlcHRoKTtcbiAgcmVmZXJlbmNlcy5leHBlY3RlZC5zZXQoZXhwZWN0ZWQsIHJlZmVyZW5jZXMuZGVwdGgpOyAvLyBXaGVuIGNvbXBhcmluZyBNYXBzL1NldHMsIGNvbXBhcmUgZWxlbWVudHMgYmVmb3JlIGN1c3RvbSBwcm9wZXJ0aWVzXG5cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG5cbiAgaWYgKGNvbXBhcmlzb24gPT09IENPTVBBUkVfVFlQRS5TZXQpIHtcbiAgICByZXN1bHQgPSBjb21wYXJlU2V0cyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKTtcbiAgfSBlbHNlIGlmIChjb21wYXJpc29uID09PSBDT01QQVJFX1RZUEUuTWFwKSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZU1hcHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcyk7XG4gIH1cblxuICBpZiAocmVzdWx0KSB7XG4gICAgLy8gTm93IGxvb3Agb3ZlciBrZXlzIGFuZCBjb21wYXJlIHRoZW0gdG8gZWFjaCBvdGhlciFcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hY3R1YWxLZXlzID0gYWN0dWFsS2V5czsgX2kgPCBfYWN0dWFsS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gX2FjdHVhbEtleXNbX2ldO1xuXG4gICAgICBpZiAoIWRlZXBFcXVhbChhY3R1YWxbX2tleV0sIGV4cGVjdGVkW19rZXldLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHdpcGUgdGhlIG9iamVjdCB0byBkZXB0aCBtYXBwaW5nIGZvciB0aGVzZSBvYmplY3RzIG5vd1xuXG5cbiAgcmVmZXJlbmNlcy5hY3R1YWwuZGVsZXRlKGFjdHVhbCk7XG4gIHJlZmVyZW5jZXMuZXhwZWN0ZWQuZGVsZXRlKGV4cGVjdGVkKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuU3RyaWN0KSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuU3RyaWN0KSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIWRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBTVFJJQ1RORVNTLkxvb3NlKSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuTG9vc2UpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnRmFpbGVkJztcbiAgcmV0dXJuIHRocm93RXJyb3Ioe1xuICAgIG1lc3NhZ2VcbiAgfSk7XG59O1xuXG52YXIgTk9fRVhDRVBUSU9OID0ge307XG5cbmZ1bmN0aW9uIGV4ZWN1dGUoZm4pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZuLCAnZm4nLCAnRnVuY3Rpb24nKTtcblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT047XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UoZm4pIHtcbiAgcmV0dXJuIHV0aWwudHlwZXMuaXNQcm9taXNlKGZuKSB8fCBmbiAmJiB0eXBlb2YgZm4gPT09ICdvYmplY3QnICYmIHR5cGVvZiBmbi50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlUHJvbWlzZShfeCkge1xuICByZXR1cm4gX2V4ZWN1dGVQcm9taXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9leGVjdXRlUHJvbWlzZSgpIHtcbiAgX2V4ZWN1dGVQcm9taXNlID0gX2FzeW5jVG9HZW5lcmF0b3IoXG4gIC8qI19fUFVSRV9fKi9cbiAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoZm4pIHtcbiAgICB2YXIgcHJvbWlzZSwgZm5UeXBlO1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBmblR5cGUgPSB0eXBlb2YgZm47XG5cbiAgICAgICAgICAgIGlmICghKGZuVHlwZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvbWlzZSA9IGZuKCk7XG5cbiAgICAgICAgICAgIGlmIChpc1Byb21pc2VMaWtlKHByb21pc2UpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnN0YW5jZW9mIFByb21pc2UgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXFxcImZuXFxcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlb2YgcHJvbWlzZSkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UoZm4pKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcImZuXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24gb3IgUHJvbWlzZS4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoZm5UeXBlKSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBwcm9taXNlID0gZm47XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxMDtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTM7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDEwKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgTk9fRVhDRVBUSU9OKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgbnVsbCwgW1sxMCwgMTVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9leGVjdXRlUHJvbWlzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gKGZuLCBlcnJvciwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsID0gZXhlY3V0ZShmbik7XG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OKSB7XG4gICAgLy8gRklYTUU6IGFwcGVuZCBtZXNzYWdlIGlmIG5vdCBudWxsXG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG1lc3NhZ2U6ICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbi4nLFxuICAgICAgb3BlcmF0b3I6ICd0aHJvd3MnXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZXkgZGlkbid0IHNwZWNpZnkgaG93IHRvIHZhbGlkYXRlLCBzbyBqdXN0IHJvbGwgd2l0aCBpdFxuXG5cbiAgaWYgKCFlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghY2hlY2tFcnJvcihhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSkge1xuICAgIHRocm93IGFjdHVhbDsgLy8gdGhyb3cgdGhlIEVycm9yIGl0IGRpZCBnZW5lcmF0ZVxuICB9XG59O1xuXG5hc3NlcnQucmVqZWN0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoXG4gIC8qI19fUFVSRV9fKi9cbiAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhc3luY0ZuLCBlcnJvciwgbWVzc2FnZSkge1xuICAgIHZhciBhY3R1YWw7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVByb21pc2UoYXN5bmNGbik7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBhY3R1YWwgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRTogYXBwZW5kIG1lc3NhZ2UgaWYgbm90IG51bGxcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe1xuICAgICAgICAgICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24uJyxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6ICdyZWplY3RzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmIChjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGFjdHVhbDtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChfeDIsIF94MywgX3g0KSB7XG4gICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbCA9IGV4ZWN1dGUoZm4pOyAvLyBubyBFcnJvciwganVzdCByZXR1cm5cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3QgcmUtdGhyb3dcblxuXG4gIGlmICghZXJyb3IpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH0gLy8gSWYgZXJyb3IgbWF0Y2hlcyBleHBlY3RlZCwgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcblxuXG4gIGlmIChjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogJ2RvZXNOb3RUaHJvdycsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBleGNlcHRpb25cIi5jb25jYXQobWVzc2FnZSA/ICc6ICcgKyBtZXNzYWdlIDogJy4nKVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSAvLyBkb2Vzbid0IG1hdGNoLCByZS10aHJvd1xuXG5cbiAgdGhyb3cgYWN0dWFsO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvcihcbiAgLyojX19QVVJFX18qL1xuICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihmbiwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgICB2YXIgYWN0dWFsO1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVByb21pc2UoZm4pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgYWN0dWFsID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBhY3R1YWw7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAoIWNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvcikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93RXJyb3Ioe1xuICAgICAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkb2VzTm90VGhyb3cnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBleGNlcHRpb25cIi5jb25jYXQobWVzc2FnZSA/ICc6ICcgKyBtZXNzYWdlIDogJy4nKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICB0aHJvdyBhY3R1YWw7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChfeDUsIF94NiwgX3g3KSB7XG4gICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IGFjdHVhbCB0aGUgYWN0dWFsIEVycm9yIGdlbmVyYXRlZCBieSB0aGUgd3JhcHBlZCBmdW5jdGlvbi9ibG9ja1xuICogQHBhcmFtIHtvYmplY3R8UmVnRXhwfEZ1bmN0aW9ufEVycm9yfENsYXNzfSBleHBlY3RlZCBUaGUgdmFsdWUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBFcnJvclxuICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXSBjdXN0b20gbWVzc2FnZSB0byBhcHBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBFcnJvciBtYXRjaGVzIHRoZSBleHBlY3RlZCB2YWx1ZS9vYmplY3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrRXJyb3IoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICAvLyBXaGF0IHdlIGRvIGhlcmUgZGVwZW5kcyBvbiB3aGF0IGBleHBlY3RlZGAgaXM6XG4gIC8vIGZ1bmN0aW9uIC0gY2FsbCBpdCB0byB2YWxpZGF0ZVxuICAvLyBvYmplY3QgLSB0ZXN0IHByb3BlcnRpZXMgYWdhaW5zdCBhY3R1YWxcbiAgLy8gUmVnZXhwIC0gdGVzdCBhZ2FpbnN0IGFjdHVhbC50b1N0cmluZygpXG4gIC8vIEVycm9yIHR5cGUgLSBjaGVjayB0eXBlIG1hdGNoZXNcbiAgLy8gRXJyb3IgaW5zdGFuY2UgLSBjb21wYXJlIHByb3BlcnRpZXNcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodXRpbC50eXBlcy5pc1JlZ2V4cChleHBlY3RlZCkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGRvZXMgdGhlIGVycm9yIG1hdGNoIHRoZSBSZWdFeHAgZXhwcmVzc2lvbj8gaWYgc28sIHBhc3NcbiAgICB9IC8vIFRlc3QgcHJvcGVydGllcyAoYGV4cGVjdGVkYCBpcyBlaXRoZXIgYSBnZW5lcmljIE9iamVjdCBvciBhbiBFcnJvciBpbnN0YW5jZSlcblxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIElmIHdlJ3JlIHRlc3RpbmcgYWdhaW5zdCBhbiBpbnN0YW5jZSBvZiBhbiBFcnJvciwgd2UgbmVlZCB0byBoYWNrIGluIG5hbWUvbWVzc2FnZSBwcm9wZXJ0aWVzLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMudW5zaGlmdCgnbmFtZScsICdtZXNzYWdlJyk7IC8vIHdlIHdhbnQgdG8gY29tcGFyZSBuYW1lIGFuZCBtZXNzYWdlLCBidXQgdGhleSdyZSBub3Qgc2V0IGFzIGVudW1lcmFibGUgb24gRXJyb3JcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfa2V5cyA9IGtleXM7IF9pMiA8IF9rZXlzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBrZXkgPSBfa2V5c1tfaTJdO1xuXG4gICAgICBpZiAoIWRlZXBFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIC8vIGdlbmVyYXRlIGEgbWVhbmluZ2Z1bCBtZXNzYWdlISBDaGVhdCBieSB0cmVhdGluZyBsaWtlIGVxdWFsaXR5IGNoZWNrIG9mIHZhbHVlc1xuICAgICAgICAgIC8vIHRoZW4gc3RlYWwgdGhlIG1lc3NhZ2UgaXQgZ2VuZXJhdGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe1xuICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFtrZXldLFxuICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRba2V5XSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKHtcbiAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gVGhleSBhbGwgbWF0Y2hlZCwgcGFzcyFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBpZiBgZXhwZWN0ZWRgIGlzIGEgXCJ0eXBlXCIgYW5kIGFjdHVhbCBpcyBhbiBpbnN0YW5jZSBvZiB0aGF0IHR5cGUsIHRoZW4gcGFzc1xuICAgIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT0gbnVsbCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJZiBgZXhwZWN0ZWRgIGlzIGEgc3ViY2xhc3Mgb2YgRXJyb3IgYnV0IGBhY3R1YWxgIHdhc24ndCBhbiBpbnN0YW5jZSBvZiBpdCAoYWJvdmUpLCBmYWlsXG5cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChFcnJvciwgZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBvaywgbGV0J3MgYXNzdW1lIHdoYXQncyBsZWZ0IGlzIHRoYXQgYGV4cGVjdGVkYCB3YXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLFxuICAgIC8vIHNvIGNhbGwgaXQgd2l0aCBlbXB0eSBgdGhpc2AgYW5kIHNpbmdsZSBhcmd1bWVudCBvZiB0aGUgYWN0dWFsIGVycm9yIHdlIHJlY2VpdmVkXG5cblxuICAgIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbDogdmFsdWUsXG4gICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgbWVzc2FnZTogXCJpZkVycm9yIGdvdCB1bndhbnRlZCBleGNlcHRpb246IFwiLmNvbmNhdCh2YWx1ZSksXG4gICAgb3BlcmF0b3I6ICdpZkVycm9yJ1xuICB9KTtcbn07IC8vIENyZWF0ZSBcInN0cmljdFwiIGNvcHkgd2hpY2ggb3ZlcnJpZGVzIFwibG9vc2VcIiBtZXRob2RzIHRvIGNhbGwgc3RyaWN0IGVxdWl2YWxlbnRzXG5cblxuYXNzZXJ0LnN0cmljdCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICByZXR1cm4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTtcbn07IC8vIFwiQ29weVwiIG1ldGhvZHMgZnJvbSBhc3NlcnQgdG8gYXNzZXJ0LnN0cmljdCFcblxuXG5PYmplY3QuYXNzaWduKGFzc2VydC5zdHJpY3QsIGFzc2VydCk7IC8vIE92ZXJyaWRlIHRoZSBcImxvb3NlXCIgbWV0aG9kcyB0byBwb2ludCB0byB0aGUgc3RyaWN0IG9uZXNcblxuYXNzZXJ0LnN0cmljdC5kZWVwRXF1YWwgPSBhc3NlcnQuZGVlcFN0cmljdEVxdWFsO1xuYXNzZXJ0LnN0cmljdC5ub3REZWVwRXF1YWwgPSBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsO1xuYXNzZXJ0LnN0cmljdC5lcXVhbCA9IGFzc2VydC5zdHJpY3RFcXVhbDtcbmFzc2VydC5zdHJpY3Qubm90RXF1YWwgPSBhc3NlcnQubm90U3RyaWN0RXF1YWw7IC8vIGhhbmcgc3RyaWN0IG9mZiBpdHNlbGZcblxuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG52YXIga05vZGVNb2R1bGVzUkUgPSAvXiguKilbXFxcXC9dbm9kZV9tb2R1bGVzW1xcXFwvXS87XG52YXIgZ2V0U3RydWN0dXJlZFN0YWNrO1xuXG52YXIgU3RhY2tUcmFjZUVycm9yID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFN0YWNrVHJhY2VFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBTdGFja1RyYWNlRXJyb3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YWNrVHJhY2VFcnJvcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFN0YWNrVHJhY2VFcnJvcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gU3RhY2tUcmFjZUVycm9yO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cblN0YWNrVHJhY2VFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIChlcnIsIHRyYWNlKSB7XG4gIHJldHVybiB0cmFjZTtcbn07XG5cblN0YWNrVHJhY2VFcnJvci5zdGFja1RyYWNlTGltaXQgPSBJbmZpbml0eTtcbmZ1bmN0aW9uIGlzSW5zaWRlTm9kZU1vZHVsZXMoKSB7XG4gIGlmIChnZXRTdHJ1Y3R1cmVkU3RhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIGdldFN0cnVjdHVyZWRTdGFjayA9IGZ1bmN0aW9uIGdldFN0cnVjdHVyZWRTdGFjaygpIHtcbiAgICAgIHJldHVybiBuZXcgU3RhY2tUcmFjZUVycm9yKCkuc3RhY2s7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBzdGFjayA9IGdldFN0cnVjdHVyZWRTdGFjaygpOyAvLyBzdGFjayBpcyBvbmx5IGFuIGFycmF5IG9uIHY4LCB0cnkgdG8gY29udmVydCBtYW51YWxseSBpZiBzdHJpbmdcblxuICBpZiAodHlwZW9mIHN0YWNrID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzdGFja0ZyYW1lcyA9IFtdO1xuICAgIHZhciBsaW5lcyA9IHN0YWNrLnNwbGl0KC9cXG4vKTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGxpbmVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGluZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgbGluZUluZm8gPSBsaW5lLm1hdGNoKC8oLiopQCguKik6KFxcZCspOihcXGQrKS8pO1xuXG4gICAgICAgIGlmIChsaW5lSW5mbykge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBsaW5lSW5mb1syXS5yZXBsYWNlKCdmaWxlOi8vJywgJycpO1xuICAgICAgICAgICAgc3RhY2tGcmFtZXMucHVzaCh7XG4gICAgICAgICAgICAgIGdldEZpbGVOYW1lOiBmdW5jdGlvbiBnZXRGaWxlTmFtZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrID0gc3RhY2tGcmFtZXM7XG4gIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBzdGFjayBmcmFtZXMgYW5kIGxvb2sgZm9yIHRoZSBmaXJzdCBvbmUgbm90IGNvbWluZ1xuICAvLyBmcm9tIGluc2lkZSBOb2RlLmpzIGl0c2VsZjpcblxuXG4gIGlmIChBcnJheS5pc0FycmF5KHN0YWNrKSkge1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHN0YWNrW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZnJhbWUuZ2V0RmlsZU5hbWUoKTsgLy8gSWYgYSBmaWxlbmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIC8gb3IgY29udGFpbiBcXCxcbiAgICAgICAgLy8gaXQncyBsaWtlbHkgZnJvbSBOb2RlLmpzIGNvcmUuXG5cbiAgICAgICAgaWYgKCEvXlxcL3xcXFxcLy50ZXN0KGZpbGVuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtOb2RlTW9kdWxlc1JFLnRlc3QoZmlsZW5hbWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFRJX0NPREVDX01BUCA9IG5ldyBNYXAoKTtcblRJX0NPREVDX01BUC5zZXQoJ3V0Zi04JywgVGkuQ29kZWMuQ0hBUlNFVF9VVEY4KTtcblRJX0NPREVDX01BUC5zZXQoJ3V0ZjgnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjgpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmLTE2bGUnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmMTZsZScsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCd1Y3MyJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ3Vjcy0yJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ2xhdGluMScsIFRpLkNvZGVjLkNIQVJTRVRfSVNPX0xBVElOXzEpO1xuVElfQ09ERUNfTUFQLnNldCgnYmluYXJ5JywgVGkuQ29kZWMuQ0hBUlNFVF9JU09fTEFUSU5fMSk7XG5USV9DT0RFQ19NQVAuc2V0KCdhc2NpaScsIFRpLkNvZGVjLkNIQVJTRVRfQVNDSUkpOyAvLyBXZSBoYXZlIG5vIGVxdWl2YWxlbnRzIG9mIGJhc2U2NCBvciBoZXgsIHNvIHdlIGNvbnZlcnQgdGhlbSBpbnRlcm5hbGx5IGhlcmVcblxudmFyIFZBTElEX0VOQ09ESU5HUyA9IFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnbGF0aW4xJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJ107IC8vIFVzZWQgdG8gY2hlYXQgZm9yIHJlYWQvd3JpdGVzIG9mIGRvdWJsZXNcblxudmFyIGRvdWJsZUFycmF5ID0gbmV3IEZsb2F0NjRBcnJheSgxKTtcbnZhciB1aW50OERvdWJsZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZG91YmxlQXJyYXkuYnVmZmVyKTsgLy8gVXNlZCB0byBjaGVhdCB0byByZWFkL3dyaXRlIGZsb2F0c1xuXG52YXIgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG52YXIgdWludDhGbG9hdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmxvYXRBcnJheS5idWZmZXIpO1xuXG52YXIgQnVmZmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyLlxuICAgKlxuICAgKiBQcmltYXJpbHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoaXMgbW9kdWxlIHRvZ2V0aGVyIHdpdGggYG5ld0J1ZmZlcmAgdG9cbiAgICogY3JlYXRlIGEgbmV3IEJ1ZmZlciBpbnN0YW5jZSB3cmFwcGluZyBhIFRpLkJ1ZmZlci5cbiAgICpcbiAgICogQWxzbyBzdXBwb3J0cyB0aGUgZGVwcmVjYXRlZCBCdWZmZXIoKSBjb25zdHJ1Y3RvcnMgd2hpY2ggYXJlIHNhZmVcbiAgICogdG8gdXNlIG91dHNpZGUgb2YgdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW50ZWdlcltdfEJ1ZmZlcnxpbnRlZ2VyfHN0cmluZ3xUaS5CdWZmZXJ9IGFyZ1xuICAgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBlbmNvZGluZ09yT2Zmc2V0XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoXG4gICAqL1xuICBmdW5jdGlvbiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyKTtcblxuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuYXBpTmFtZSAhPT0gJ1RpLkJ1ZmZlcicpIHtcbiAgICAgIHNob3dGbGFnZ2VkRGVwcmVjYXRpb24oKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJzdHJpbmdcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBcXFwic3RyaW5nXFxcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFyZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhhcmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciB0aUJ1ZmZlciA9IGFyZztcbiAgICB2YXIgc3RhcnQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIHRoaXMuX3RpQnVmZmVyID0gdGlCdWZmZXI7XG5cbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIHRoaXMuYnl0ZU9mZnNldCA9IHN0YXJ0O1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHRpQnVmZmVyLmxlbmd0aCAtIHRoaXMuYnl0ZU9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5faXNCdWZmZXIgPSB0cnVlOyAvLyBGSVhNRTogU3VwcG9ydCAuYnVmZmVyIHByb3BlcnR5IHRoYXQgaG9sZHMgYW4gQXJyYXlCdWZmZXIhXG4gIH1cbiAgLyoqXG4gICAqIDAgaXMgcmV0dXJuZWQgaWYgdGFyZ2V0IGlzIHRoZSBzYW1lIGFzIGJ1ZlxuICAgKiAxIGlzIHJldHVybmVkIGlmIHRhcmdldCBzaG91bGQgY29tZSBiZWZvcmUgYnVmIHdoZW4gc29ydGVkLlxuICAgKiAtMSBpcyByZXR1cm5lZCBpZiB0YXJnZXQgc2hvdWxkIGNvbWUgYWZ0ZXIgYnVmIHdoZW4gc29ydGVkLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0IEJ1ZmZlciB0byBjb21wYXJlIGFnYWluc3RcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0U3RhcnQ9MF0gaW5kZXggdG8gc3RhcnQgaW4gdGFyZ2V0XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldEVuZD10YXJnZXQubGVuZ3RoXSBpbmRleCB0byBlbmQgaW4gdGFyZ2V0XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZVN0YXJ0PTBdIGluZGV4IHRvIHN0YXJ0IGluIHRoaXMgQnVmZmVyXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZUVuZD10aGlzLmxlbmd0aF0gaW5kZXggdG8gZW5kIGluIHRoaXMgQnVmZmVyXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXIsIFt7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZSh0YXJnZXQsIHRhcmdldFN0YXJ0LCB0YXJnZXRFbmQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwidGFyZ2V0XFxcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYnVmMSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXRTdGFydCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldEVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhcmdldEVuZCA9IHRhcmdldC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzb3VyY2VFbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH0gLy8gRVJSX09VVF9PRl9SQU5HRSBpcyB0aHJvd24gaWYgdGFyZ2V0U3RhcnQgPCAwLCBzb3VyY2VTdGFydCA8IDAsIHRhcmdldEVuZCA+IHRhcmdldC5ieXRlTGVuZ3RoLCBvciBzb3VyY2VFbmQgPiBzb3VyY2UuYnl0ZUxlbmd0aFxuXG5cbiAgICAgIGlmICh0YXJnZXRTdGFydCA8IDAgfHwgc291cmNlU3RhcnQgPCAwIHx8IHRhcmdldEVuZCA+IHRhcmdldC5sZW5ndGggfHwgc291cmNlRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpOyAvLyBGSVhNRTogc2V0IFwiY29kZVwiIHRvIEVSUl9JTkRFWF9PVVRfT0ZfUkFOR0VcbiAgICAgIH0gLy8gVXNlIHNsaWNlcyB0byBtYWtlIHRoZSBsb29wIGVhc2llclxuXG5cbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNsaWNlKHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuICAgICAgdmFyIHNvdXJjZUxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICB2YXIgZGVzdCA9IHRhcmdldC5zbGljZSh0YXJnZXRTdGFydCwgdGFyZ2V0RW5kKTtcbiAgICAgIHZhciBkZXN0TGVuZ3RoID0gZGVzdC5sZW5ndGg7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc291cmNlTGVuZ3RoLCBkZXN0TGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSBnZXRBZGp1c3RlZEluZGV4KGRlc3QsIGkpO1xuICAgICAgICB2YXIgc291cmNlVmFsdWUgPSBnZXRBZGp1c3RlZEluZGV4KHNvdXJjZSwgaSk7XG5cbiAgICAgICAgaWYgKHRhcmdldFZhbHVlICE9PSBzb3VyY2VWYWx1ZSkge1xuICAgICAgICAgIC8vIE5vIG1hdGNoISBSZXR1cm4gMSBvciAtMSBiYXNlZCBvbiB3aGF0IGlzIGdyZWF0ZXIhXG4gICAgICAgICAgaWYgKHNvdXJjZVZhbHVlIDwgdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBzb3J0IGJhc2VkIG9uIGxlbmd0aCFcblxuXG4gICAgICBpZiAoc291cmNlTGVuZ3RoIDwgZGVzdExlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VMZW5ndGggPiBkZXN0TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGZyb20gdGhpcyB0byB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0IGRlc3RpbmF0aW9uIHdlJ3JlIGNvcHlpbmcgaW50b1xuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldFN0YXJ0PTBdIHN0YXJ0IGluZGV4IHRvIGNvcHkgaW50byBpbiBkZXN0aW5hdGlvbiBCdWZmZXJcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VTdGFydD0wXSBzdGFydCBpbmRleCB0byBjb3B5IGZyb20gd2l0aGluIGB0aGlzYFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZUVuZD10aGlzLmxlbmd0aF0gZW5kIGluZGV4IHRvIGNvcHkgZnJvbSB3aXRoaW4gYHRoaXNgXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9IG51bWJlciBvZiBieXRlcyBjb3BpZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weSh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzb3VyY2VTdGFydCwgc291cmNlRW5kKSB7XG4gICAgICBpZiAodGFyZ2V0U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXRTdGFydCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNvdXJjZUVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlU3RhcnQgPT09IHNvdXJjZUVuZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IC8vIFRPRE86IGNoZWNrIGZvciBvdXQgb2YgYm91bmRzP1xuXG5cbiAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VFbmQgLSBzb3VyY2VTdGFydDsgLy8gQ2FwIGxlbmd0aCB0byByZW1haW5pbmcgYnl0ZXMgaW4gdGFyZ2V0IVxuXG4gICAgICB2YXIgcmVtYWluaW5nID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0O1xuXG4gICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgIH0gLy8gVE9ETzogaGFuZGxlIG92ZXJsYXAgd2hlbiB0YXJnZXQgPT09IHRoaXMhXG4gICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIHRha2UgdGFyZ2V0IG9yIHRoaXMuYnl0ZU9mZnNldCBpbnRvIGFjY291bnQgaGVyZT9cblxuXG4gICAgICB0YXJnZXQuX3RpQnVmZmVyLmNvcHkodGhpcy5fdGlCdWZmZXIsIHRhcmdldFN0YXJ0LCBzb3VyY2VTdGFydCwgbGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpdGVyYXRvciBvZiBbaW5kZXgsIGJ5dGVdIHBhaXJzIGZyb20gdGhlIGNvbnRlbnRzIG9mIGJ1Zi5cbiAgICAgKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICB2YXIgYnVmZmVyID0gdGhpcztcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIGVudHJ5SXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IFtuZXh0SW5kZXgsIGdldEFkanVzdGVkSW5kZXgoYnVmZmVyLCBuZXh0SW5kZXgpXSxcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBlbnRyeUl0ZXJhdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKG90aGVyQnVmZmVyKSB7XG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdGhlckJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3RoZXJCdWZmZXIgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXJCdWZmZXIpID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VUludDhBcnJheXxpbnRlZ2VyfSB2YWx1ZSBUaGUgdmFsdWUgd2l0aCB3aGljaCB0byBmaWxsIGBidWZgLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gZmlsbCBgYnVmYFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZF0gV2hlcmUgdG8gc3RvcCBmaWxsaW5nIGJ1ZiAobm90IGluY2x1c2l2ZSkuIGBidWYubGVuZ3RoYCBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBlbmNvZGluZyBmb3IgYHZhbHVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgICAgIHZhciBvZmZzZXRUeXBlID0gdHlwZW9mIG9mZnNldDtcblxuICAgICAgaWYgKG9mZnNldFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHZhbHVlIHN1cHBsaWVkXG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gdmFsdWUsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gdmFsdWUsIG9mZnNldCwgZW5jb2Rpbmcgc3VwcGxpZWRcbiAgICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgYnVmVG9GaWxsV2l0aCA9IEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIHZhciBmaWxsQnVmTGVuZ3RoID0gYnVmVG9GaWxsV2l0aC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHZhbGlkIGZpbGwgZGF0YScpO1xuICAgICAgICB9IC8vIElmIHRoZSBidWZmZXIgbGVuZ3RoID09PSAxLCB3ZSBjYW4ganVzdCBkbyB0aGlzLl90aUJ1ZmZlci5maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCk7XG5cblxuICAgICAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwoYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbMF0sIG9mZnNldCwgZW5kKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IC8vIG11bHRpcGxlIGJ5dGUgZmlsbCFcblxuXG4gICAgICAgIHZhciBsZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlIChvbiBgdGhpc2AsIG5vdCBvbiB0aGUgYnVmZmVyIHdlIGp1c3QgY3JlYXRlZCk/XG4gICAgICAgICAgdmFyIGZpbGxDaGFyID0gYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbaSAlIGZpbGxCdWZMZW5ndGhdO1xuICAgICAgICAgIHRoaXMuX3RpQnVmZmVyW2kgKyBvZmZzZXRdID0gZmlsbENoYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gLy8gaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyIChvciBhIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGJ5dGUpIHdlIGNhbiB1c2UgdGlCdWZmZXIuZmlsbCgpO1xuXG5cbiAgICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluY2x1ZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWx1ZSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfGludGVnZXJ9IHZhbHVlIFdoYXQgdG8gc2VhcmNoIGZvclxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2J5dGVPZmZzZXQ9MF0gV2hlcmUgdG8gYmVnaW4gc2VhcmNoaW5nIGluIGJ1Zi4gSWYgbmVnYXRpdmUsIHRoZW4gb2Zmc2V0IGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZW5kIG9mIGJ1ZlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBJZiB2YWx1ZSBpcyBhIHN0cmluZywgdGhpcyBpcyB0aGUgZW5jb2RpbmcgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RyaW5nIHRoYXQgd2lsbCBiZSBzZWFyY2hlZCBmb3IgaW4gYnVmXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9IFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB2YWx1ZSBpbiBidWYsIG9yIC0xIGlmIGJ1ZiBkb2VzIG5vdCBjb250YWluIHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5kZXhPZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGVtcHR5IGJ1ZmZlcj8gY2FuJ3QgZmluZCBhbnl0aGluZyFcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSAvLyBpZiBieXRlT2Zmc2V0IGlzIHVuZGVmaW5lZCwgbWFrZSBpdCAwXG5cblxuICAgICAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBieXRlT2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYSBzdHJpbmcsIHRoYXQncyBhY3R1YWxseSBlbmNvZGluZ1xuICAgICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgfSAvLyBpZiB3ZSBkb24ndCBoYXZlIGFuIGVuY29kaW5nIHlldCwgdXNlIHV0ZjhcblxuXG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgIH1cblxuICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBieXRlT2Zmc2V0ID0gdGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgICAgICAgIC8vIHN0aWxsIG5lZ2F0aXZlPyBzdGFydCBhdCAwXG4gICAgICAgICAgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7IC8vIGNhbid0IGZpbmQgcGFzdCBlbmQgb2YgYnVmZmVyIVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZSAmPSAweEZGOyAvLyBjbGFtcCB0byAyNTVcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsZXIgY2FzZSwgd2UgaGF2ZSBhIHNpbmdsZSBieXRlIHdlIG5lZWQgdG8gc2VhcmNoIGZvclxuICAgICAgICAvLyBzbyBqdXN0IGxvb3AgdGhyb3VnaCBhbmQgdHJ5IHRvIGZpbmQgaXRcblxuICAgICAgICByZXR1cm4gX2luZGV4T2YodGhpcywgdmFsdWUsIGJ5dGVPZmZzZXQpO1xuICAgICAgfSAvLyBjb2VyY2UgYSBzdHJpbmcgdG8gYSBCdWZmZXJcblxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICB9IC8vIHZhbHVlIGlzIG5vdyBhIEJ1ZmZlci4uLlxuXG5cbiAgICAgIHZhciBtYXRjaExlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgaWYgKG1hdGNoTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTsgLy8gbmV2ZXIgZmluZCBlbXB0eSB2YWx1ZSFcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHNpbXBsZSBjYXNlLCBtYXRjaCBvbmUgYnl0ZSFcbiAgICAgICAgcmV0dXJuIF9pbmRleE9mKHRoaXMsIHZhbHVlWzBdLCBieXRlT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGJ5dGVPZmZzZXQ7XG4gICAgICB2YXIgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICBpZiAobWF0Y2hMZW5ndGggPiB0aGlzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTsgLy8gY2FuJ3QgbWF0Y2ggaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoaXMgQnVmZmVyIVxuICAgICAgfSAvLyBGSVhNRTogQ2FuIHdlIHJld3JpdGUgdGhpcyBpbiBhIGxlc3MgZnVua3kgd2F5P1xuICAgICAgLy8gRklYTUU6IENhbiBzdG9wIGVhcmxpZXIgYmFzZWQgb24gbWF0Y2hMZW5ndGghXG5cblxuICAgICAgZmlyc3RNYXRjaDogd2hpbGUgKGN1cnJlbnRJbmRleCA8IHRoaXNMZW5ndGgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sYWJlbHNcbiAgICAgICAgLy8gbWF0Y2ggZmlyc3QgYnl0ZSFcbiAgICAgICAgdmFyIGZpcnN0Qnl0ZU1hdGNoID0gX2luZGV4T2YodGhpcywgdmFsdWVbMF0sIGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKGZpcnN0Qnl0ZU1hdGNoID09PSAtMSkge1xuICAgICAgICAgIC8vIGNvdWxkbid0IGV2ZW4gbWF0Y2ggdGhlIHZlcnkgZmlyc3QgYnl0ZSwgc28gbm8gbWF0Y2ggb3ZlcmFsbCFcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gLy8gb2ssIHdlIGZvdW5kIHRoZSBmaXJzdCBieXRlLCBub3cgd2UgbmVlZCB0byBzZWUgaWYgdGhlIG5leHQgY29uc2VjdXRpdmUgYnl0ZXMgbWF0Y2ghXG5cblxuICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IG1hdGNoTGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlTWF0Y2ggKyB4ID49IHRoaXNMZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGZpcnN0Qnl0ZU1hdGNoICsgMTsgLy8gbW92ZSBwYXN0IG91ciBmaXJzdCBtYXRjaFxuXG4gICAgICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzW2ZpcnN0Qnl0ZU1hdGNoICsgeF0gIT09IHZhbHVlW3hdKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgbWF0Y2ghXG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSBmaXJzdEJ5dGVNYXRjaCArIDE7IC8vIG1vdmUgcGFzdCBvdXIgZmlyc3QgbWF0Y2hcblxuICAgICAgICAgICAgY29udGludWUgZmlyc3RNYXRjaDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlyc3RCeXRlTWF0Y2g7IC8vIHRoZSByZXN0IG1hdGNoZWQsIGh1cnJheSFcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIHZhciBteUl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZXh0SW5kZXgsXG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gbXlJdGVyYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDhcbiAgICAgKiBAcmV0dXJucyB7ZG91YmxlfSBSZWFkcyBhIDY0LWJpdCBkb3VibGUgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZERvdWJsZUJFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWREb3VibGVCRSgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpOyAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0NjRBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gICAgICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0NjRBcnJheVxuICAgICAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbN10gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbNl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbNF0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHJldHVybiBkb3VibGVBcnJheVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDhcbiAgICAgKiBAcmV0dXJucyB7ZG91YmxlfSBSZWFkcyBhIDY0LWJpdCBkb3VibGUgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZERvdWJsZUxFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWREb3VibGVMRSgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpOyAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0NjRBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gICAgICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0NjRBcnJheVxuICAgICAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbNF0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbNl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RG91YmxlQXJyYXlbN10gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHJldHVybiBkb3VibGVBcnJheVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAgICAgKiBAcmV0dXJucyB7ZmxvYXR9IFJlYWRzIGEgMzItYml0IGZsb2F0IGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRGbG9hdEJFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKCkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgICAgIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQzMkFycmF5XG4gICAgICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcblxuICAgICAgdWludDhGbG9hdEFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gICAgICB1aW50OEZsb2F0QXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RmxvYXRBcnJheVsxXSA9IHRoaXNbb2Zmc2V0KytdO1xuICAgICAgdWludDhGbG9hdEFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAgICAgKiBAcmV0dXJucyB7ZmxvYXR9IFJlYWRzIGEgMzItYml0IGZsb2F0IGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRGbG9hdExFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRGbG9hdExFKCkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgICAgIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQzMkFycmF5XG4gICAgICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcblxuICAgICAgdWludDhGbG9hdEFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gICAgICB1aW50OEZsb2F0QXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgICAgIHVpbnQ4RmxvYXRBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICAgICAgdWludDhGbG9hdEFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gICAgICByZXR1cm4gZmxvYXRBcnJheVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDEuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSW50OCgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkSW50MTZCRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQpIHtcbiAgICAgIHZhciB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRJbnQxNkxFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRJbnQxNkxFKCkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDE2TEUob2Zmc2V0KTtcbiAgICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRJbnQzMkJFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRJbnQzMkJFKCkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRJbnQzMkxFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRJbnQzMkxFKCkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlcyBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCBhbmQgaW50ZXJwcmV0cyB0aGUgcmVzdWx0IGFzIGEgdHdvJ3MgY29tcGxlbWVudCBzaWduZWQgdmFsdWUuIFN1cHBvcnRzIHVwIHRvIDQ4IGJpdHMgb2YgYWNjdXJhY3kuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkSW50QkVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgdmFyIHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIGJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlcyBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCBhbmQgaW50ZXJwcmV0cyB0aGUgcmVzdWx0IGFzIGEgdHdvJ3MgY29tcGxlbWVudCBzaWduZWQgdmFsdWUuIFN1cHBvcnRzIHVwIHRvIDQ4IGJpdHMgb2YgYWNjdXJhY3kuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkSW50TEVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEludExFKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgdmFyIHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIGJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRVSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUludDgoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAxKTtcbiAgICAgIHJldHVybiB0aGlzW29mZnNldF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFVJbnQxNkJFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpOyAvLyBmaXJzdCBieXRlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBzZWNvbmQgYnl0ZVxuXG4gICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDggfCB0aGlzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRVSW50MTZMRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUludDE2TEUoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTsgLy8gZmlyc3QgYnl0ZSBPUidkIHdpdGggc2Vjb25kIGJ5dGUgc2hpZnRlZFxuXG4gICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWRVSW50MzJCRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUludDMyQkUoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICAgIHJldHVybiB0aGlzW29mZnNldF0gKiAweDEwMDAwMDAgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pOyAvLyByYXRoZXIgdGhhbiBzaGlmdGluZyBieSA8PCAyNCwgbXVsdGlwbHkgdGhlIGZpcnN0IGJ5dGUgYW5kIGFkZCBpdCBpbiBzbyB3ZSBkb24ndCByZXRhaW4gdGhlIFwic2lnbiBiaXRcIlxuICAgICAgLy8gKGJlY2F1c2UgYml0LXdpc2Ugb3BlcmF0b3JzIGFzc3VtZSBhIDMyLWJpdCBudW1iZXIpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFVJbnQzMkxFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICAgICAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDA7IC8vIHJhdGhlciB0aGFuIHNoaWZ0aW5nIGJ5IDw8IDI0LCBtdWx0aXBseSB0aGUgbGFzdCBieXRlIGFuZCBhZGQgaXQgaW4gc28gd2UgZG9uJ3QgcmV0YWluIHRoZSBcInNpZ24gYml0XCJcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFVJbnRCRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIHZhciBtdWx0aXBsaWVyID0gMTsgLy8gd2UgdXNlIGEgbXVsdGlwbGVyIGZvciBlYWNoIGJ5dGVcbiAgICAgIC8vIHdlJ3JlIGRvaW5nIHRoZSBzYW1lIGxvb3AgYXMgI3JlYWRVSW50TEUsIGp1c3QgYmFja3dhcmRzIVxuXG4gICAgICBmb3IgKHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc3VsdCArPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIGkpICogbXVsdGlwbGllcjtcbiAgICAgICAgbXVsdGlwbGllciAqPSAweDEwMDsgLy8gbW92ZSBtdWx0aXBsaWVyIHRvIG5leHQgYnl0ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZWFkVUludExFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgIH1cblxuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSAxOyAvLyB3ZSB1c2UgYSBtdWx0aXBsZXIgZm9yIGVhY2ggYnl0ZVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyBpKSAqIG11bHRpcGxpZXI7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gMHgxMDA7IC8vIG1vdmUgbXVsdGlwbGllciB0byBuZXh0IGJ5dGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZD10aGlzLmxlbmd0aF0gV2hlcmUgdGhlIG5ldyBCdWZmZXIgd2lsbCBlbmQgKG5vdCBpbmNsdXNpdmUpLiBEZWZhdWx0OiBgYnVmLmxlbmd0aGAuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpc0xlbmd0aCArIHN0YXJ0O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIHN0aWxsIG5lZ2F0aXZlLCB1c2UgMCAodGhhdCBtYXRjaGVzIE5vZGUpXG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmQgPSB0aGlzTGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCA9IHRoaXNMZW5ndGggKyBlbmQ7XG4gICAgICB9IC8vIFNwZWNpZnlpbmcgZW5kIGdyZWF0ZXIgdGhhbiBidWYubGVuZ3RoIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGF0IG9mIGVuZCBlcXVhbCB0byBidWYubGVuZ3RoLlxuXG5cbiAgICAgIGlmIChlbmQgPiB0aGlzTGVuZ3RoKSB7XG4gICAgICAgIGVuZCA9IHRoaXNMZW5ndGg7XG4gICAgICB9IC8vIFdoYXQgaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydD9cblxuXG4gICAgICB2YXIgbGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG5cbiAgICAgIGlmIChsZW5ndGggPD0gMCkge1xuICAgICAgICBsZW5ndGggPSAwOyAvLyByZXR1cm4gZW1wdHkgdmlldyBvZiBCdWZmZXIhIHJldGFpbiBieXRlIG9mZnNldCwgc2V0IGxlbmd0aCB0byAwXG4gICAgICB9IC8vIFdyYXAgdGhlIHNhbWUgVGkuQnVmZmVyIG9iamVjdCBidXQgc3BlY2lmeSB0aGUgc3RhcnQvZW5kIHRvIFwiY3JvcFwiIHdpdGhcblxuXG4gICAgICByZXR1cm4gbmV3QnVmZmVyKHRoaXMuX3RpQnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyBzdGFydCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZD10aGlzLmxlbmd0aF0gV2hlcmUgdGhlIG5ldyBCdWZmZXIgd2lsbCBlbmQgKG5vdCBpbmNsdXNpdmUpLiBEZWZhdWx0OiBgYnVmLmxlbmd0aGAuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YmFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YmFycmF5KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcnByZXRzIGJ1ZiBhcyBhbiBhcnJheSBvZiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlcnMgYW5kIHN3YXBzIHRoZSBieXRlIG9yZGVyIGluLXBsYWNlLlxuICAgICAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDIuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN3YXAxNlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzd2FwMTYoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgIGlmIChsZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IGdldEFkanVzdGVkSW5kZXgodGhpcywgaSk7XG4gICAgICAgIHZhciBzZWNvbmQgPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAxKTtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpLCBzZWNvbmQpO1xuICAgICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAxLCBmaXJzdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcnByZXRzIGJ1ZiBhcyBhbiBhcnJheSBvZiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgYW5kIHN3YXBzIHRoZSBieXRlIG9yZGVyIGluLXBsYWNlLlxuICAgICAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDQuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN3YXAzMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzd2FwMzIoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgIGlmIChsZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHZhciBmaXJzdCA9IGdldEFkanVzdGVkSW5kZXgodGhpcywgaSk7XG4gICAgICAgIHZhciBzZWNvbmQgPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAxKTtcbiAgICAgICAgdmFyIHRoaXJkID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgMik7XG4gICAgICAgIHZhciBmb3VydGggPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAzKTtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpLCBmb3VydGgpO1xuICAgICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAxLCB0aGlyZCk7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDIsIHNlY29uZCk7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDMsIGZpcnN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVycHJldHMgYnVmIGFzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VycyBhbmQgc3dhcHMgdGhlIGJ5dGUgb3JkZXIgaW4tcGxhY2UuXG4gICAgICogVGhyb3dzIEVSUl9JTlZBTElEX0JVRkZFUl9TSVpFIGlmIGJ1Zi5sZW5ndGggaXMgbm90IGEgbXVsdGlwbGUgb2YgOC5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3dhcDY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN3YXA2NCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgICAgaWYgKGxlbmd0aCAlIDggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpKTtcbiAgICAgICAgdmFyIHNlY29uZCA9IGdldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDEpO1xuICAgICAgICB2YXIgdGhpcmQgPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAyKTtcbiAgICAgICAgdmFyIGZvdXJ0aCA9IGdldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDMpO1xuICAgICAgICB2YXIgZmlmdGggPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyA0KTtcbiAgICAgICAgdmFyIHNpeHRoID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgNSk7XG4gICAgICAgIHZhciBzZXZlbnRoID0gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgNik7XG4gICAgICAgIHZhciBlaWdodGggPSBnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyA3KTtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpLCBlaWdodGgpO1xuICAgICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAxLCBzZXZlbnRoKTtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgMiwgc2l4dGgpO1xuICAgICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkgKyAzLCBmaWZ0aCk7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDQsIGZvdXJ0aCk7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIDUsIHRoaXJkKTtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgNiwgc2Vjb25kKTtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpICsgNywgZmlyc3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICAgICAgLy8gVGFrZSBhZHZhbnRhZ2Ugb2Ygc2xpY2Ugd29ya2luZyBvbiBcIkFycmF5LWxpa2VcIiBvYmplY3RzIChqdXRzIGxpa2UgYGFyZ3VtZW50c2ApXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlI0FycmF5LWxpa2Vfb2JqZWN0c1xuICAgICAgICBkYXRhOiBbXS5zbGljZS5jYWxsKHRoaXMpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gVGhlIGNoYXJhY3RlciBlbmNvZGluZyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBUaGUgYnl0ZSBvZmZzZXQgdG8gc3RhcnQgZGVjb2RpbmcgYXRcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmRdIFRoZSBieXRlIG9mZnNldCB0byBzdG9wIGRlY29kaW5nIGF0IChub3QgaW5jbHVzaXZlKS4gYGJ1Zi5sZW5ndGhgIGRlZmF1bHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIGZhc3QgY2FzZSBvZiBubyBhcmdzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlCdWZmZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICBpZiAoc3RhcnQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJzsgLy8gc3RhcnQgaXMgcGFzdCBlbmQgb2YgYnVmZmVyLCByZXR1cm4gZW1wdHkgc3RyaW5nXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA8IDAgfHwgdHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPiBsZW5ndGggfHwgdHlwZW9mIGVuZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gbm8gZW5kIHNwZWNpZmllZCwgb3IgcGFzdCBlbmQgb2YgYnVmZmVyLCB1c2UgbGVuZ3RoIG9mIGJ1ZmZlclxuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9IC8vIGVsc2Uga2VlcCBlbmQgYXMgcGFzc2VkIGluXG5cblxuICAgICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgICByZXR1cm4gJyc7IC8vIGlmIGVuZCBpcyBiZWZvcmUgc3RhcnQgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAgICAgfSAvLyBJZiBzdGFydCAhPT0gMCBhbmQgZW5kICE9PSBsZW5ndGgsIG1heWJlIHdlIHNob3VsZCBkbyBhIEJ1ZmZlci5zdWJhcnJheS9zbGljZSBvdmVyIHRoZSByYW5nZSBhbmQgY2FsbCB0b1N0cmluZygpIG9uIHRoYXQ/XG5cblxuICAgICAgaWYgKHN0YXJ0ICE9PSAwIHx8IGVuZCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgIH0gLy8gYmFzZSBjYXNlLCBzdGFydCBpcyAwLCBlbmQgaXMgbGVuZ3RoXG5cblxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7IC8vIFRocm93IGlmIGJhZCBlbmNvZGluZyFcblxuICAgICAgICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIi5jb25jYXQoZW5jb2RpbmcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04Jykge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBvcmlnaW5hbCB1bmRlcmx5aW5nIGJ1ZmZlciBqdXN0IHJldHVybiBpdCdzIHRvU3RyaW5nKCkgdmFsdWVcbiAgICAgICAgaWYgKHRoaXMuYnl0ZU9mZnNldCA9PT0gMCAmJiB0aGlzLmxlbmd0aCA9PT0gdGhpcy5fdGlCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyLnRvU3RyaW5nKCk7IC8vIHdlIHJldHVybiB1dGYtOCBieSBkZWZhdWx0IG5hdGl2ZWx5XG4gICAgICAgIH0gLy8gaWYgd2UncmUgb2Zmc2V0IG9yIGNyb3BwaW5nIGluIG5heSB3YXksIGNsb25lIHRoZSByYW5nZSBhbmQgcmV0dXJuIHRoYXQgYnVmZmVyJ3MgdG9TdHJpbmcoKVxuXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyLmNsb25lKHRoaXMuYnl0ZU9mZnNldCwgdGhpcy5sZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgdmFyIGJsb2I7IC8vIGlmIHRoaXMgaXMgdGhlIG9yaWdpbmFsIHVuZGVybHlpbmcgYnVmZmVyIGp1c3QgcmV0dXJuIGl0J3MgdG9TdHJpbmcoKSB2YWx1ZVxuXG4gICAgICAgIGlmICh0aGlzLmJ5dGVPZmZzZXQgPT09IDAgJiYgdGhpcy5sZW5ndGggPT09IHRoaXMuX3RpQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIGJsb2IgPSBUaS5VdGlscy5iYXNlNjRlbmNvZGUodGhpcy5fdGlCdWZmZXIudG9CbG9iKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHdlJ3JlIG9mZnNldCBvciBjcm9wcGluZyBpbiBhbnkgd2F5LCBjbG9uZSB0aGUgcmFuZ2UgYW5kIHJldHVybiB0aGF0IGJ1ZmZlcidzIHRvU3RyaW5nKClcbiAgICAgICAgICBibG9iID0gVGkuVXRpbHMuYmFzZTY0ZW5jb2RlKHRoaXMuX3RpQnVmZmVyLmNsb25lKHRoaXMuYnl0ZU9mZnNldCwgdGhpcy5sZW5ndGgpLnRvQmxvYigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBibG9iLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICAgICAgdmFyIGhleFN0ciA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBlYWNoIG9uZSBpcyBhIFwiYnl0ZVwiXG4gICAgICAgICAgdmFyIGhleCA9IChnZXRBZGp1c3RlZEluZGV4KHRoaXMsIGkpICYgMHhmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgIGhleCA9IGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG4gICAgICAgICAgaGV4U3RyICs9IGhleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXhTdHI7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2xhdGluMScgfHwgZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgICAgIHZhciBsYXRpbjFTdHJpbmcgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgLy8gZWFjaCBvbmUgaXMgYSBcImJ5dGVcIlxuICAgICAgICAgIGxhdGluMVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGdldEFkanVzdGVkSW5kZXgodGhpcywgX2kpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXRpbjFTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgICAgICB2YXIgYXNjaWkgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgLy8gd2Ugc3RvcmUgYnl0ZXMgKDgtYml0KSwgYnV0IGFzY2lpIGlzIDctYml0LiBOb2RlIFwibWFza3NcIiB0aGUgbGFzdCBiaXQgb2ZmLCBzbyBsZXQncyBkbyB0aGUgc2FtZVxuICAgICAgICAgIGFzY2lpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBfaTIpICYgMHg3Rik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNjaWk7XG4gICAgICB9IC8vIFVDUzIvVVRGMTZcblxuXG4gICAgICByZXR1cm4gYnVmZmVyVG9VVEYxNlN0cmluZyh0aGlzLl90aUJ1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gaXRlcmF0b3IgZm9yIGJ1ZiB2YWx1ZXMgKGJ5dGVzKVxuICAgICAqIEByZXR1cm5zIHtJdGVyYXRvcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICB2YXIgYnVmZmVyID0gdGhpcztcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIG15SXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldEFkanVzdGVkSW5kZXgoYnVmZmVyLCBuZXh0SW5kZXgpLFxuICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG15SXRlcmF0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGJ1ZmZlciBpcyB1c2VkIGluIGEgZm9yLi5vZiBsb29wLiBEZWxlZ2F0ZXMgdG8gI3ZhbHVlcygpXG4gICAgICogQHJldHVybnMge0l0ZXJhdG9yfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvcixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHN0cmluZyB0byBidWYgYXQgb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgY2hhcmFjdGVyIGVuY29kaW5nIGluIGVuY29kaW5nLlxuICAgICAqIFRoZSBsZW5ndGggcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIElmIGJ1ZiBkaWQgbm90IGNvbnRhaW4gZW5vdWdoIHNwYWNlIHRvXG4gICAgICogZml0IHRoZSBlbnRpcmUgc3RyaW5nLCBvbmx5IHBhcnQgb2Ygc3RyaW5nIHdpbGwgYmUgd3JpdHRlbi4gSG93ZXZlciwgcGFydGlhbGx5IGVuY29kZWRcbiAgICAgKiBjaGFyYWN0ZXJzIHdpbGwgbm90IGJlIHdyaXR0ZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gd3JpdGUgdG8gYGJ1ZmAuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGg9YnVmLmxlbmd0aCAtIG9mZnNldF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2Ygc3RyaW5nXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgY2FwIGBsZW5ndGhgIGF0IHRoZSBsZW5ndGggb2Ygb3VyIGJ1ZmZlclxuICAgICAgICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JzsgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IGByZW1haW5pbmdgIGJ5dGVzIG9mIG91ciBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkvYnVmZmVyXG5cbiAgICAgIHZhciBzcmMgPSBCdWZmZXIuZnJvbShzdHJpbmcsIGVuY29kaW5nKTsgLy8gRklYTUU6IENhbiB3ZSBsZXQgaXQga25vdyB0byBvbmx5IGNvbnZlcnQgYHJlbWFpbmluZ2AgYnl0ZXM/XG4gICAgICAvLyB0aGVuIHN0aWNrIHRoYXQgaW50byBvdXIgYnVmZmVyIHN0YXJ0aW5nIGF0IGBvZmZzZXRgIVxuXG4gICAgICByZXR1cm4gY29weUJ1ZmZlcihzcmMuX3RpQnVmZmVyLCB0aGlzLl90aUJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZURvdWJsZUJFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDgpO1xuICAgICAgZG91YmxlQXJyYXlbMF0gPSB2YWx1ZTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbN10pO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzVdKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNF0pO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzJdKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMV0pO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gICAgICByZXR1cm4gb2Zmc2V0OyAvLyBhdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGFkZGVkIDggdG8gb2Zmc2V0XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlRG91YmxlTEVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVEb3VibGVMRSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG4gICAgICBkb3VibGVBcnJheVswXSA9IHZhbHVlO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzFdKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbMl0pO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzRdKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RG91YmxlQXJyYXlbNV0pO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzddKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVGbG9hdEJFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gICAgICBmbG9hdEFycmF5WzBdID0gdmFsdWU7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbM10pO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzJdKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVsxXSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMF0pO1xuICAgICAgcmV0dXJuIG9mZnNldDsgLy8gYXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhZGRlZCA0IHRvIG9mZnNldFxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUZsb2F0TEVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICAgIGZsb2F0QXJyYXlbMF0gPSB2YWx1ZTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVswXSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMV0pO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzJdKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVszXSk7XG4gICAgICByZXR1cm4gb2Zmc2V0OyAvLyBhdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGFkZGVkIDQgdG8gb2Zmc2V0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUludDgodmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDEpO1xuICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTEyOCwgMTI3KTtcblxuICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgLy8ganVzdCB3cml0ZSBpdCBub3JtYWxseVxuICAgICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVydCBmcm9tIHNpZ25lZCB0byAyJ3MgY29tcGxlbWVudCBiaXRzXG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0LCAweEZGICsgdmFsdWUgKyAxKTsgLy8gbWF4IHZhbHVlLCBwbHVzIHRoZSBuZWdhdGl2ZSBudW1iZXIsIGFkZCBvbmVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldCArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlSW50MTZCRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgPj4+IDgpOyAvLyBqdXN0IHNoaWZ0IG92ZXIgYSBieXRlXG5cbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMSwgdmFsdWUgJiAweEZGKTsgLy8gbWFzayB0byBmaXJzdCBieXRlXG5cbiAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUludDE2TEVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVJbnQxNkxFKHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTtcbiAgICAgIGNoZWNrVmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQsIHZhbHVlICYgMHhGRik7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUludDMyQkVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVJbnQzMkJFKHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICAgIGNoZWNrVmFsdWUodmFsdWUsIC0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3KTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0LCB2YWx1ZSA+Pj4gMjQpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gMTYpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gOCk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDMsIHZhbHVlICYgMHhGRik7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVJbnQzMkxFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gICAgICBjaGVja1ZhbHVlKHZhbHVlLCAtMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0Nyk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgJiAweEZGKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gMTYpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAzLCB2YWx1ZSA+Pj4gMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVJbnRCRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgdmFyIG1pbk1heEJhc2UgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgLW1pbk1heEJhc2UsIG1pbk1heEJhc2UgLSAxKTtcblxuICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICB2YWx1ZSA9IG1pbk1heEJhc2UgKiAyICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0aXBsaWVyID0gMTtcblxuICAgICAgZm9yICh2YXIgaSA9IGJ5dGVMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgICAgICBtdWx0aXBsaWVyICo9IDB4MTAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3cml0ZUludExFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICB2YXIgbWluTWF4QmFzZSA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG4gICAgICBjaGVja1ZhbHVlKHZhbHVlLCAtbWluTWF4QmFzZSwgbWluTWF4QmFzZSAtIDEpO1xuXG4gICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHZhbHVlID0gbWluTWF4QmFzZSAqIDIgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHRpcGxpZXIgPSAxO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgICAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVVSW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAxKTtcbiAgICAgIGNoZWNrVmFsdWUodmFsdWUsIDAsIDI1NSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlVUludDE2QkVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVSW50MTZCRSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gICAgICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA2NTUzNSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgPj4+IDgpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAxLCB2YWx1ZSAmIDB4ZmYpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlVUludDE2TEVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gICAgICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA2NTUzNSk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlVUludDMyQkVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gICAgICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA0Mjk0OTY3Mjk1KTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0LCB2YWx1ZSA+Pj4gMjQpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gMTYpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gOCk7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDMsIHZhbHVlICYgMHhmZik7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVVSW50MzJMRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgICAgIGNoZWNrVmFsdWUodmFsdWUsIDAsIDQyOTQ5NjcyOTUpO1xuICAgICAgc2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBvZmZzZXQsIHZhbHVlICYgMHhmZik7XG4gICAgICBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDE2KTtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgMywgdmFsdWUgPj4+IDI0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlVUludEJFXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMSk7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IDE7XG5cbiAgICAgIGZvciAodmFyIGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICAgICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICAgICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid3JpdGVVSW50TEVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICBjaGVja1ZhbHVlKHZhbHVlLCAwLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxKTtcbiAgICAgIHZhciBtdWx0aXBsaWVyID0gMTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgb2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICAgICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG4gICAgfSAvLyBUT0RPOiBJbXBsZW1lbnQgcmVtYWluaW5nIGluc3RhbmNlIG1ldGhvZHM6XG4gICAgLy8gYnVmLmxhc3RJbmRleE9mKHZhbHVlWywgYnl0ZU9mZnNldF1bLCBlbmNvZGluZ10pXG4gICAgLy8gYnVmLnJlYWRCaWdJbnQ2NEJFKFtvZmZzZXRdKVxuICAgIC8vIGJ1Zi5yZWFkQmlnSW50NjRMRShbb2Zmc2V0XSlcbiAgICAvLyBidWYucmVhZEJpZ1VJbnQ2NEJFKFtvZmZzZXRdKVxuICAgIC8vIGJ1Zi5yZWFkQmlnVUludDY0TEUoW29mZnNldF0pXG4gICAgLy8gYnVmLndyaXRlQmlnSW50NjRCRSh2YWx1ZVssIG9mZnNldF0pXG4gICAgLy8gYnVmLndyaXRlQmlnSW50NjRMRSh2YWx1ZVssIG9mZnNldF0pXG4gICAgLy8gYnVmLndyaXRlQmlnVUludDY0QkUodmFsdWVbLCBvZmZzZXRdKVxuICAgIC8vIGJ1Zi53cml0ZUJpZ1VJbnQ2NExFKHZhbHVlWywgb2Zmc2V0XSlcblxuICB9XSwgW3tcbiAgICBrZXk6IFwiYWxsb2NVbnNhZmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsb2NVbnNhZmUobGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3QnVmZmVyKFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvY1Vuc2FmZVNsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxvYyhsZW5ndGgpIHtcbiAgICAgIHZhciBmaWxsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIGVuY29kaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndXRmOCc7XG4gICAgICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZyk7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld3xBcnJheUJ1ZmZlcnxTaGFyZWRBcnJheUJ1ZmZlcn0gc3RyaW5nIG9yaWdpbmFsIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB3aG9zZSBieXRlIGxlbmd0aCB3ZSBuZWVkIHRvIGdyYWJcbiAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJ5dGVMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcpIHtcbiAgICAgIHZhciBlbmNvZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnO1xuXG4gICAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7IC8vIHJldHVybiBCdWZmZXIncyBsZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDsgLy8gVHlwZWRBcnJheSwgQXJyYXlCdWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyLCBEYXRhVmlld1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICAgICAgc3dpdGNoIChlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgICAgcmV0dXJuIHV0ZjhCeXRlTGVuZ3RoKHN0cmluZyk7XG5cbiAgICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG5cbiAgICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgICBjYXNlICd1Y3MyJzpcbiAgICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAgIGNhc2UgJ3V0ZjE2LWxlJzpcbiAgICAgICAgICByZXR1cm4gMiAqIGxlbmd0aDtcblxuICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICAgIHJldHVybiBsZW5ndGggLyAyO1xuXG4gICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgLy8gU3VidHJhY3QgdXAgdG8gdHdvIHBhZGRpbmcgY2hhcnMgZnJvbSBlbmQgb2Ygc3RyaW5nIVxuICAgICAgICAgIGlmIChsZW5ndGggPiAxICYmIHN0cmluZy5jaGFyQXQobGVuZ3RoIC0gMSkgPT09ICc9Jykge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihsZW5ndGggKiAzIC8gNCk7XG4gICAgICAgIC8vIGRyb3AgZnJhY3Rpb25hbCB2YWx1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKGJ1ZjEsIGJ1ZjIpIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZjEpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcImJ1ZjFcXFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBidWYxKSk7XG4gICAgICB9IC8vIFRPRE86IFdyYXAgVUludDhBcnJheSBhcmdzIGluIGJ1ZmZlcnM/XG5cblxuICAgICAgcmV0dXJuIGJ1ZjEuY29tcGFyZShidWYyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCdWZmZXJbXXxVSW50OEFycmF5W119IGxpc3QgbGlzdCBvZiBCdWZmZXJzIHRvIGNvbmNhdGVuYXRlXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWxMZW5ndGhdIFRvdGFsIGxlbmd0aCBvZiB0aGUgQnVmZmVyIGluc3RhbmNlcyBpbiBsaXN0IHdoZW4gY29uY2F0ZW5hdGVkLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApOyAvLyBvbmUgZW1wdHkgQnVmZmVyIVxuICAgICAgfSAvLyBhbGxvY2F0ZSBvbmUgQnVmZmVyIG9mIGB0b3RhbExlbmd0aGA/IENhcCBhdCB0b3RhbExlbmd0aD9cblxuXG4gICAgICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0b3RhbExlbmd0aCA9IDA7IC8vIGdlbmVyYXRlIHRoZSB0b3RhbCBsZW5ndGggZnJvbSBlYWNoIGJ1ZmZlcidzIGxlbmd0aD9cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxpc3QubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFtfaTNdO1xuICAgICAgICBidWYuY29weShyZXN1bHQsIHBvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb24gKz0gYnVmLmxlbmd0aDtcblxuICAgICAgICBpZiAocG9zaXRpb24gPj0gdG90YWxMZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJbXXxCdWZmZXJ8c3RyaW5nfSB2YWx1ZSB2YWx1ZSB3ZSdyZSB3cmFwcGluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgZW5jb2Rpbmcgb2Ygc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICAgIHZhciBlbmNvZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnO1xuICAgICAgdmFyIHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIuY29uY2F0KGVuY29kaW5nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgIHZhciBibG9iID0gVGkuVXRpbHMuYmFzZTY0ZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICB2YXIgYmxvYlN0cmVhbSA9IFRpLlN0cmVhbS5jcmVhdGVTdHJlYW0oe1xuICAgICAgICAgICAgc291cmNlOiBibG9iLFxuICAgICAgICAgICAgbW9kZTogVGkuU3RyZWFtLk1PREVfUkVBRFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBidWZmZXIgPSBUaS5TdHJlYW0ucmVhZEFsbChibG9iU3RyZWFtKTtcbiAgICAgICAgICBibG9iU3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIG5ld0J1ZmZlcihidWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmdUb0hleEJ5dGVzKHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3QnVmZmVyKFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHR5cGU6IGdldFRpQ29kZWNDaGFyc2V0KGVuY29kaW5nKVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgdmFyIF9idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcblxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfYnVmZmVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlLmNvcHkoX2J1ZmZlciwgMCwgMCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gX2J1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICB2YXIgX2xlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChfbGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0aUJ1ZmZlciA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBsZW5ndGg6IF9sZW5ndGhcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aUJ1ZmZlcltpXSA9IHZhbHVlW2ldICYgMHhGRjsgLy8gbWFzayB0byBvbmUgYnl0ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXdCdWZmZXIodGlCdWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmFwaU5hbWUgJiYgdmFsdWUuYXBpTmFtZSA9PT0gJ1RpLkJ1ZmZlcicpIHtcbiAgICAgICAgICByZXR1cm4gbmV3QnVmZmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFwndmFsdWVcXCcgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZTogXFwnc3RyaW5nXFwnLCBcXCdBcnJheVxcJywgXFwnQnVmZmVyXFwnLCBcXCdUaS5CdWZmZXJcXCcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIHBvc3NpYmxlIGVuY29kaW5nIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzRW5jb2RpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbmNvZGluZyhlbmNvZGluZykge1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVkFMSURfRU5DT0RJTkdTLmluY2x1ZGVzKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IG9iaiBwb3NzaWJsZSBCdWZmZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmouX2lzQnVmZmVyID09PSB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXI7XG59KCk7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTI7XG52YXIgQnVmZmVyTW9kdWxlID0ge1xuICBCdWZmZXIsXG4gIC8vIFRPRE86IEltcGxlbWVudCB0cmFuc2NvZGUoKSFcbiAgdHJhbnNjb2RlOiBmdW5jdGlvbiB0cmFuc2NvZGUoX3NvdXJjZSwgX2Zyb21FbmNvZGluZywgX3RvRW5jb2RpbmcpIHt9LFxuICBJTlNQRUNUX01BWF9CWVRFUzogNTAsXG4gIGtNYXhMZW5ndGg6IDIxNDc0ODM2NDcsXG4gIGtTdHJpbmdNYXhMZW5ndGg6IDEwNzM3NDE3OTksXG4gIGNvbnN0YW50czoge1xuICAgIE1BWF9MRU5HVEg6IDIxNDc0ODM2NDcsXG4gICAgTUFYX1NUUklOR19MRU5HVEg6IDEwNzM3NDE3OTlcbiAgfVxufTtcbi8qKlxuICogU2VhcmNoZXMgYSBCdWZmZXIgZm9yIHRoZSBpbmRleCBvZiBhIHNpbmdsZSBieXRlLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBidWZmZXIgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHNpbmdsZUJ5dGUgYnl0ZSB3ZSdyZSBsb29raW5nIGZvclxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgc3RhcnQgb2Zmc2V0IHdlIHNlYXJjaCBhdFxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuZnVuY3Rpb24gX2luZGV4T2YoYnVmZmVyLCBzaW5nbGVCeXRlLCBvZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGdldEFkanVzdGVkSW5kZXgoYnVmZmVyLCBpKSA9PT0gc2luZ2xlQnl0ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHkgYXZvaWRzIGJpdHdpc2Ugb3BlcmF0aW9ucyBiZWNhdXNlIEpTIGFzc3VtZXMgMzItYml0IHNlcXVlbmNlcyBmb3IgdGhvc2UuXG4gKiBJdCdzIHBvc3NpYmxlIHdlIG1heSBiZSBhYmxlIHRvIHVzZSB0aGVtIHdoZW4gYnl0ZUxlbmd0aCA8IDQgaWYgdGhhdCdzIGZhc3Rlci5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHVuc2lnbmVkVmFsdWUgdmFsdWUgYmVmb3JlIGNvbnZlcnRpbmcgYmFjayB0byBzaWduZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXNcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSB0aGUgc2lnbmVkIHZhbHVlIHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIHVuc2lnbmVkIHZhbHVlJ3MgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCkge1xuICB2YXIgYml0TGVuZ3RoID0gYnl0ZUxlbmd0aCAqIDg7XG4gIHZhciBtYXhQb3NpdGl2ZVZhbHVlID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSk7XG5cbiAgaWYgKHVuc2lnbmVkVmFsdWUgPCBtYXhQb3NpdGl2ZVZhbHVlKSB7XG4gICAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG4gIH1cblxuICB2YXIgbWF4VW5zaWduZWRWYWx1ZSA9IE1hdGgucG93KDIsIGJpdExlbmd0aCk7XG4gIHVuc2lnbmVkVmFsdWUgLT0gbWF4VW5zaWduZWRWYWx1ZTtcbiAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG59XG4vKipcbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSBzcmMgc291cmNlIEJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSBkZXN0IGRlc3RpbmF0aW9uIEJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHN0YXJ0IG9mZnNldCB3ZSdyZSBjb3B5aW5nIHRvIGluIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgdG8gY29weVxuICogQHJldHVybnMge2ludGVnZXJ9IGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgY29waWVkXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgZGVzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIHZhciBkZXN0TGVuZ3RoID0gZGVzdC5sZW5ndGg7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc3RJbmRleCA9IGkgKyBvZmZzZXQ7IC8vIGFyZSB3ZSB0cnlpbmcgdG8gd3JpdGUgcGFzdCBlbmQgb2YgZGVzdGluYXRpb24/IE9yIHJlYWQgcGFzdCBlbmQgb2Ygc291cmNlPyBTdG9wIVxuXG4gICAgaWYgKGRlc3RJbmRleCA+PSBkZXN0TGVuZ3RoIHx8IGkgPj0gc3JjTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXN0W2Rlc3RJbmRleF0gPSBzcmNbaV07XG4gIH1cblxuICByZXR1cm4gaTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB1dGYtOCBzdHJpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuZnVuY3Rpb24gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKSB7XG4gIC8vIEp1c3QgY29udmVydCB0byBhIFRpLkJ1ZmZlciBhbmQgbGV0IGl0IHRlbGwgdXMgdGhlIGxlbmd0aFxuICB2YXIgYnVmID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHR5cGU6IFRpLkNvZGVjLkNIQVJTRVRfVVRGOFxuICB9KTtcbiAgdmFyIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gIGJ1Zi5yZWxlYXNlKCk7IC8vIHJlbGVhc2UgdGhlIGJ1ZmZlciBzaW5jZSB3ZSBqdXN0IG5lZWRlZCB0aGUgbGVuZ3RoXG5cbiAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIGRlc2lyZWQgZW5jb2RpbmcgbmFtZVxuICogQHJldHVybnMge2ludGVnZXJ9IFRpLkNvZGVjIGNvbnN0YW50IHRoYXQgbWFwcyB0byB0aGUgZW5jb2RpbmdcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRpQ29kZWNDaGFyc2V0KGVuY29kaW5nKSB7XG4gIHJldHVybiBUSV9DT0RFQ19NQVAuZ2V0KGVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gYnVmZmVyVG9VVEYxNlN0cmluZyh0aUJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICB2YXIgb3V0ID0gJyc7XG4gIHZhciBpID0gc3RhcnQ7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAvLyB1dGYtMTYvdWNzLTIgaXMgMi1ieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgdmFyIGJ5dGUxID0gdGlCdWZmZXJbaSsrXTtcbiAgICB2YXIgYnl0ZTIgPSB0aUJ1ZmZlcltpKytdO1xuICAgIHZhciBjb2RlX3VuaXQgPSAoYnl0ZTIgPDwgOCkgKyBieXRlMTsgLy8gd2UgbWFzaCB0b2dldGhlciB0aGUgdHdvIGJ5dGVzXG5cbiAgICBvdXQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZV91bml0KTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIGxvb3Agb3ZlciBpbnB1dCwgZXZlcnkgMiBjaGFyYWN0ZXJzLCBwYXJzZSBhcyBhbiBpbnRcbiAqIGJhc2ljYWxseSBlYWNoIHR3byBjaGFyYWN0ZXJzIGFyZSBhIFwiYnl0ZVwiIG9yIGFuIDgtYml0IHVpbnRcbiAqIHdlIGFwcGVuZCB0aGVtIGFsbCB0b2dldGhlciB0byBmb3JtIGEgc2luZ2xlIGJ1ZmZlciBob2xkaW5nIGFsbCB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgc3RyaW5nIHdlJ3JlIGVuY29kaW5nIGluIGhleFxuICogQHJldHVybnMge2ludGVnZXJbXX0gYXJyYXkgb2YgZW5jb2RlZCBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gc3RyaW5nVG9IZXhCeXRlcyh2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoIC8gMjtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbnVtZXJpY1ZhbHVlID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSkge1xuICAgICAgLy8gZHJvcCBiYWQgaGV4IGNoYXJhY3RlcnNcbiAgICAgIGJ5dGVBcnJheS5wdXNoKG51bWVyaWNWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn0gLy8gVXNlIGEgUHJveHkgdG8gaGFjayBhcnJheSBzdHlsZSBpbmRleCBhY2Nlc3NvcnNcblxuXG52YXIgYXJyYXlJbmRleEhhbmRsZXIgPSB7XG4gIGdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG51bSA9IE51bWJlcihwcm9wS2V5KTtcblxuICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKTtcbiAgfSxcblxuICBzZXQodGFyZ2V0LCBwcm9wS2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHByb3BLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbnVtID0gTnVtYmVyKHByb3BLZXkpO1xuXG4gICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICByZXR1cm4gc2V0QWRqdXN0ZWRJbmRleCh0YXJnZXQsIG51bSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BLZXksIHZhbHVlLCByZWNlaXZlcik7XG4gIH0sXG5cbiAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbnVtID0gTnVtYmVyKGtleSk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIC8vIGVuc3VyZSBpdCdzIGEgcG9zaXRpdmUgXCJzYWZlXCIgaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBidWZmZXJcbiAgICAgICAgcmV0dXJuIG51bSA+PSAwICYmIG51bSA8IHRhcmdldC5fdGlCdWZmZXIubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0O1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGdldEFkanVzdGVkSW5kZXgoYnVmLCBpbmRleCkge1xuICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGJ1Zi5fdGlCdWZmZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBidWYuX3RpQnVmZmVyW2luZGV4ICsgYnVmLmJ5dGVPZmZzZXRdO1xufVxuXG5mdW5jdGlvbiBzZXRBZGp1c3RlZEluZGV4KGJ1ZiwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCA+PSAwIHx8IGluZGV4IDwgYnVmLl90aUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBidWYuX3RpQnVmZmVyW2luZGV4ICsgYnVmLmJ5dGVPZmZzZXRdID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFdyYXBzIGNyZWF0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlIGluc2lkZSBhIFByb3h5IHNvIHdlIGNhbiBoYW5kbGUgYXJyYXkgaW5kZXggYWNjZXNzXG4gKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgYXJndW5lbnRzIG90IEJ1ZmZlciBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge0J1ZmZlcn0gd3JhcHBlZCBpbnNpZGUgYSBQcm94eVxuICovXG5cblxuZnVuY3Rpb24gbmV3QnVmZmVyKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShfY29uc3RydWN0KEJ1ZmZlciwgYXJncyksIGFycmF5SW5kZXhIYW5kbGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzZWN1cml0eS9kZXRlY3QtbmV3LWJ1ZmZlclxufVxuLyoqXG4gKiBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB3ZSdyZSBvcGVyYXRpbmcgb25cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHVzZXIgc3VwcGxpZWQgb2Zmc2V0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBpbiByYW5nZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0KGJ1ZmZlciwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhciBlbmRPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gYnl0ZUxlbmd0aDtcblxuICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBlbmRPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBvZiBcXFwib2Zmc2V0XFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgPj0gMCBhbmQgPD0gXCIuY29uY2F0KGVuZE9mZnNldCwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQob2Zmc2V0KSk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSB1c2VyLXN1cHBsaWVkIHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG1pbiBtaW5pbXVtIHZhbGlkIHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG1heCBtYXhpbXVtIHZhbGlkIHZhbHVlXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgXFxcInZhbHVlXFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgPj0gXCIuY29uY2F0KG1pbiwgXCIgYW5kIDw9IFwiKS5jb25jYXQobWF4LCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICB9XG59XG5cbnZhciBidWZmZXJXYXJuaW5nQWxyZWFkeUVtaXR0ZWQgPSBmYWxzZTtcbnZhciBub2RlTW9kdWxlc0NoZWNrQ291bnRlciA9IDA7XG52YXIgYnVmZmVyV2FybmluZyA9ICdCdWZmZXIoKSBpcyBkZXByZWNhdGVkIGR1ZSB0byBzZWN1cml0eSBhbmQgdXNhYmlsaXR5ICcgKyAnaXNzdWVzLiBQbGVhc2UgdXNlIHRoZSBCdWZmZXIuYWxsb2MoKSwgJyArICdCdWZmZXIuYWxsb2NVbnNhZmUoKSwgb3IgQnVmZmVyLmZyb20oKSBtZXRob2RzIGluc3RlYWQuJztcblxuZnVuY3Rpb24gc2hvd0ZsYWdnZWREZXByZWNhdGlvbigpIHtcbiAgaWYgKGJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCB8fCArK25vZGVNb2R1bGVzQ2hlY2tDb3VudGVyID4gMTAwMDAgfHwgaXNJbnNpZGVOb2RlTW9kdWxlcygpKSB7XG4gICAgLy8gV2UgZG9uJ3QgZW1pdCBhIHdhcm5pbmcsIGJlY2F1c2Ugd2UgZWl0aGVyOlxuICAgIC8vIC0gQWxyZWFkeSBkaWQgc28sIG9yXG4gICAgLy8gLSBBbHJlYWR5IGNoZWNrZWQgdG9vIG1hbnkgdGltZXMgd2hldGhlciBhIGNhbGwgaXMgY29taW5nXG4gICAgLy8gICBmcm9tIG5vZGVfbW9kdWxlcyBhbmQgd2FudCB0byBzdG9wIHNsb3dpbmcgZG93biB0aGluZ3MsIG9yXG4gICAgLy8gLSBUaGUgY29kZSBpcyBpbnNpZGUgYG5vZGVfbW9kdWxlc2AuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhidWZmZXJXYXJuaW5nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwMDUnKTtcbiAgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgdXNlZCB0byBoaWphY2sgdGhlIHN0YW5kYXJkIHJlcXVpcmUgdG8gYWxsb3cgZm9yIEpTXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgXCJjb3JlXCIgbW9kdWxlcy5cbiAqXG4gKiBZb3UgYWRkIGEgYmluZGluZyBmcm9tIHRoZSBcImNvcmVcIiBtb2R1bGUgaWQgdG8gdGhlIHVuZGVyIHRoZSBob29kIEpTXG4gKiBpbXBsZW1lbnRhdGlvbi4gV2UgdGhlbiBpbnRlcmNlcHQgcmVxdWlyZSBjYWxscyB0byBoYW5kbGUgcmVxdWVzdHMgZm9yIHRoZXNlIG1vZHVsZXNcbiAqIGFuZCBsYXppbHkgbG9hZCB0aGUgZmlsZS5cbiAqL1xuXG4vKipcbiAqIFVzZWQgYnkgQGZ1bmN0aW9uIGJpbmRPYmplY3RUb0NvcmVNb2R1bGVJZFxuICogQHR5cGUge21hcDxzdHJpbmcsIG9iamVjdD59XG4gKi9cbnZhciBiaW5kaW5ncyA9IG5ldyBNYXAoKTtcbi8qKlxuICogVXNlZCBieSBAZnVuY3Rpb24gcmVkaXJlY3RDb3JlTW9kdWxlSWRUb1BhdGhcbiAqIEB0eXBlIHttYXA8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5cbnZhciByZWRpcmVjdHMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIERvZXMgdGhlIHJlcXVlc3QgbG9vayBsaWtlIGEgdHlwaWNhbCBjb3JlIG1vZHVsZT8gKG5vICcuJyBvciAnLycgY2hhcmFjdGVycylcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIG9yaWdpbmFsIHJlcXVpcmUgcGF0aC9pZFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNIaWphY2thYmxlTW9kdWxlSWQocGF0aCkge1xuICBpZiAoIXBhdGggfHwgcGF0aC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0Q2hhciA9IHBhdGguY2hhckF0KDApO1xuICByZXR1cm4gZmlyc3RDaGFyICE9PSAnLicgJiYgZmlyc3RDaGFyICE9PSAnLyc7XG59IC8vIEhhY2sgcmVxdWlyZSB0byBwb2ludCB0byB0aGlzIGFzIGEgY29yZSBtb2R1bGUgXCJiaW5kaW5nXCJcblxuXG52YXIgb3JpZ2luYWxSZXF1aXJlID0gZ2xvYmFsLnJlcXVpcmU7IC8vIFRoaXMgd29ya3MgZm9yIGlPUyBhcy1pcywgYW5kIGFsc28gaW50ZXJjZXB0cyB0aGUgY2FsbCBvbiBBbmRyb2lkIGZvciB0aS5tYWluLmpzICh0aGUgZmlyc3QgZmlsZSBleGVjdXRlZClcblxuZ2xvYmFsLnJlcXVpcmUgPSBmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICByZXR1cm4gYmluZGluZ3MuZ2V0KG1vZHVsZUlkKTtcbiAgfVxuXG4gIGlmIChyZWRpcmVjdHMuaGFzKG1vZHVsZUlkKSkge1xuICAgIG1vZHVsZUlkID0gcmVkaXJlY3RzLmdldChtb2R1bGVJZCk7XG4gIH1cblxuICByZXR1cm4gb3JpZ2luYWxSZXF1aXJlKG1vZHVsZUlkKTtcbn07XG5cbmlmIChUaS5QbGF0Zm9ybS5uYW1lID09PSAnYW5kcm9pZCcpIHtcbiAgLy8gLi4uIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGhhY2sgaXQgd2hlbiByZXF1aXJpbmcgZnJvbSBvdGhlciBmaWxlcyBmb3IgQW5kcm9pZFxuICB2YXIgb3JpZ2luYWxNb2R1bGVSZXF1aXJlID0gZ2xvYmFsLk1vZHVsZS5wcm90b3R5cGUucmVxdWlyZTtcblxuICBnbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gZnVuY3Rpb24gKHBhdGgsIGNvbnRleHQpIHtcbiAgICBpZiAoYmluZGluZ3MuaGFzKHBhdGgpKSB7XG4gICAgICByZXR1cm4gYmluZGluZ3MuZ2V0KHBhdGgpO1xuICAgIH1cblxuICAgIGlmIChyZWRpcmVjdHMuaGFzKHBhdGgpKSB7XG4gICAgICBwYXRoID0gcmVkaXJlY3RzLmdldChwYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ2luYWxNb2R1bGVSZXF1aXJlLmNhbGwodGhpcywgcGF0aCwgY29udGV4dCk7XG4gIH07XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGJpbmRpbmcgZnJvbSBhIHNob3J0IG1vZHVsZSBpZCB0byBhbiBhbHJlYWR5IGxvYWRlZC9jb25zdHJ1Y3RlZCBvYmplY3QvdmFsdWUgdG8gZXhwb3J0IGZvciB0aGF0IGNvcmUgbW9kdWxlIGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIHRoZSBtb2R1bGUgaWQgdG8gXCJoaWphY2tcIlxuICogQHBhcmFtIHsqfSBiaW5kaW5nIGFuIGFscmVhZHkgY29uc3RydWN0dXJlZCB2YWx1ZS9vYmplY3QgdG8gcmV0dXJuXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3Rlcihtb2R1bGVJZCwgYmluZGluZykge1xuICBpZiAoIWlzSGlqYWNrYWJsZU1vZHVsZUlkKG1vZHVsZUlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWdpc3RlciBmb3IgcmVsYXRpdmUvYWJzb2x1dGUgZmlsZSBwYXRoczsgbm8gbGVhZGluZyAnLicgb3IgJy8nIGFsbG93ZWQgKHdhcyBnaXZlbiBcIi5jb25jYXQobW9kdWxlSWQsIFwiKVwiKSk7XG4gIH1cblxuICBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihcIkFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICdcIi5jb25jYXQobW9kdWxlSWQsIFwiJywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLlwiKSk7XG4gICAgcmVkaXJlY3RzLmRlbGV0ZShtb2R1bGVJZCk7XG4gIH0gZWxzZSBpZiAoYmluZGluZ3MuaGFzKG1vZHVsZUlkKSkge1xuICAgIFRpLkFQSS53YXJuKFwiQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJ1wiLmNvbmNhdChtb2R1bGVJZCwgXCInLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLi4uXCIpKTtcbiAgfVxuXG4gIGJpbmRpbmdzLnNldChtb2R1bGVJZCwgYmluZGluZyk7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGJpbmRpbmcgZnJvbSBhIHNob3J0IG1vZHVsZSBpZCB0byB0aGUgZnVsbCB1bmRlciB0aGUgaG9vZCBmaWxlcGF0aCBpZiBnaXZlbiBhIHN0cmluZy5cbiAqIFRoaXMgYWxsb3dzIGZvciBsYXp5IGluc3RhbnRpYXRpb24gb2YgdGhlIG1vZHVsZSBvbi1kZW1hbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgdGhlIG1vZHVsZSBpZCB0byBcImhpamFja1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggdGhlIGZ1bGwgZmlsZXBhdGggdG8gcmVxdWlyZSB1bmRlciB0aGUgaG9vZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBzaG91bGQgYmUgYW4gYWxyZWFkeSByZXNvbHZlZCBhYnNvbHV0ZSBwYXRoLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBvdGhlcndpc2UgdGhlIGNvbnRleHQgb2YgdGhlIGNhbGwgY291bGQgY2hhbmdlIHdoYXQgZ2V0cyBsb2FkZWQhXG4gKi9cblxuZnVuY3Rpb24gcmVkaXJlY3QobW9kdWxlSWQsIGZpbGVwYXRoKSB7XG4gIGlmICghaXNIaWphY2thYmxlTW9kdWxlSWQobW9kdWxlSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIGZvciByZWxhdGl2ZS9hYnNvbHV0ZSBmaWxlIHBhdGhzOyBubyBsZWFkaW5nICcuJyBvciAnLycgYWxsb3dlZCAod2FzIGdpdmVuIFwiLmNvbmNhdChtb2R1bGVJZCwgXCIpXCIpKTtcbiAgfVxuXG4gIGlmIChiaW5kaW5ncy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oXCJBbm90aGVyIGJpbmRpbmcgaGFzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbW9kdWxlIGlkOiAnXCIuY29uY2F0KG1vZHVsZUlkLCBcIicsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5cIikpO1xuICAgIGJpbmRpbmdzLmRlbGV0ZShtb2R1bGVJZCk7XG4gIH0gZWxzZSBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihcIkFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICdcIi5jb25jYXQobW9kdWxlSWQsIFwiJywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLlwiKSk7XG4gIH1cblxuICByZWRpcmVjdHMuc2V0KG1vZHVsZUlkLCBmaWxlcGF0aCk7XG59XG52YXIgYmluZGluZyA9IHtcbiAgcmVnaXN0ZXIsXG4gIHJlZGlyZWN0XG59O1xuZ2xvYmFsLmJpbmRpbmcgPSBiaW5kaW5nO1xuXG4vLyBMb2FkIGFsbCB0aGUgbm9kZSBjb21wYXRpYmxlIGNvcmUgbW9kdWxlc1xucmVnaXN0ZXIoJ3BhdGgnLCBwYXRoKTtcbnJlZ2lzdGVyKCdvcycsIE9TKTtcbnJlZ2lzdGVyKCd0dHknLCB0dHkpO1xucmVnaXN0ZXIoJ3V0aWwnLCB1dGlsKTtcbnJlZ2lzdGVyKCdhc3NlcnQnLCBhc3NlcnQpO1xucmVnaXN0ZXIoJ2V2ZW50cycsIEV2ZW50RW1pdHRlcik7XG5yZWdpc3RlcignYnVmZmVyJywgQnVmZmVyTW9kdWxlKTsgLy8gUmVnaXN0ZXIgcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyIGFzIGdsb2JhbFxuXG5nbG9iYWwuQnVmZmVyID0gQnVmZmVyTW9kdWxlLkJ1ZmZlcjtcblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKlxuICogRGVzY3JpcHRpb246XG4gKiBUaGlzIHNjcmlwdCBsb2FkcyBhbGwgSmF2YVNjcmlwdCBmaWxlcyBlbmRpbmcgd2l0aCB0aGUgbmFtZSBcIiouYm9vdHN0cmFwLmpzXCIgYW5kIHRoZW4gZXhlY3V0ZXMgdGhlbS5cbiAqIFRoZSBtYWluIGludGVudGlvbiBvZiB0aGlzIGZlYXR1cmUgaXMgdG8gYWxsb3cgSmF2YVNjcmlwdCBmaWxlcyB0byBraWNrLW9mZiBmdW5jdGlvbmFsaXR5IG9yXG4gKiBkaXNwbGF5IFVJIHRvIHRoZSBlbmQtdXNlciBiZWZvcmUgdGhlIFwiYXBwLmpzXCIgZ2V0cyBsb2FkZWQuIFRoaXMgZmVhdHVyZSBpcyB0aGUgQ29tbW9uSlNcbiAqIGVxdWl2YWxlbnQgdG8gVGl0YW5pdW0ncyBBbmRyb2lkIG1vZHVsZSBvbkFwcENyZWF0ZSgpIG9yIGlPUyBtb2R1bGUgbG9hZCgpIGZlYXR1cmVzLlxuICpcbiAqIFVzZS1DYXNlczpcbiAqIC0gQXV0b21hdGljYWxseSBraWNrLW9mZiBhbmFseXRpY3MgZnVuY3Rpb25hbGl0eSBvbiBhcHAgc3RhcnR1cC5cbiAqIC0gRW5zdXJlIFwiR29vZ2xlIFBsYXkgU2VydmljZXNcIiBpcyBpbnN0YWxsZWQvdXBkYXRlZCBvbiBhcHAgc3RhcnR1cCBvbiBBbmRyb2lkLlxuICovXG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gbG9hZCBhbGwgYm9vdHN0cmFwcyBmcm9tIGEgXCJib290c3RyYXAuanNvblwiIGZpbGUgY3JlYXRlZCBieSB0aGUgYXBwIGJ1aWxkIHN5c3RlbS5cbiAqIFRoaXMgaXMgYW4gb3B0aW9uYWwgZmVhdHVyZSBhbmQgaXMgdGhlIGZhc3Rlc3QgbWV0aG9kIG9mIGFjcXVpcmluZyBib29zdHJhcHMgY29uZmlndXJlZCBmb3IgdGhlIGFwcC5cbiAqIFRoaXMgSlNPTiBmaWxlLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhpcyBzY3JpcHQuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHJlcXVpcmUoKSBjb21wYXRpYmxlIHN0cmluZ3MgaWYgYm9vdHN0cmFwcyB3ZXJlIHN1Y2Nlc3NmdWxseSBsb2FkZWQgZnJvbSBKU09OLlxuICogUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiBKU09OIGZpbGUgd2FzIGZvdW5kLCBidXQgbm8gYm9vdHN0cmFwcyB3ZXJlIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBSZXR1cm5zIG51bGwgaWYgSlNPTiBmaWxlIHdhcyBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGZldGNoU2NyaXB0c0Zyb21Kc29uKCkge1xuICB2YXIgSlNPTl9GSUxFX05BTUUgPSAnYm9vdHN0cmFwLmpzb24nO1xuXG4gIHRyeSB7XG4gICAgdmFyIGpzb25GaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5LCBcInRpLmludGVybmFsL1wiLmNvbmNhdChKU09OX0ZJTEVfTkFNRSkpO1xuXG4gICAgaWYgKGpzb25GaWxlLmV4aXN0cygpKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBKU09OLnBhcnNlKGpzb25GaWxlLnJlYWQoKS50ZXh0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3Muc2NyaXB0cykpIHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLnNjcmlwdHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgVGkuQVBJLmVycm9yKFwiRmFpbGVkIHRvIHJlYWQgXFxcIlwiLmNvbmNhdChKU09OX0ZJTEVfTkFNRSwgXCJcXFwiLiBSZWFzb246IFwiKS5jb25jYXQoZXJyb3IubWVzc2FnZSkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIHRoZSBcIlJlc291cmNlc1wiIGRpcmVjdG9yeSBmb3IgYWxsIFwiKi5ib290c3RyYXAuanNcIiBmaWxlcy5cbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVxdWlyZSgpIGNvbXBhdGlibGUgc3RyaW5ncyBmb3IgZWFjaCBib290c3RyYXAgZm91bmQgaW4gdGhlIHNlYXJjaC5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gYm9vdHN0cmFwIGZpbGVzIHdlcmUgZm91bmQuXG4gKi9cblxuXG5mdW5jdGlvbiBmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5KCkge1xuICB2YXIgcmVzb3VyY2VEaXJlY3RvcnkgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnkpO1xuICB2YXIgcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoID0gcmVzb3VyY2VEaXJlY3RvcnkubmF0aXZlUGF0aC5sZW5ndGg7XG4gIHZhciBib290c3RyYXBTY3JpcHRzID0gW107XG5cbiAgZnVuY3Rpb24gbG9hZEZyb20oZmlsZSkge1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBpZiAoZmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3RvcnkuIFJlY3Vyc2l2ZWx5IGxvb2sgZm9yIGJvb3RzdHJhcCBmaWxlcyB1bmRlciBpdC5cbiAgICAgICAgdmFyIGZpbGVOYW1lQXJyYXkgPSBmaWxlLmdldERpcmVjdG9yeUxpc3RpbmcoKTtcblxuICAgICAgICBpZiAoZmlsZU5hbWVBcnJheSkge1xuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBmaWxlTmFtZUFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgbG9hZEZyb20oVGkuRmlsZXN5c3RlbS5nZXRGaWxlKGZpbGUubmF0aXZlUGF0aCwgZmlsZU5hbWVBcnJheVtpbmRleF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsZS5uYW1lLnNlYXJjaCgvLmJvb3RzdHJhcC5qcyQvKSA+PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBib290c3RyYXAgZmlsZS5cbiAgICAgICAgLy8gQ29udmVydCBpdHMgcGF0aCB0byBzb21ldGhpbmcgbG9hZGFibGUgdmlhIHJlcXVpcmUoKSBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheS5cbiAgICAgICAgdmFyIGJvb3RzdHJhcFBhdGggPSBmaWxlLm5hdGl2ZVBhdGg7XG4gICAgICAgIGJvb3RzdHJhcFBhdGggPSBib290c3RyYXBQYXRoLnN1YnN0cihyZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGgsIGJvb3RzdHJhcFBhdGgubGVuZ3RoIC0gcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoIC0gJy5qcycubGVuZ3RoKTtcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0cy5wdXNoKGJvb3RzdHJhcFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWRGcm9tKHJlc291cmNlRGlyZWN0b3J5KTtcbiAgcmV0dXJuIGJvb3RzdHJhcFNjcmlwdHM7XG59XG4vKipcbiAqIE5vbi1ibG9ja2luZyBmdW5jdGlvbiB3aGljaCBsb2FkcyBhbmQgZXhlY3V0ZXMgYWxsIGJvb3RzdHJhcCBzY3JpcHRzIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmaW5pc2hlZCBDYWxsYmFjayB0byBiZSBpbnZva2VkIG9uY2UgYWxsIGJvb3RzdHJhcHMgaGF2ZSBmaW5pc2hlZCBleGVjdXRpbmcuIENhbm5vdCBiZSBudWxsLlxuICovXG5cblxuZnVuY3Rpb24gbG9hZEFzeW5jKGZpbmlzaGVkKSB7XG4gIC8vIEFjcXVpcmUgYW4gYXJyYXkgb2YgYWxsIGJvb3RzdHJhcCBzY3JpcHRzIGluY2x1ZGVkIHdpdGggdGhlIGFwcC5cbiAgLy8gLSBGb3IgYmVzdCBwZXJmb3JtYW5jZSwgYXR0ZW1wdCB0byBmZXRjaCBzY3JpcHRzIHZpYSBhbiBvcHRpb25hbCBKU09OIGZpbGUgY3JlYXRlZCBieSB0aGUgYnVpbGQgc3lzdGVtLlxuICAvLyAtIElmIEpTT04gZmlsZSBub3QgZm91bmQgKHdpbGwgcmV0dXJuIG51bGwpLCB0aGVuIHNlYXJjaCBcIlJlc291cmNlc1wiIGRpcmVjdG9yeSBmb3IgYm9vdHN0cmFwIGZpbGVzLlxuICB2YXIgYm9vdHN0cmFwU2NyaXB0cyA9IGZldGNoU2NyaXB0c0Zyb21Kc29uKCk7XG5cbiAgaWYgKCFib290c3RyYXBTY3JpcHRzKSB7XG4gICAgYm9vdHN0cmFwU2NyaXB0cyA9IGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKTtcbiAgfSAvLyBEbyBub3QgY29udGludWUgaWYgbm8gYm9vdHN0cmFwcyB3ZXJlIGZvdW5kLlxuXG5cbiAgaWYgKCFib290c3RyYXBTY3JpcHRzIHx8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoIDw9IDApIHtcbiAgICBmaW5pc2hlZCgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBTb3J0IHRoZSBib290c3RyYXBzIHNvIHRoYXQgdGhleSdsbCBiZSBsb2FkZWQgaW4gYSBjb25zaXN0ZW50IG9yZGVyIGJldHdlZW4gcGxhdGZvcm1zLlxuXG5cbiAgYm9vdHN0cmFwU2NyaXB0cy5zb3J0KCk7IC8vIExvYWRzIGFsbCBib290c3RyYXAgc2NyaXB0cyBmb3VuZC5cblxuICBmdW5jdGlvbiBsb2FkQm9vdHN0cmFwU2NyaXB0cyhmaW5pc2hlZCkge1xuICAgIHZhciBib290c3RyYXBJbmRleCA9IDA7XG5cbiAgICBmdW5jdGlvbiBkb0xvYWQoKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGxvYWQgYWxsIGJvb3RzdHJhcCBzY3JpcHRzLlxuICAgICAgd2hpbGUgKGJvb3RzdHJhcEluZGV4IDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTG9hZCB0aGUgbmV4dCBib290c3RyYXAuXG4gICAgICAgIHZhciBmaWxlTmFtZSA9IGJvb3RzdHJhcFNjcmlwdHNbYm9vdHN0cmFwSW5kZXhdO1xuXG4gICAgICAgIHZhciBib290c3RyYXAgPSByZXF1aXJlKGZpbGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzZWN1cml0eS9kZXRlY3Qtbm9uLWxpdGVyYWwtcmVxdWlyZVxuICAgICAgICAvLyBJbnZva2UgdGhlIGJvb3RzdHJhcCdzIGV4ZWN1dGUoKSBtZXRob2QgaWYgaXQgaGFzIG9uZS4gKFRoaXMgaXMgb3B0aW9uYWwuKVxuICAgICAgICAvLyBXZSBtdXN0IHdhaXQgZm9yIHRoZSBnaXZlbiBjYWxsYmFjayB0byBiZSBpbnZva2VkIGJlZm9yZSBsb2FkaW5nIHRoZSBuZXh0IHNjcmlwdC5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBleHBlY3RlZCB0byBiZSB1c2VkIHRvIGRpc3BsYXkgVUkgdG8gdGhlIGVuZC11c2VyLlxuXG5cbiAgICAgICAgaWYgKGJvb3RzdHJhcC5leGVjdXRlKSB7XG4gICAgICAgICAgYm9vdHN0cmFwLmV4ZWN1dGUob25Cb290c3RyYXBFeGVjdXRpb25GaW5pc2hlZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGUgY3VycmVudCBib290c3RyYXAuIFRpbWUgdG8gbG9hZCB0aGUgbmV4dCBvbmUuXG5cblxuICAgICAgICBib290c3RyYXBJbmRleCsrO1xuICAgICAgfSAvLyBJbnZva2UgZ2l2ZW4gY2FsbGJhY2sgdG8gaW5mb3JtIGNhbGxlciB0aGF0IGFsbCBsb2FkaW5nIGlzIGRvbmUuXG5cblxuICAgICAgZmluaXNoZWQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkKCkge1xuICAgICAgLy8gTGFzdCBib290c3RyYXAgaGFzIGZpbmlzaGVkIGV4ZWN1dGlvbi4gVGltZSB0byBsb2FkIHRoZSBuZXh0IG9uZS5cbiAgICAgIC8vIE5vdGU6IEFkZCBhIHRpbnkgZGVsYXkgc28gd2hhdGV2ZXIgVUkgdGhlIGxhc3QgYm9vdHN0cmFwIGxvYWRlZCBoYXMgdGltZSB0byBjbG9zZS5cbiAgICAgIGJvb3RzdHJhcEluZGV4Kys7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvTG9hZCgpO1xuICAgICAgfSwgMSk7XG4gICAgfVxuXG4gICAgZG9Mb2FkKCk7XG4gIH0gLy8gV2UndmUgZmluaXNoZWQgbG9hZGluZy9leGVjdXRpbmcgYWxsIGJvb3RzdHJhcCBzY3JpcHRzLlxuICAvLyBJbmZvcm0gY2FsbGVyIGJ5IGludm9raW5nIHRoZSBjYWxsYmFjayBnaXZlbiB0byBsb2FkQXN5bmMoKS5cblxuXG4gIGxvYWRCb290c3RyYXBTY3JpcHRzKGZpbmlzaGVkKTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKlxuICogVGhpcyBzY3JpcHQgaXMgbG9hZGVkIG9uIGFwcCBzdGFydHVwIG9uIGFsbCBwbGF0Zm9ybXMuIEl0IGlzIHVzZWQgdG8gZG8gdGhlIGZvbGxvd2luZzpcbiAqIC0gUHJvdmlkZSBjb25zaXN0ZW50IHN0YXJ0dXAgYmVoYXZpb3IgYmV0d2VlbiBwbGF0Zm9ybXMsIHN1Y2ggYXMgbG9nZ2luZyBUaXRhbml1bSB2ZXJzaW9uLlxuICogLSBMb2FkIFRpdGFuaXVtJ3MgY29yZSBKYXZhU2NyaXB0IGV4dGVuc2lvbnMgc2hhcmVkIGJ5IGFsbCBwbGF0Zm9ybXMuXG4gKiAtIFByb3ZpZGUgXCIqLmJvb3RzdHJhcC5qc1wiIHNjcmlwdCBzdXBwb3J0LiAoU2ltaWxhciB0byBuYXRpdmUgbW9kdWxlIG9uQXBwQ3JlYXRlKCkvbG9hZCgpIHN1cHBvcnQuKVxuICogLSBMb2FkIHRoZSBhcHAgZGV2ZWxvcGVyJ3MgbWFpbiBcImFwcC5qc1wiIHNjcmlwdCBhZnRlciBkb2luZyBhbGwgb2YgdGhlIGFib3ZlLlxuICovXG4vLyBMb2cgdGhlIGFwcCBuYW1lLCBhcHAgdmVyc2lvbiwgYW5kIFRpdGFuaXVtIHZlcnNpb24gb24gc3RhcnR1cC5cblRpLkFQSS5pbmZvKFwiXCIuY29uY2F0KFRpLkFwcC5uYW1lLCBcIiBcIikuY29uY2F0KFRpLkFwcC52ZXJzaW9uLCBcIiAoUG93ZXJlZCBieSBUaXRhbml1bSBcIikuY29uY2F0KFRpLnZlcnNpb24sIFwiLlwiKS5jb25jYXQoVGkuYnVpbGRIYXNoLCBcIilcIikpOyAvLyBBdHRlbXB0IHRvIGxvYWQgY3Jhc2ggYW5hbHl0aWNzIG1vZHVsZS5cbi8vIE5PVEU6IFRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdCBtb2R1bGUgdGhhdCBsb2FkcyBvbiBzdGFydHVwLlxuXG50cnkge1xuICByZXF1aXJlKCdjb20uYXBwY2VsZXJhdG9yLmFjYScpO1xufSBjYXRjaCAoZSkge30gLy8gQ291bGQgbm90IGxvYWQgbW9kdWxlLCBzaWxlbnRseSBpZ25vcmUgZXhjZXB0aW9uLlxubG9hZEFzeW5jKGZ1bmN0aW9uICgpIHtcbiAgLy8gV2UndmUgZmluaXNoZWQgbG9hZGluZy9leGVjdXRpbmcgYWxsIGJvb3RzdHJhcCBzY3JpcHRzLlxuICAvLyBXZSBjYW4gbm93IHByb2NlZWQgdG8gcnVuIHRoZSBtYWluIFwiYXBwLmpzXCIgc2NyaXB0LlxuICByZXF1aXJlKCcuL2FwcCcpOyAvLyBUaGlzIGV2ZW50IGlzIHRvIGJlIGZpcmVkIGFmdGVyIFwiYXBwLmpzXCIgZXhlY3V0aW9uLiBSZWFzb25zOlxuICAvLyAtIEFsbG93IHN5c3RlbSB0byBxdWV1ZSBzdGFydHVwIHJlbGF0ZWQgZXZlbnRzIHVudGlsIFwiYXBwLmpzXCIgaGFzIGhhZCBhIGNoYW5jZSB0byBhZGQgbGlzdGVuZXJzLlxuICAvLyAtIEZvciBBbGxveSBhcHBzLCB3ZSBub3cga25vdyB0aGF0IEFsbG95IGhhcyBiZWVuIGluaXRpYWxpemVkIGFuZCBpdHMgZ2xvYmFscyB3ZXJlIGFkZGVkLlxuXG5cbiAgVGkuQXBwLmZpcmVFdmVudCgnc3RhcnRlZCcpO1xufSk7XG4iXSwic291cmNlUm9vdCI6IkM6XFxQcm9ncmFtRGF0YVxcVGl0YW5pdW1cXG1vYmlsZXNka1xcd2luMzJcXDguMi4xLkdBXFxjb21tb25cXFJlc291cmNlcyJ9
